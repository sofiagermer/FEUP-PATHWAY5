<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>lib-json (SICStus Prolog)</title>

<meta name="description" content="lib-json (SICStus Prolog)">
<meta name="keywords" content="lib-json (SICStus Prolog)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Predicate-Index.html#Predicate-Index" rel="index" title="Predicate Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="The-Prolog-Library.html#The-Prolog-Library" rel="up" title="The Prolog Library">
<link href="lib_002djsonrpc.html#lib_002djsonrpc" rel="next" title="lib-jsonrpc">
<link href="Deprecated-Jasper-Predicates.html#Deprecated-Jasper-Predicates" rel="prev" title="Deprecated Jasper Predicates">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>

<body lang="en">
<a name="lib_002djson"></a>
<hr>
<a name="JSON-format-serialization_002d_002d_002dlibrary_0028json_0029"></a>
<h3 class="section">10.21 JSON format serialization&mdash;<code>library(json)</code></h3>
<p>This library module provides some utilities for reading and writing structured data using the
<a href="https://json.org/">JSON</a> (JavaScript Object Notation) serialization format.
The library module is part of SICStus Prolog since release 4.5.0.
</p>
<p>JSON is a light-weight, language independent, data-interchange format with good support in many environments.
As such, it is a convenient format when transferring data between Prolog and other programming languages.
The format is specified in <a href="https://www.ecma-international.org/publications/standards/Ecma-404.htm">ECMA-404</a>
and in <a href="https://www.rfc-editor.org/info/rfc8259">RFC 8259</a>.
</p>
<p>The Prolog representation of JSON values is as follows:
</p><dl compact="compact">
<dt><var>Number</var></dt>
<dd><p>A JSON number is represented as the corresponding Prolog number; as a float
when the JSON number has an exponent or a fractional part, otherwise as an integer.
</p>
</dd>
<dt><var>String</var></dt>
<dd><p>A JSON string is represented as the corresponding Prolog atom (escaped surrogate pairs are combined into the corresponding Unicode code point).
</p>
</dd>
<dt><var>Array</var></dt>
<dd><p>A JSON array is represented as a list of the corresponding Prolog terms.
</p>
</dd>
<dt><var>Object</var></dt>
<dd><p>A JSON object is a sequence of <code><var>name</var>:<var>value</var></code> pairs, where each name is a JSON string and each value is an arbitrary JSON value.
It is represented as a term <code>json(<var>Members</var>)</code> where <var>Members</var> is a list of <code><var>Name</var>=<var>Value</var></code> pairs,
where <var>Name</var> is a representation of the JSON string name and <var>Value</var> is a representation of the JSON value.
</p>
</dd>
<dt><code>null</code></dt>
<dt><code>true</code></dt>
<dt><code>false</code></dt>
<dd><p>These special JSON literals are, by default, translated to the Prolog terms <code>@(null)</code>,
<code>@(true)</code>, and <code>@(false)</code>, respectively.
</p></dd>
</dl>

<p>Examples:
</p><div class="example">
<pre class="example"><kbd>123</kbd> &rArr; <code>123</code>

<kbd>12.3</kbd> &rArr; <code>12.3</code>

<kbd>12E3</kbd> &rArr; <code>12.0E3</code>

<kbd>&quot;foo&quot;</kbd> &rArr; <code>'foo'</code>

<kbd>null</kbd> &rArr; <code>@(null)</code>

<kbd>[&quot;a&quot;, 2, &quot;bar&quot;]</kbd> &rArr; <code>['a', 2, 'bar']</code>

<kbd>{&quot;age&quot;: 42,</kbd>
<kbd> &quot;name&quot;: {&quot;first&quot;:&quot;Kim&quot;, &quot;last&quot;:&quot;Jones&quot;},</kbd>
<kbd> &quot;children&quot;: [&quot;Lisa&quot;,&quot;Jim&quot;,&quot;John&quot;]</kbd>
<kbd>}</kbd>
&rArr;
<code>json(['age'=42,
      'name'=json(['first'='Kim', 'last'='Jones']),
      'children'=['Lisa','Jim','John']])</code>

</pre></div>


<p>It is possible to specify other Prolog representations of a JSON value using the option argument. See below for details.
</p>
<a name="Options-1"></a>
<h4 class="subsection">10.21.1 Options</h4>

<p>The following options are used. They are valid for all predicates that takes options, unless stated otherwise.
</p>
<dl compact="compact">
<dt><code>compact(<var>Boolean</var>)</code></dt>
<dd><p>Valid values for <var>Boolean</var> are <code>true</code> and <code>false</code> (default).
</p>
<p>If <code>false</code> (default), JSON values are written with extra whitespace and end-of-line characters to make it easier for humans to read.
The details of the non-compact format is subject to change without notice.
</p>
<p>If <code>true</code>, JSON values are written with a minimum of whitespace.
Since this implies that no end-of-line characters will be written, it makes it possible to read the resulting JSON as a single line.
</p>
<p>Only valid for predicates that write.
</p>
</dd>
<dt><code>ascii(<var>Boolean</var>)</code></dt>
<dd><p>Valid values for <var>Boolean</var> are <code>true</code> (default) and <code>false</code>.
</p>
<p>If <code>true</code> (default), JSON values are written using only 7-bit ASCII characters, which makes the format less sensitive to stream encodings.
</p>
<p>If <code>false</code>, JSON values are written using full Unicode. In this case any streams should use UTF-8 encoding.
</p>
<p>Only valid for predicates that write.
</p>
</dd>
<dt><code>null(<var>X</var>)</code></dt>
<dt><code>true(<var>X</var>)</code></dt>
<dt><code>false(<var>X</var>)</code></dt>
<dd><p>The specified term <var>X</var>, which may be a variable, is used for representing the corresponding JSON literal.
</p>
</dd>
<dt><code>array_tag(<var>Tag</var>)</code></dt>
<dd><p>The <var>Tag</var> must be an atom.
</p>
<p>A JSON array is represented as the compound term <code><var>Tag</var>(<var>Elements</var>)</code>, where <var>Elements</var> is a list of the representations of the array elements.
This may be useful if you need to be able to distinguish between an empty JSON array (<code>[]</code>), and a JSON string <code>&quot;[]&quot;</code>,
since these have the same Prolog representation (the atom <code>[]</code>) in the default representation.
</p>
<p>If this option is not specified (the default), then JSON arrays are represented as a list of the representations of the array elements.
</p>
</dd>
<dt><code>object_tag(<var>Tag</var>)</code></dt>
<dd><p>The <var>Tag</var> must be an atom. <var>Tag</var> defaults to <code>'json'</code>.
</p>
<p>A JSON object is represented as the compound term <code><var>Tag</var>(<var>Members</var>)</code>,
where <var>Members</var> is a list of <code><var>Name</var>=<var>Value</var></code> pairs,
where <var>Name</var> is a representation of the JSON string name and <var>Value</var> is a representation of the JSON value.
</p>
</dd>
<dt><code>width(<var>Width</var>)</code></dt>
<dd><p>This option is present for compatibility with other systems.
</p>
<p>If <var>Width</var> is <code>0</code> (zero), it is treated as a synonym for <code>compact(true)</code>. Otherwise, the option is currently ignored.
</p>
<p>Only valid for predicates that write.
</p>
</dd>
<dt><code>value_string_as(<var>Value</var>)</code></dt>
<dt><code>step(<var>Value</var>)</code></dt>
<dt><code>tab(<var>Value</var>)</code></dt>
<dt><code>serialize_unknown(<var>Value</var>)</code></dt>
<dd>
<p>These options are present for compatibility with other systems. They are currently ignored.
</p>
<p>Only valid for predicates that write.
</p></dd>
</dl>

<a name="Exported-Predicates"></a>
<h4 class="subsection">10.21.2 Exported Predicates</h4>

<p>The <var>Options</var> argument is described in the module documentation.
</p>
<dl compact="compact">
<dt><code>json_read(<var>+Stream</var>, <var>-Term</var>)</code></dt>
<dt><code>json_read(<var>+Stream</var>, <var>-Term</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005fread_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005fread_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Reads a single JSON value from the text stream <var>Stream</var>
and unifies it with <var>Term</var>.
</p></dd>
<dt><code>json_write(<var>+Stream</var>, <var>+Term</var>)</code></dt>
<dt><code>json_write(<var>+Stream</var>, <var>+Term</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005fwrite_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005fwrite_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Write the JSON value <var>Term</var> to the text stream <var>Stream</var>.
</p></dd>
<dt><code>is_json_term(<var>+Term</var>)</code></dt>
<dt><code>is_json_term(<var>+Term</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-is_005fjson_005fterm_002f_005b1_002c2_005d-_0028json_0029-1"></a>
<a name="index-is_005fjson_005fterm_002f_005b1_002c2_005d-_0028json_0029"></a>

<p>True if the <var>Term</var> is a valid representation of a JSON value.
</p></dd>
<dt><code>json_to_codes(<var>+Term</var>, <var>-JSONCodes</var>)</code></dt>
<dt><code>json_to_codes(<var>+Term</var>, <var>-JSONCodes</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005fto_005fcodes_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005fto_005fcodes_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Writes <var>Term</var> as JSON and unifies <var>JSONCodes</var> with the list of resulting character codes.
</p></dd>
<dt><code>json_to_atom(<var>+Term</var>, <var>-JSONAtom</var>)</code></dt>
<dt><code>json_to_atom(<var>+Term</var>, <var>-JSONAtom</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005fto_005fatom_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005fto_005fatom_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Writes <var>Term</var> as JSON and unifies <var>JSONAtom</var> with an atom consisting of the resulting character codes.
</p></dd>
<dt><code>json_from_codes(<var>+JSONCodes</var>, <var>-Term</var>)</code></dt>
<dt><code>json_from_codes(<var>+JSONCodes</var>, <var>-Term</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005ffrom_005fcodes_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005ffrom_005fcodes_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Converts a JSON text, represented as the list of character codes <var>JSONCodes</var>, into the corresponding Prolog term <var>Term</var>.
</p></dd>
<dt><code>json_from_atom(<var>+JSONAtom</var>, <var>-Term</var>)</code></dt>
<dt><code>json_from_atom(<var>+JSONAtom</var>, <var>-Term</var>, <var>+Options</var>)</code></dt>
<dd>
<a name="index-json_005ffrom_005fatom_002f_005b2_002c3_005d-_0028json_0029-1"></a>
<a name="index-json_005ffrom_005fatom_002f_005b2_002c3_005d-_0028json_0029"></a>

<p>Converts a JSON text, represented as the character codes of <var>JSONAtom</var>, into the corresponding Prolog term <var>Term</var>.
</p></dd>
</dl>
<p>A small example:
</p><div class="example">
<pre class="example">| ?- <kbd>JSONCodes = &quot;{\&quot;foo\&quot;: 42, \&quot;bar\&quot;: null}&quot;,</kbd>
     <kbd>json_from_codes(JSONCodes, JSONTerm),</kbd>
     <kbd>json_to_atom(JSONTerm, JSONAtom, [compact(true)]).</kbd>
JSONCodes = [123,34,102,111,111,34,58,32,52,50|...],
JSONTerm = json([foo=42,bar= @(null)]),
JSONAtom = '{&quot;foo&quot;:42,&quot;bar&quot;:null}' ?
yes
| ?-
</pre></div>

<hr>



<div class="logo">
<a href="https://sicstus.sics.se/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
<li><a href="lib_002djsonrpc.html#lib_002djsonrpc" accesskey="n" rel="next">Next</a>
<li><a href="lib_002djasper.html#lib_002djasper" accesskey="p" rel="prev">Previous</a>
<li><a href="The-Prolog-Library.html#The-Prolog-Library" accesskey="u" rel="up">Up</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@ri.se?subject=Documentation%20feedback%20on%20html/sicstus/lib_002djson.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/lib_002djson.html%20in%20User's%20Manual.">Send feedback on this subject.</a>
</body>
</html>
