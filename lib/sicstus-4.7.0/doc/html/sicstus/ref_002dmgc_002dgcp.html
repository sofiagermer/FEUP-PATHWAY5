<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ref-mgc-gcp (SICStus Prolog)</title>

<meta name="description" content="ref-mgc-gcp (SICStus Prolog)">
<meta name="keywords" content="ref-mgc-gcp (SICStus Prolog)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Predicate-Index.html#Predicate-Index" rel="index" title="Predicate Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="ref_002dmgc.html#ref_002dmgc" rel="up" title="ref-mgc">
<link href="ref_002dmgc_002degc.html#ref_002dmgc_002degc" rel="next" title="ref-mgc-egc">
<link href="ref_002dmgc_002dove_002dsta.html#ref_002dmgc_002dove_002dsta" rel="prev" title="ref-mgc-ove-sta">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>

<body lang="en">
<a name="ref_002dmgc_002dgcp"></a>
<hr>
<a name="Garbage-Collection-and-Programming-Style"></a>
<h4 class="subsection">4.10.2 Garbage Collection and Programming Style</h4>

<a name="index-garbage-collection-2"></a>


<a name="index-statistics_002f_005b0_002c2_005d-_0028built_002din_0029-3"></a>
<a name="index-statistics_002f_005b0_002c2_005d-_0028built_002din_0029-1"></a>


<p>The availability of garbage collection can lead to a more natural 
programming style.  Without garbage collection, a procedure that generates 
global stack garbage may have to be executed in a failure-driven loop.
Failure-driven loops minimize global stack usage from iteration to iteration of
a loop via SICStus Prolog&rsquo;s automatic recovery of global stack space on failure.
For instance, in the following procedure
<code>echo/0</code> echoes Prolog terms until it reads an end-of-file character.
It uses a failure-driven loop to recover inaccessible global stack space.
</p><div class="example">
<pre class="example">echo :- repeat, 
        read(Term), 
        echo_term(Term), 
        !.

echo_term(Term) :-
        Term == end_of_file.
echo_term(Term) :-
        writeq(Term), nl, 
        fail.
</pre></div>

<p>Any global stack garbage generated by <code>read/1</code> or <code>write/1</code> 
is automatically reclaimed by the failure of each iteration.  
</p>
<p>Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to 
write a clearer version of <code>echo/0</code> using recursion instead, as in
</p><div class="example">
<pre class="example">echo :- read(Term), 
        echo_term(Term).

echo_term(Term) :-
        Term == end_of_file, 
        !.
echo_term(Term) :-
        writeq(Term), nl, 
        echo.
</pre></div>

<p>Without garbage collection the more 
natural recursive loop accumulates global stack garbage that cannot be reclaimed 
automatically.  While it is unlikely that this trivial example will run out 
of global stack space, larger and more practical applications may be unable to use 
the clearer
recursive style without garbage collection.  With garbage collection, all 
inaccessible global stack space will be reclaimed by the garbage collector.
</p>
<p>Using recursion rather than failure-driven loops can improve programming
style further.  We might want to write a predicate that reads terms and 
collects them in a list.  This is naturally done in a recursive
loop by accumulating results in a list that is passed from iteration
to iteration.  For instance, 
</p><div class="example">
<pre class="example">collect(List) :-
        read(Term), 
        collect_term(Term, List).

collect_term(Term, []) :-
        Term == end_of_file, 
        !.
collect_term(Term, [Term|List0]) :-
        collect(List0).
</pre></div>

<p>For more complex applications this sort of construction might prove unusable
without garbage collection.  Instead, we may be forced to use a 
failure-driven loop with side effects to store partial results, as in 
the following much less readable version of <code>collect/1</code>:
</p><div class="example">
<pre class="example">collect(List) :-
        repeat, 
        read(Term), 
        store_term(Term), 
        !, 
        collect_terms(List).

store_term(Term) :-
        Term == end_of_file.

store_term(Term) :-
        assertz(term(Term)), 
        fail.   

collect_terms([M|List]) :-
        retract(term(M)), 
        !, 
        collect_terms(List).
collect_terms([]).
</pre></div>

<p>The variable bindings made in one iteration of
a failure-driven loop are unbound on failure of the iteration.  Thus partial
results cannot simply be stored in a data structure that is passed along
to the next iteration.  We must instead resort to storing partial results
via side effects (here, <code>assertz/1</code>) and collect (and clean up) partial 
results in a separate pass.  The second example is much less
clear to most people than the first.  It is also much less efficient than
the first.  However,  if there were no garbage collector, then larger examples 
of the second type might be able to run
where those of the first type would run out of memory.
</p>
        
<hr>



<div class="logo">
<a href="https://sicstus.sics.se/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
<li><a href="ref_002dmgc_002degc.html#ref_002dmgc_002degc" accesskey="n" rel="next">Next</a>
<li><a href="ref_002dmgc_002dove.html#ref_002dmgc_002dove" accesskey="p" rel="prev">Previous</a>
<li><a href="ref_002dmgc.html#ref_002dmgc" accesskey="u" rel="up">Up</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@ri.se?subject=Documentation%20feedback%20on%20html/sicstus/ref_002dmgc_002dgcp.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/ref_002dmgc_002dgcp.html%20in%20User's%20Manual.">Send feedback on this subject.</a>
</body>
</html>
