This is sicstus.info, produced by makeinfo version 6.5 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated July 7, 2021.



File: sicstus.info,  Node: mpg-ref-var,  Next: mpg-ref-volatile,  Prev: mpg-ref-use_module,  Up: mpg-bpr

11.3.248 'var/1'   ISO
----------------------

Synopsis
--------

'var(+TERM)'

   TERM is currently uninstantiated.

Arguments
---------

TERM
     "term"

Examples
--------

     | ?- var(foo(X,Y)).

     no
     | ?- var([X,Y]).

     no
     | ?- var(X).

     true ;

     no
     | ?- Term = foo(X,Y), var(Term).

     no

Exceptions
----------

None.

See Also
--------

*note ref-lte-met-typ::.


File: sicstus.info,  Node: mpg-ref-volatile,  Next: mpg-ref-when,  Prev: mpg-ref-var,  Up: mpg-bpr

11.3.249 'volatile/1'   declaration
-----------------------------------

Synopsis
--------

':- volatile +PREDSPECS'

   Declares PREDSPECS to be volatile.  Clauses of volatile predicates
are not saved by the 'save_*' predicates.

Arguments
---------

:PREDSPECS
     "pred_spec_forest", must be ground

     A predicate specification, or a list of such, or a sequence of such
     separated by commas.

Exceptions
----------

Exceptions in the context of loading code are printed as error messages.

'instantiation_error'
     PREDSPECS not ground.

'type_error'
     PREDSPECS not a valid "pred_spec_forest".

'domain_error'
     Some arity is an integer < 0.

'representation_error'
     Some arity is an integer > 255.

'context_error'
     Declaration appeared in a goal.

'permission_error'
     Declaration appeared as a clause.

See Also
--------

*note Volatile Declarations::.


File: sicstus.info,  Node: mpg-ref-when,  Next: mpg-ref-write,  Prev: mpg-ref-volatile,  Up: mpg-bpr

11.3.250 'when/2'
-----------------

Synopsis
--------

'when(+CONDITION,+GOAL)'

   Blocks GOAL until the CONDITION is true.

Arguments
---------

CONDITION
     "callable", must be nonvar and one of:
     'nonvar(X)'
          False until X is nonvar.

     'ground(X)'
          False until X is ground.

     '?=(X,Y)'
          False while 'dif(X,Y)' would block.

     'CONDITION,CONDITION'
          True if both conditions are true.

     'CONDITION;CONDITION'
          True if at least one condition is true.

:GOAL
     "callable", must be nonvar

Backtracking
------------

Depends on GOAL.

Examples
--------

     | ?- when(((nonvar(X);?=(X,Y)),ground(T)), process(X,Y,T)).

Exceptions
----------

Call errors (*note ref-sem-exc::).

See Also
--------

*note ref-sem-sec::.


File: sicstus.info,  Node: mpg-ref-write,  Next: mpg-ref-write_canonical,  Prev: mpg-ref-when,  Up: mpg-bpr

11.3.251 'write/[1,2]'   ISO
----------------------------

Synopsis
--------

'write(+STREAM, +TERM)'

   'write(+TERM)'

   Writes TERM on STREAM, without quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

'write(Term)' is equivalent to:

     write_term(Term, [numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_canonical,  Next: mpg-ref-write_term,  Prev: mpg-ref-write,  Up: mpg-bpr

11.3.252 'write_canonical/[1,2]'   ISO
--------------------------------------

Synopsis
--------

'write_canonical(+STREAM, +TERM)'

   'write_canonical(+TERM)'

   Writes TERM on STREAM, quoting atoms, in functional notation, without
treating ''$VAR'/1' terms specially.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

This predicate is provided so that TERM, if written to a file, can be
read back by 'read/[1,2]' regardless of special characters in TERM or
prevailing operator declarations.

   'write_canonical(Term)' is equivalent to:

     write_term(Term, [quoted(true),ignore_ops(true),quoted_charset(portable)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

Examples
--------

To contrast 'write/[1,2]' and 'write_canonical/[1,2]':
     | ?- write({'A' + '$VAR'(0) + [a]}).

     {A+A+[a]}

     | ?- write_canonical({'A' + '$VAR'(0) + [a]}).

     {}(+(+('A','$VAR'(0)),.(a,[])))

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-write_term,  Next: mpg-ref-writeq,  Prev: mpg-ref-write_canonical,  Up: mpg-bpr

11.3.253 'write_term/[2,3]'   hookable, ISO
-------------------------------------------

Synopsis
--------

'write_term(+STREAM, +TERM, +OPTIONS)'

   'write_term(+TERM, +OPTIONS)'

   Writes TERM on STREAM, subject to +OPTIONS.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

OPTIONS
     "list of term".

     A list of zero or more of the following, where BOOLEAN must be
     'true' or 'false' ('false' is the default).

     'quoted(BOOLEAN)'
          If selected, then atoms and functors are quoted where
          necessary to make the result acceptable as input to 'read/1'.
          'write_canonical/1', 'writeq/1', and 'portray_clause/1' select
          this.

          Any output produced by 'write_term/2' with the option
          'quoted(true)' will be in Normal Form C, as defined by
          Unicode.  *Note ref-syn-syn-tok:: for further details.

     'ignore_ops(BOOLEAN)'
          If selected, then TERM is written in standard functional
          notation instead of using operators.  'write_canonical/1' and
          'display/1' select this.

     'portrayed(BOOLEAN)'
          If selected, then 'user:portray/1' is called for each
          non-variable subterm.  'print/1' selects this.

     'variable_names(NAMES)   since release 4.3'
          NAMES should be a list of 'NAME=VAR' pairs, where each NAME is
          an atom indicating the name to be used if VAR is a variable
          occurring in the written term.

          This argument has the same form as the corresponding
          'read_term/[2,3]' option and provides a convenient and safe
          way to preserve variable names when writing a previously read
          term.

     'numbervars(BOOLEAN)'
          If selected, then terms of the form ''$VAR'(N)' where N is an
          integer >= 0 are treated specially (see 'numbervars/3').
          'print/1', 'write/1', 'writeq/1', and 'portray_clause/1'
          select this.

     'legacy_numbervars(BOOLEAN)   since release 4.3'
          If selected, then terms of the form ''$VAR'(N)' where N is an
          integer >= 0, an atom, or a code list, are treated specially,
          in a way consistent with versions prior to release 4.3, as
          follows.

          If N is an integer >= 0, then the behavior is as for the
          'numbervars/1' option.  Otherwise the characters of the atom
          or code list are written instead of the term.

          The preferred way to specify variable names is with the
          'variable_names/1' option.

     'cycles(BOOLEAN)'
          If selected, then the potentially cyclic term is printed in
          finite '@/2' notation, as discussed for 'read_term/[2,3]'
          (*note mpg-ref-read_term::).

     'indented(BOOLEAN)'
          If selected, then the term is printed with the same
          indentation as is used by 'portray_clause/1' and
          'listing/[0,1]'.

     'max_depth(DEPTH)'
          Depth limit on printing.  DEPTH is an integer.  0 (the
          default) means no limit.

     'quoted_charset(CHARSET)'
          Only relevant if 'quoted(true)' holds.  CHARSET should be a
          legal value of the 'quoted_charset' Prolog flag, where it
          takes its default value from.  'write_canonical/1' selects the
          value 'portable'.  *Note ref-lps-flg::.

     'float_format(SPEC)'
          How to print floats.  SPEC should be an atom of the form
          '~NC', like one of the 'format/[2,3]' character sequences for
          printing floats.  The default is '~H'.

     'priority(PRIO)'
          The term is printed as if in the context of an associative
          operator of precedence PRIO, where PRIO is an integer.  The
          default is 1200.  *Note ref-syn-ops::.

Description
-----------

This predicate subsumes the predicates that output terms except
'portray_clause/[1,2]', which additionally prints a period and a
newline, and removes module prefixes that are redundant wrt. the current
type-in module.

   During debugging, goals are written out by this predicate with
options given by the 'debugger_print_options' Prolog flag.

   Top-level variable bindings are written out by this predicate with
options given by the 'toplevel_print_options' Prolog flag.

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::), plus:

'instantiation_error'
'type_error'
'domain_error'
     in OPTIONS.

Examples
--------

How certain options affect the output of 'write_term/2':
     | ?- write_term('a b', [quoted(true)]).
     'a b'

     | ?- write_term(a+b, [ignore_ops(true)]).
     +(a,b)

     | ?- write_term(f('$VAR'(2)),
                        [numbervars(true)].)
     f(C)


     | ?- write_term(A+B,
                           [variable_names(['Hello'=A, 'World'=B])]).
     Hello+World


   If your intention is to name variables such as that generated by
'read_term/2' with the 'variable_names' option, then this can be done by
simply passing on the 'variable_names' option to 'write_term/2':

     | ?- read_term(T, [variable_names(Names)]),
          write_term(T, [variable_names(Names),quoted(true)]),
          nl,
          fail.
     |: a(X, Y).
     a(X, Y)
     no

   There is, currently, no documented way to write single-occurrence
variables as '_', e.g.  as done by 'portray_clause/1' (*note
mpg-ref-portray_clause::).

See Also
--------

*note ref-iou-tou::, *note ref-lps-flg::, 'user:portray/1'.


File: sicstus.info,  Node: mpg-ref-writeq,  Next: mpg-ref-zip,  Prev: mpg-ref-write_term,  Up: mpg-bpr

11.3.254 'writeq/[1,2]'   ISO
-----------------------------

Synopsis
--------

'writeq(+STREAM, +TERM)'

   'writeq(+TERM)'

   Writes TERM on STREAM, quoting atoms.

Arguments
---------

STREAM
     "stream_object", must be ground

     A valid open Prolog stream, defaults to the current output stream.

TERM
     "term"

Description
-----------

'writeq(Term)' is equivalent to:

     write_term(Term, [quoted(true),numbervars(true)])

Exceptions
----------

Stream errors (*note ref-iou-sfh-est::).

See Also
--------

*note ref-iou-tou::.


File: sicstus.info,  Node: mpg-ref-zip,  Prev: mpg-ref-writeq,  Up: mpg-bpr

11.3.255 'zip/0'   development
------------------------------

Synopsis
--------

'zip'

   Turns on the debugger in zip mode.

Description
-----------

'zip/0' turns the debugger on and sets it to zip mode.  Turning the
debugger on in zip mode means that it will stop at the next spypoint
encountered in the current execution.  Until the spypoint is reached, it
does not keep any information of the execution of the goal, and hence
you will not be able to see the ancestors of the goal when you reach the
spypoint.

   The effect of this predicate can also be achieved by typing the
letter 'z' after a '^C' interrupt (*note Execution::).

Exceptions
----------

None.

See Also
--------

*note Basic Debug::.


File: sicstus.info,  Node: C Reference Pages,  Next: Command Reference Pages,  Prev: Prolog Reference Pages,  Up: Top

12 C Reference Pages
********************

* Menu:

* cpg-rve::                             Return Values and Errors
* cpg-top::                             Topical List of C Functions
* cpg-bif::                             C Functions


File: sicstus.info,  Node: cpg-rve,  Next: cpg-top,  Up: C Reference Pages

12.1 Return Values and Errors
=============================

Many, but not all, C functions return one of the codes 'SP_SUCCESS' for
success, 'SP_FAILURE' for failure, 'SP_ERROR' if an error condition
occurred, or if an uncaught exception was raised during a call from C to
Prolog.  If the value is 'SP_ERROR', then the macro 'SP_errno' will
return a value (an integer) describing the error condition.

   The function 'SP_error_message()' returns a pointer to the diagnostic
message corresponding to a specified error number.

   See *note mpg-ref-ove:: for a description of the conventions observed
in the Reference Pages for Prolog predicates.  C function Reference
Pages differ primarily in the synopsis.  Also, the Reference Page for
each C function documents its return values.

   The following function annotations are used in the Reference Pages:

"hook"
     The function is user defined and is called in some specific
     context.

"macro"
     The function is defined as a C macro.

"preinit"
     It is only meaningful to call the function before initializing the
     Prolog engine


File: sicstus.info,  Node: cpg-top,  Next: cpg-bif,  Prev: cpg-rve,  Up: C Reference Pages

12.2 Topical List of C Functions
================================

* Menu:

* cpg-top-err::                         C Errors
* cpg-top-cio::                         I/O
* cpg-top-exc::                         Exceptions
* cpg-top-fst::                         Files and Streams
* cpg-top-fin::                         Foreign Interface
* cpg-top-main::                        Initialization
* cpg-top-mem::                         Memory Management
* cpg-top-sig::                         Signal Handling
* cpg-top-tic::                         Terms in C
* cpg-top-typ::                         Type Tests


File: sicstus.info,  Node: cpg-top-err,  Next: cpg-top-cio,  Up: cpg-top

12.2.1 C Errors
---------------

'SP_error_message()'
     gets the corresponding error message from an error number obtained
     from 'SP_error'


File: sicstus.info,  Node: cpg-top-cio,  Next: cpg-top-exc,  Prev: cpg-top-err,  Up: cpg-top

12.2.2 I/O
----------

'SP_get_byte()'
     gets a byte from a Prolog binary input stream

'SP_get_code()'
     gets a character code from a Prolog input text stream

'SP_unget_byte()'
'SP_unget_code()'
     Ungets a byte or character, respectively.

'SP_fprintf()'
'SP_printf()'
     prints formatted output on a Prolog output text stream

'SP_put_byte()'
'SP_put_bytes()'
     Writes one or more bytes to a Prolog output binary stream.

'SP_put_code()'
'SP_put_codes()'
'SP_put_encoded_string()'
     Writes one or more characters to a Prolog output text stream.


File: sicstus.info,  Node: cpg-top-exc,  Next: cpg-top-fst,  Prev: cpg-top-cio,  Up: cpg-top

12.2.3 Exceptions
-----------------

'SP_exception_term()'
     fetches the Prolog term representing the most recently raised
     exception

'SP_fail()'
     propagates failure to Prolog

'SP_on_fault()   macro'
     provide a scope for faults

'SP_raise_exception()'
     propagates an exception to Prolog

'SP_raise_fault()'
     raise a fault


File: sicstus.info,  Node: cpg-top-fst,  Next: cpg-top-fin,  Prev: cpg-top-exc,  Up: cpg-top

12.2.4 Files and Streams
------------------------

'SP_fopen()'
     opens a file as a Prolog stream

'SP_fclose()'
     closes a Prolog stream

'SP_flush_output()'
     flushes output on a Prolog output stream

'SP_load()'
     same as 'load_files/1'

'SP_create_stream()'
     makes a new Prolog stream

'SP_restore()'
     same as 'restore/1'

'SP_set_user_stream_hook()   preinit'
'SP_set_user_stream_post_hook()   preinit'
     provide hooks for setting up standard streams


File: sicstus.info,  Node: cpg-top-fin,  Next: cpg-top-main,  Prev: cpg-top-fst,  Up: cpg-top

12.2.5 Foreign Interface
------------------------

'SP_atom_from_string()'
     returns the encoded string representing a Prolog atom

'SP_atom_length()'
     returns the length of the encoded string representing a Prolog atom

'SP_close_query()'
     closes a Prolog query opened from C by 'SP_open_query()'

'SP_cons_functor()'
'SP_cons_functor_array()'
     creates a Prolog compound term from C

'SP_cons_list()'
     creates a Prolog list from C

'SP_cut_query()'
     commits to the current solution of a Prolog query opened from C by
     'SP_open_query()'

'SP_define_c_predicate()'
     defines a Prolog predicate linked to a C function

'SP_exception_term()'
     returns the Prolog term to C corresponding to the most recent
     Prolog error

'SP_get_address()'
     fetches an integer representing a pointer in an SP_term_ref

'SP_get_arg()'
     fetches a specified argument of a compound term in an SP_term_ref

'SP_get_atom()'
     fetches an atom from an SP_term_ref

'SP_get_current_dir()'
     obtain name of current working directory

'SP_get_float()'
     fetches a floating point number from an SP_term_ref

'SP_get_functor()'
     fetches the name and arity of a term in an SP_term_ref

'SP_get_integer()'
     fetches an integer in an SP_term_ref

'SP_get_integer_bytes()'
     fetches an arbitrarily sized integer in an SP_term_ref

'SP_get_list()'
     fetches the head and tail of a list in an SP_term_ref

'SP_get_list_codes()'
     fetches a code list in an SP_term_ref

'SP_get_list_n_codes()'
     fetches the first part of a code list in an SP_term_ref

'SP_get_list_n_bytes()'
     fetches the first part of a byte list in an SP_term_ref

'SP_get_number_codes()'
     fetches a number encoded as a code list in an SP_term_ref

'SP_get_string()'
     fetches the encoded string representing a Prolog atom in an
     SP_term_ref

'SP_next_solution()'
     gets the next solution, if any, to an open Prolog query

'SP_open_query()'
     opens a Prolog query from C

'SP_pred()'
     fetches an identifier for a Prolog predicate

'SP_predicate()'
     fetches an identifier a Prolog predicate

'SP_put_address()'
     assigns a pointer to an SP_term_ref

'SP_put_atom()'
     assigns an atom to an SP_term_ref

'SP_put_float()'
     assigns a floating point number to an SP_term_ref

'SP_put_functor()'
     assigns a new compound term to an SP_term_ref

'SP_put_integer()'
     assigns an integer to an SP_term_ref

'SP_put_integer_bytes()'
     assigns an arbitrarily sized integer to an SP_term_ref

'SP_put_list()'
     assigns a new list to an SP_term_ref

'SP_put_list_codes()'
     assigns a code list to an SP_term_ref

'SP_put_list_n_codes()'
     assigns the first part of a code list to an SP_term_ref

'SP_put_list_n_bytes()'
     assigns the first part of a byte list to an SP_term_ref

'SP_put_number_codes()'
     assigns a number encoded as a code list to an SP_term_ref

'SP_put_string()'
     assigns the atom represented by an encoded string to an SP_term_ref

'SP_put_term()'
     assigns the value of an SP_term_ref to another SP_term_ref

'SP_put_variable()'
     assigns a Prolog variable to an SP_term_ref

'SP_query()'
     makes a determinate query to a Prolog predicate, committing to the
     solution

'SP_query_cut_fail()'
     makes a determinate query to a Prolog predicate for side effects
     only

'SP_read_from_string()'
     assigns a Prolog term read from a string to an SP_term_ref

'SP_set_current_dir()'
     set name of current working directory

'SP_string_from_atom()'
     returns a null-terminated string corresponding to a Prolog atom


File: sicstus.info,  Node: cpg-top-main,  Next: cpg-top-mem,  Prev: cpg-top-fin,  Up: cpg-top

12.2.6 Initialization
---------------------

'SP_deinitialize()'
     shuts down the Prolog engine

'SP_force_interactive()   preinit'
     consider standard streams to be interactive streams, even if they
     appear not to be TTY streams

'SP_initialize()   macro'
     initializes the Prolog engine

'SP_set_argv()'
     sets the 'argv' Prolog flag.

'SP_set_user_stream_hook()   preinit'
'SP_set_user_stream_post_hook()   preinit'
     provide hooks for setting up standard streams

'SU_initialize()   hook'
     called before initializing the Prolog engine in applications built
     with '--userhook'


File: sicstus.info,  Node: cpg-top-mem,  Next: cpg-top-sig,  Prev: cpg-top-main,  Up: cpg-top

12.2.7 Memory Management
------------------------

'SP_calloc()'
     Allocates memory for an array of elements, and clears the allocated
     memory.

'SP_foreign_stash()   macro'
     provide a memory location unique to the current foreign resource
     instance

'SP_free()'
     Deallocates a piece of memory.

'SP_malloc()'
     Allocates a piece of memory.

'SP_mutex_lock()'
     Locks a mutex.

'SP_mutex_unlock()'
     Unlocks a mutex.

'SP_realloc()'
     Changes the size of an allocated piece of memory.

'SP_register_atom()'
     prevents an atom from being discarded by atom garbage collection
     even if not referenced by Prolog code

'SP_strdup()'
     Makes a copy of a string in allocated memory.

'SP_unregister_atom()'
     enables an atom to be discarded during atom garbage collection if
     not referenced by Prolog code


File: sicstus.info,  Node: cpg-top-sig,  Next: cpg-top-tic,  Prev: cpg-top-mem,  Up: cpg-top

12.2.8 Signal Handling
----------------------

'SP_signal()'
     install a signal handler

'SP_event()'
     Schedules a function for execution in the main thread in contexts
     where queries cannot be issued.


File: sicstus.info,  Node: cpg-top-tic,  Next: cpg-top-typ,  Prev: cpg-top-sig,  Up: cpg-top

12.2.9 Terms in C
-----------------

'SP_compare()'
     compares two terms using Prolog's standard term order

'SP_new_term_ref()'
     returns an SP_term_ref, which can be used to hold a Prolog term in
     C

'SP_unify()'
     unifies two Prolog terms


File: sicstus.info,  Node: cpg-top-typ,  Prev: cpg-top-tic,  Up: cpg-top

12.2.10 Type Tests
------------------

'SP_is_atom()'
     tests whether an SP_term_ref contains an atom

'SP_is_atomic()'
     tests whether an SP_term_ref contains an atomic term

'SP_is_compound()'
     tests whether an SP_term_ref contains a compound term

'SP_is_float()'
     tests whether an SP_term_ref contains a floating point number

'SP_is_integer()'
     tests whether an SP_term_ref contains a Prolog integer

'SP_is_list()'
     tests whether an SP_term_ref contains a list cell

'SP_is_number()'
     tests whether an SP_term_ref contains an integer or a floating
     point number

'SP_is_variable()'
     tests whether an SP_term_ref contains a Prolog variable

'SP_term_type()'
     returns the type of the term in an SP_term_ref


File: sicstus.info,  Node: cpg-bif,  Prev: cpg-top,  Up: C Reference Pages

12.3 API Functions
==================

The following reference pages, alphabetically arranged, describe the
SICStus Prolog API functions.

* Menu:

* cpg-ref-SP_atom_from_string:: SP_atom_from_string()
* cpg-ref-SP_atom_length:: SP_atom_length()
* cpg-ref-SP_calloc:: SP_calloc()
* cpg-ref-SP_close_query:: SP_close_query()
* cpg-ref-SP_compare:: SP_compare()
* cpg-ref-SP_cons_functor:: SP_cons_functor()
* cpg-ref-SP_cons_functor_array:: SP_cons_functor_array()
* cpg-ref-SP_cons_list:: SP_cons_list()
* cpg-ref-SP_create_stream:: SP_create_stream()
* cpg-ref-SP_cut_query:: SP_cut_query()
* cpg-ref-SP_define_c_predicate:: SP_define_c_predicate()
* cpg-ref-SP_deinitialize:: SP_deinitialize()
* cpg-ref-SP_error_message:: SP_error_message()
* cpg-ref-SP_event:: SP_event()
* cpg-ref-SP_exception_term:: SP_exception_term()
* cpg-ref-SP_expand_file_name:: SP_expand_file_name()
* cpg-ref-SP_fail:: SP_fail()
* cpg-ref-SP_fclose:: SP_fclose()
* cpg-ref-SP_flush_output:: SP_flush_output()
* cpg-ref-SP_fopen:: SP_fopen()
* cpg-ref-SP_foreign_stash:: SP_foreign_stash()
* cpg-ref-SP_fprintf:: SP_fprintf()
* cpg-ref-SP_free:: SP_free()
* cpg-ref-SP_get_address:: SP_get_address()
* cpg-ref-SP_get_arg:: SP_get_arg()
* cpg-ref-SP_get_atom:: SP_get_atom()
* cpg-ref-SP_get_byte:: SP_get_byte()
* cpg-ref-SP_get_code:: SP_get_code()
* cpg-ref-SP_get_current_dir:: SP_get_current_dir()
* cpg-ref-SP_get_dispatch:: SP_get_dispatch()
* cpg-ref-SP_get_float:: SP_get_float()
* cpg-ref-SP_get_functor:: SP_get_functor()
* cpg-ref-SP_get_integer:: SP_get_integer()
* cpg-ref-SP_get_integer_bytes:: SP_get_integer_bytes()
* cpg-ref-SP_get_list:: SP_get_list()
* cpg-ref-SP_get_list_codes:: SP_get_list_codes()
* cpg-ref-SP_get_list_n_bytes:: SP_get_list_n_bytes()
* cpg-ref-SP_get_list_n_codes:: SP_get_list_n_codes()
* cpg-ref-SP_get_number_codes:: SP_get_number_codes()
* cpg-ref-SP_get_stream_counts:: SP_get_stream_counts()
* cpg-ref-SP_get_stream_user_data:: SP_get_stream_user_data()
* cpg-ref-SP_get_string:: SP_get_string()
* cpg-ref-SP_getenv:: SP_getenv()
* cpg-ref-SP_initialize:: SP_initialize()
* cpg-ref-SP_is_atom:: SP_is_atom()
* cpg-ref-SP_is_atomic:: SP_is_atomic()
* cpg-ref-SP_is_compound:: SP_is_compound()
* cpg-ref-SP_is_float:: SP_is_float()
* cpg-ref-SP_is_integer:: SP_is_integer()
* cpg-ref-SP_is_list:: SP_is_list()
* cpg-ref-SP_is_number:: SP_is_number()
* cpg-ref-SP_is_variable:: SP_is_variable()
* cpg-ref-SP_load:: SP_load()
* cpg-ref-SP_load_sicstus_run_time:: SP_load_sicstus_run_time()
* cpg-ref-SP_malloc:: SP_malloc()
* cpg-ref-SP_mutex_lock:: SP_mutex_lock()
* cpg-ref-SP_mutex_unlock:: SP_mutex_unlock()
* cpg-ref-SP_new_term_ref:: SP_new_term_ref()
* cpg-ref-SP_next_solution:: SP_next_solution()
* cpg-ref-SP_next_stream:: SP_next_stream()
* cpg-ref-SP_open_query:: SP_open_query()
* cpg-ref-SP_pred:: SP_pred()
* cpg-ref-SP_predicate:: SP_predicate()
* cpg-ref-SP_printf:: SP_printf()
* cpg-ref-SP_put_address:: SP_put_address()
* cpg-ref-SP_put_atom:: SP_put_atom()
* cpg-ref-SP_put_byte:: SP_put_byte()
* cpg-ref-SP_put_bytes:: SP_put_bytes()
* cpg-ref-SP_put_code:: SP_put_code()
* cpg-ref-SP_put_codes:: SP_put_codes()
* cpg-ref-SP_put_encoded_string:: SP_put_encoded_string()
* cpg-ref-SP_put_float:: SP_put_float()
* cpg-ref-SP_put_functor:: SP_put_functor()
* cpg-ref-SP_put_integer:: SP_put_integer()
* cpg-ref-SP_put_integer_bytes:: SP_put_integer_bytes()
* cpg-ref-SP_put_list:: SP_put_list()
* cpg-ref-SP_put_list_codes:: SP_put_list_codes()
* cpg-ref-SP_put_list_n_bytes:: SP_put_list_n_bytes()
* cpg-ref-SP_put_list_n_codes:: SP_put_list_n_codes()
* cpg-ref-SP_put_number_codes:: SP_put_number_codes()
* cpg-ref-SP_put_string:: SP_put_string()
* cpg-ref-SP_put_term:: SP_put_term()
* cpg-ref-SP_put_variable:: SP_put_variable()
* cpg-ref-SP_query:: SP_query()
* cpg-ref-SP_query_cut_fail:: SP_query_cut_fail()
* cpg-ref-SP_raise_exception:: SP_raise_exception()
* cpg-ref-SP_read_from_string:: SP_read_from_string()
* cpg-ref-SP_realloc:: SP_realloc()
* cpg-ref-SP_register_atom:: SP_register_atom()
* cpg-ref-SP_restore:: SP_restore()
* cpg-ref-SP_set_argv:: SP_set_argv()
* cpg-ref-SP_set_current_dir:: SP_set_current_dir()
* cpg-ref-SP_set_user_stream_hook:: SP_set_user_stream_hook()
* cpg-ref-SP_set_user_stream_post_hook:: SP_set_user_stream_post_hook()
* cpg-ref-SP_signal:: SP_signal()
* cpg-ref-SP_strdup:: SP_strdup()
* cpg-ref-SP_string_from_atom:: SP_string_from_atom()
* cpg-ref-SP_term_type:: SP_term_type()
* cpg-ref-SP_unget_byte:: SP_unget_byte()
* cpg-ref-SP_unget_code:: SP_unget_code()
* cpg-ref-SP_unify:: SP_unify()
* cpg-ref-SP_unregister_atom:: SP_unregister_atom()
* cpg-ref-SU_initialize:: SU_initialize()
* cpg-ref-user_close:: user_close()
* cpg-ref-user_flush_output:: user_flush_output()
* cpg-ref-user_read:: user_read()
* cpg-ref-user_write:: user_write()


File: sicstus.info,  Node: cpg-ref-SP_atom_from_string,  Next: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.1 'SP_atom_from_string()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_atom
     SP_atom_from_string(char const *str);

   Finds the Prolog atom whose characters are encoded by 'str'.

Arguments
---------

STR
     The characters comprising the atom.

Return Value
------------

The SP_atom, if 'str' is a valid internal character encoding, and 0
otherwise.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_atom_length,  Next: cpg-ref-SP_calloc,  Prev: cpg-ref-SP_atom_from_string,  Up: cpg-bif

12.3.2 'SP_atom_length()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     size_t
     SP_atom_length(SP_atom atom);

   Obtains the length of the encoded string representing a Prolog atom.

Arguments
---------

ATOM
     The atom to inspect.

Return Value
------------

The length if 'atom' is valid, and 0 otherwise.

Description
-----------

Same as 'strlen(SP_string_from_atom(a)', but runs in O(1) time.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_calloc,  Next: cpg-ref-SP_close_query,  Prev: cpg-ref-SP_atom_length,  Up: cpg-bif

12.3.3 'SP_calloc()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_calloc(size_t nmemb,
               size_t size);

   Allocates a block of at least 'size * nemb'.  The first 'size *
nmemb' bytes are set to zero.

Arguments
---------

NMEMB
     How many items to allocate.

SIZE
     Size of each item.

Return Value
------------

The pointer, if allocation was successful, otherwise 'NULL'.

See Also
--------

*note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_close_query,  Next: cpg-ref-SP_compare,  Prev: cpg-ref-SP_calloc,  Up: cpg-bif

12.3.4 'SP_close_query()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_close_query(SP_qid query);

   Discard the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by 'SP_open_query()'.

Return Value
------------

'SP_SUCCESS' for success, 'SP_ERROR' if an error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
'SP_open_query()', and then backtrack into the query, throwing away any
current solution, like the goal '!, fail'.  The given argument does not
have to be the innermost open query; any open queries in its scope will
also be closed.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_compare,  Next: cpg-ref-SP_cons_functor,  Prev: cpg-ref-SP_close_query,  Up: cpg-bif

12.3.5 'SP_compare()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_compare(SP_term_ref x,
                SP_term_ref y)

   Compares two terms.

Arguments
---------

X
     The one term to compare

Y
     The other term to compare

Return Value
------------

-1 if 'x' @< 'y', 0 if 'x' == 'y', and 1 if 'x' @> 'y'.

See Also
--------

*note ref-lte-cte::, *note Unifying and Comparing Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor,  Next: cpg-ref-SP_cons_functor_array,  Prev: cpg-ref-SP_compare,  Up: cpg-bif

12.3.6 'SP_cons_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor(SP_term_ref term,
                     SP_atom name,
                     int arity,
                     SP_term_ref arg, ...);

   Assigns to 'term' a reference to a compound term whose arguments are
the values of 'arg'....  If 'arity' is 0, assigns the Prolog atom whose
canonical representation is 'name'.  This is similar to calling '=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG ...
     The arguments

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_functor_array,  Next: cpg-ref-SP_cons_list,  Prev: cpg-ref-SP_cons_functor,  Up: cpg-bif

12.3.7 'SP_cons_functor_array()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_functor_array(SP_term_ref term,
     		      SP_atom name,
     		      int arity,
     		      SP_term_ref *arg);

   Assigns to 'term' a reference to a compound term whose arguments are
the elements of 'arg'.  If 'arity' is 0, assigns the Prolog atom whose
canonical representation is 'name'.  This is similar to calling '=../2'
with the first argument unbound and the second argument bound.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

ARG
     The argument array

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_cons_list,  Next: cpg-ref-SP_create_stream,  Prev: cpg-ref-SP_cons_functor_array,  Up: cpg-bif

12.3.8 'SP_cons_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cons_list(SP_term_ref term,
                  SP_term_ref head,
                  SP_term_ref tail);

   Assigns to 'term' a reference to a Prolog list whose head and tail
are the values of 'head' and 'tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

HEAD
     The head of the new list

TAIL
     The tail of the new list

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_create_stream,  Next: cpg-ref-SP_cut_query,  Prev: cpg-ref-SP_cons_list,  Up: cpg-bif

12.3.9 'SP_create_stream()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_create_stream(
        void *user_data,
        void const *user_class,
        spio_t_simple_device_read *user_read,
        spio_t_simple_device_write *user_write,
        spio_t_simple_device_flush_output *user_flush_output,
        spio_t_simple_device_seek *user_seek,
        spio_t_simple_device_close *user_close,
        spio_t_simple_device_interrupt *user_interrupt,
        spio_t_simple_device_ioctl *user_ioctl,
        spio_t_bits create_stream_options,
        SP_stream **pstream);

   Create a Prolog stream that will call user defined functions to
perform stream operations.

Arguments
---------

USER_DATA
     This is a pointer to arbitrary user specified data.  It is passed
     to all user defined stream methods.  It must not be 'NULL'.

USER_CLASS
     Arbitrary pointer.  This is used with 'SP_get_stream_user_data()',
     which see.

USER_READ
     If non-NULL then this is an input stream.  *Note
     cpg-ref-user_read:: for details.

USER_WRITE
     If non-NULL then this is an output stream.  *Note
     cpg-ref-user_write:: for details.

     Note that both 'user_read' and 'user_write' can be specified,
     signifying a bidirectional stream.

USER_FLUSH_OUTPUT
     Will be called to flush output on the stream.  Ignored if
     'user_write' is 'NULL'.  Can be 'NULL' if the stream need not be
     flushed, e.g. if 'user_write' always ensures that any output
     reaches its destination immediately.  *Note
     cpg-ref-user_flush_output:: for details.

USER_SEEK
     Reserved, should be 'NULL'.

USER_CLOSE
     Closes the stream.  *Note cpg-ref-user_close:: for details.

USER_INTERRUPT
     Reserved, should be 'NULL'.

USER_IOCTL
     Reserved, should be 'NULL'.

ARGS
     Reserved, should be 'NULL'.

CREATE_STREAM_OPTIONS
     The following bits can be set:

     'SP_CREATE_STREAM_OPTION_BINARY'
          This is a binary stream.  The 'user_read' and 'user_write'
          methods transfer bytes.

     'SP_CREATE_STREAM_OPTION_TEXT'
          This is a TEXT stream.  The 'user_read' and 'user_write'
          methods transfer wide characters.

     'SP_CREATE_STREAM_OPTION_AUTOFLUSH'
          After writing to this stream prolog predicates will do a
          'flush_output/1'.  In essence this ensures that the stream
          behaves as if it were unbuffered.

     'SP_CREATE_STREAM_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream.  Implies
          'SP_CREATE_STREAM_OPTION_AUTOFLUSH'.

     'SP_CREATE_STREAM_OPTION_EOF_ON_EOF'
     'SP_CREATE_STREAM_OPTION_RESET_ON_EOF'
          These correspond to the 'open/4' options 'eof_action(eof)' and
          'eof_action(reset)' respectively.  The default is to give an
          error if reading after reaching end of file.

     Exactly one of 'SP_CREATE_STREAM_OPTION_BINARY' and
     'SP_CREATE_STREAM_OPTION_TEXT' must be set.

PSTREAM
     This is assigned to the created SICStus stream on success.  It
     should be closed with 'SP_fclose()' or 'close/[1,2]'.

Return Value
------------

On success, '*pstream' is assigned, and 'SPIO_S_NOERR' or some other
success code is returned.  You should use the 'SPIO_FAILED()' macro to
determine if the return value signifies failure or success.

See Also
--------

*note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-SP_cut_query,  Next: cpg-ref-SP_define_c_predicate,  Prev: cpg-ref-SP_create_stream,  Up: cpg-bif

12.3.10 'SP_cut_query()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_cut_query(SP_qid query);

   Commit to the current solution to the given query, and close it.

Arguments
---------

QUERY
     The query, created by 'SP_open_query()'.

Return Value
------------

'SP_SUCCESS' for success, 'SP_FAILURE' for failure, 'SP_ERROR' if an
error condition occurred.

Description
-----------

This will discard the choices created since the corresponding
'SP_open_query()', like the goal '!'.  The current solution is retained
in the arguments until backtracking into any enclosing query.  The given
argument does not have to be the innermost open query; any open queries
in its scope will also be cut.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_define_c_predicate,  Next: cpg-ref-SP_deinitialize,  Prev: cpg-ref-SP_cut_query,  Up: cpg-bif

12.3.11 'SP_define_c_predicate()'
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef int
     SP_CPredFun(SP_term_ref goal,
                 void *stash);

     int
     SP_define_c_predicate(char *name,
                           int arity,
                           char *module,
                           SP_CPredFun *proc,
                           void *stash);

   Defines a Prolog predicate such that when the Prolog predicate is
called it will call a C function with a term corresponding to the Prolog
goal.

Arguments
---------

NAME
     The predicate name.

ARITY
     The predicate arity.

MODULE
     The predicate module name.

PROC
     The function.

STASH
     See below.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

The Prolog predicate MODULE:NAME/ARITY will be defined (the module
MODULE must already exist).  The 'stash' argument can be anything and is
simply passed as the second argument to the C function PROC.

   The C function should return 'SP_SUCCESS' for success and
'SP_FAILURE' for failure.  The C function may also call 'SP_fail()' or
'SP_raise_exception()' in which case the return value will be ignored.

Examples
--------

Here is an end-to-end example of the above:

                                                          _% square.pl_
     foreign_resource(square, [init(square_init)]).

     :- load_foreign_resource(square).
                                                          _// square.c_
     #include <sicstus/sicstus.h>

     static int square_it(SP_term_ref goal, void *stash)
     {
       SP_integer arg1;
       SP_term_ref tmp = SP_new_term_ref();
       SP_term_ref square_term = SP_new_term_ref();

       // goal will be a term like square(42,X)
       SP_get_arg(1,goal,tmp); // extract first arg
       if (!SP_get_integer(tmp,&arg1))
         return SP_FAILURE;   // type check first arg

       SP_put_integer(square_term, arg1*arg1);
       SP_get_arg(2,goal,tmp); // extract second arg

       // Unify output argument.
       // SP_put_integer(tmp,...) would *not* work!
       return (SP_unify(tmp, square_term) ? SP_SUCCESS : SP_FAILURE);
     }

     void square_init(int when)
     {
       (void)when;                   // unused
       // Install square_it as user:square/2
       SP_define_c_predicate("square", 2, "user", square_it, NULL);
     }
                                                           _# terminal_
     % splfr square.pl square.c
     % sicstus -f -l square
     % compiling /home/matsc/tmp/square.pl...
     %  loading foreign resource /home/matsc/tmp/square.so in module user
     % compiled /home/matsc/tmp/square.pl in module user, 0 msec 816 bytes
     SICStus 4.7.0 ...
     Licensed to SICS
     | ?- square(4711, X).
     X = 22193521 ?
     yes
     | ?- square(not_an_int, X).
     no

See Also
--------

*Note Calling C from Prolog::.


File: sicstus.info,  Node: cpg-ref-SP_deinitialize,  Next: cpg-ref-SP_error_message,  Prev: cpg-ref-SP_define_c_predicate,  Up: cpg-bif

12.3.12 'SP_deinitialize()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_deinitialize(void);

   Shuts down the Prolog engine.

Description
-----------

'SP_deinitialize()' will make a best effort to restore the system to the
state it was in at the time of calling 'SP_initialize()'.  This involves
unloading foreign resources, shutting down the emulator, and
deallocating memory used by Prolog.

   'SP_deinitialize()' is idempotent i.e. it is a no-op unless SICStus
has actually been initialized.

See Also
--------

*note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_error_message,  Next: cpg-ref-SP_event,  Prev: cpg-ref-SP_deinitialize,  Up: cpg-bif

12.3.13 'SP_error_message()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>
     char const *
     SP_error_message(int errnum);

   Obtains a pointer to the diagnostic message corresponding to a
specified error number.

Arguments
---------

ERRNUM
     The error number.

Return Value
------------

A pointer to the diagnostic message.

See Also
--------

*note CPL Notes::.


File: sicstus.info,  Node: cpg-ref-SP_event,  Next: cpg-ref-SP_exception_term,  Prev: cpg-ref-SP_error_message,  Up: cpg-bif

12.3.14 'SP_event()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_event(int (*func)(void*), void *arg)

   Schedules a function for execution in the main thread in contexts
where queries cannot be issued.

Arguments
---------

FUNC
     The function to schedule for execution.

ARG
     Its argument.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

If you wish to call Prolog back from a signal handler that has been
installed with 'SP_signal' or a thread other than the thread that called
'SP_initialize()', that is, the "main thread", you cannot use
'SP_query()' etc. directly.  The call to Prolog has to be delayed until
such time that the Prolog execution can accept an interrupt and the call
has to be performed from the main thread (the Prolog execution thread).
This function serves this purpose, and installs 'func' to be called from
Prolog (in the main thread) when the execution can accept a callback.

   A queue of functions, with corresponding arguments, is maintained;
that is, if several calls to 'SP_event()' occur before Prolog can accept
an interrupt, the functions are queued and executed in turn at the next
possible opportunity.  A 'func' installed with 'SP_event()' will not be
called until SICStus is actually running.  One way of ensuring that all
pending functions installed with 'SP_event()' are run is to call, from
the main thread, some dummy goal, such as,

     SP_query_cut_fail(SP_predicate("true",0,"user"));

   While 'SP_event()' is safe to call from any thread, it is not safe to
call from arbitrary signal handlers.  If you want to call 'SP_event()'
when a signal is delivered, you need to install your signal handler with
'SP_signal()'.

   Note that 'SP_event()' is one of the _very_ few functions in the
SICStus API that can safely be called from another thread than the main
thread.

   Depending on the value returned from 'func', the interrupted Prolog
execution will just continue ('SP_SUCCESS') or backtrack ('SP_FAILURE'
or 'SP_ERROR').  An exception raised by 'func', using
'SP_raise_exception()', will be processed in the interrupted Prolog
execution.  If 'func' calls 'SP_fail()' or 'SP_raise_exception()' the
return value from 'func' is ignored and handled as if 'func' returned
'SP_FAILURE' or 'SP_ERROR', respectively.  In case of failure or
exception, the event queue is flushed.

   It is generally not robust to let 'func' raise an exception or (even
worse) fail.  The reason is that not all Prolog code is written such
that it gracefully handles being interrupted.  If you want to interrupt
some long-running Prolog code, it is better to let the event handler set
a flag (in C) and let your Prolog code test the flag (using a foreign
predicate) in some part of your code that is executed repeatedly.

Examples
--------

How to install the predicate 'user:event_pred/1' as the signal handler
for 'SIGUSR1' and 'SIGUSR2' signals.

   The function 'signal_init()' installs the function 'signal_handler()'
as the primary signal handler for the signals 'SIGUSR1' and 'SIGUSR2'.
That function invokes the predicate as the actual signal handler,
passing the signal number as an argument to the predicate.

     SP_pred_ref event_pred;

     static int signal_event(void *handle)
     {
       int signal_no = (int) handle;
       SP_term_ref x=SP_new_term_ref();
       int rc;

       SP_put_integer(x, signal_no); // Should not give an error
       rc = SP_query_cut_fail(event_pred, x);
       if (rc == SP_ERROR && SP_exception_term(x))
         SP_raise_exception(x);        // Propagate any raised exception
       return rc;
     }

     static void signal_handler(int signal_no)
     {
       SP_event(signal_event, (void *)signal_no);
     }

     void signal_init(void)
     {
       event_pred = SP_predicate("prolog_handler",1,"user");

       SP_signal(SIGUSR1, signal_handler);
       SP_signal(SIGUSR2, signal_handler);
     }


See Also
--------

*note Calling Prolog Asynchronously::, 'SP_signal()', 'SP_fail()',
'SP_raise_exception()'.


File: sicstus.info,  Node: cpg-ref-SP_exception_term,  Next: cpg-ref-SP_expand_file_name,  Prev: cpg-ref-SP_event,  Up: cpg-bif

12.3.15 'SP_exception_term()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_exception_term(SP_term_ref term);

   Retracts the current pending exception term, if it exists, and
assigns it to 'term'.

Arguments
---------

TERM
     The SP_term_ref to assign.

Return Value
------------

1 if an exception term was retracted and assigned, and 0 otherwise.

See Also
--------

*note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_expand_file_name,  Next: cpg-ref-SP_fail,  Prev: cpg-ref-SP_exception_term,  Up: cpg-bif

12.3.16 'SP_expand_file_name()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_expand_file_name(
        char const *relpath,
        char const *cwd,
        spio_t_bits options,
        char **pabspath);

   Expand a file name into an absolute path.

Arguments
---------

RELPATH

     The relative path to expand.  It should be an encoded string.  The
     path is subject to syntactic rewriting, as if by
     'absolute_file_name/2'.

CWD
     If the 'relpath' is a relative path, it is expanded relative to
     'cwd', unless 'cwd' is 'NULL'.  If 'cwd' is 'NULL', a relative
     'relpath' is expanded relative to the SICStus working directory (as
     returned by 'SP_get_current_dir()').

OPTIONS

     The following option bits can be set:

     'SP_EXPAND_FILE_NAME_OPTION_DIR'
          The 'relpath' is expanded as a directory, i.e. '*pabspath'
          will be slash terminated.

     'SP_EXPAND_FILE_NAME_OPTION_NO_CWD'
          An error is returned if the 'relpath' is not an absolute path
          after syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_NO_ENV'
          Do not expand system properties and environment variables
          during syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_NO_HOME'
          Do not expand '~' and '~user' during syntactic rewriting.

     'SP_EXPAND_FILE_NAME_OPTION_ROOT_SLASH'
          If the expanded value would refer to the root directory,
          return a slash terminated absolute path, as if
          'SP_EXPAND_FILE_NAME_OPTION_DIR' had been set.  By default, an
          error is returned if the expanded absolute path would refer to
          a root directory and 'SP_EXPAND_FILE_NAME_OPTION_DIR' is not
          set.

     'SP_EXPAND_FILE_NAME_OPTION_ROOT_DOT'
          If the expanded value would refer to the root directory,
          return an absolute path terminated with '/.'.  By default, an
          error is returned if the expanded absolute path would refer to
          a root directory and 'SP_EXPAND_FILE_NAME_OPTION_DIR' is not
          set.

PABSPATH
     On success, '*pabspath' is set to the expanded path.  This value is
     allocated with 'SP_malloc()' and should be freed with 'SP_free()'.

Return Value
------------

On success, '*pabspath' is set to the expanded path and 'SPIO_S_NOERR'
or some other success code is returned.

   On failure, an error code is returned.

See Also
--------

*note cpg-ref-SP_get_current_dir::.  *Note ref-fdi-syn::, for a
description of syntactic rewriting.  *note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_fail,  Next: cpg-ref-SP_fclose,  Prev: cpg-ref-SP_expand_file_name,  Up: cpg-bif

12.3.17 'SP_fail()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_fail(SP_term_ref term);

   Fails in the scope of Prolog calling C.

Arguments
---------

TERM
     The SP_term_ref whose value will be the exception term.

Description
-----------

This function is normally used in the context of a call from Prolog to
C, and will cause Prolog to backtrack on return from the call.

   *Please note*: this should only be called right before returning to
Prolog.

See Also
--------

*note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_fclose,  Next: cpg-ref-SP_flush_output,  Prev: cpg-ref-SP_fail,  Up: cpg-bif

12.3.18 'SP_fclose()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fclose(
       SP_stream *stream,
       spio_t_bits close_options);

   Close the stream.

Arguments
---------

STREAM
     The stream to close unless the 'SP_FCLOSE_OPTION_USER_STREAMS' is
     set, see below.

CLOSE_OPTIONS
     The following bits can be set:

     'SP_FCLOSE_OPTION_READ'
     'SP_FCLOSE_OPTION_WRITE'
          Close the specified directions.  If neither of these options
          is specified, the stream is closed in all opened directions,
          i.e. as if both options were specified.  If the stream is not
          opened in a direction specified by an option, that option is
          ignored.

          Note that it is possible to close only one direction of a
          bidirectional stream.  The return value will tell whether the
          stream is still open; see below.

     'SP_FCLOSE_OPTION_FORCE'
          Close the specified direction forcibly, i.e. without flushing
          buffers etc.  This also ensures that the close finishes
          "quickly", i.e. does not block.

     'SP_FCLOSE_OPTION_NO_FSYNC'

          Do not use OS 'fclose()' or similar when closing a stream in
          write direction, i.e. do not wait for written data to reach
          the disk.

          By default, closing a stream will try to ensure that all
          written data have been stored on disk before the call returns.
          This makes stream handling more robust, e.g. if the process
          crashes shortly after closing the stream.  However, waiting
          for data to reach the disk is sometimes _very_ slow (e.g.  on
          some Linux configurations), in which case this flag can be
          used to speed things up, at the cost of somewhat reduced
          robustness.

     'SP_FCLOSE_OPTION_NONBLOCKING'
          You should avoid using this option.

          Pass non-blocking option to lower level routines, including
          the call to 'SP_flush_output()' that is issued when
          non-forcibly closing write direction.

          One possible use for this option is to perform a "best effort"
          close, which falls back to using 'SP_FCLOSE_OPTION_FORCE' only
          if ordinary close would block.

     'SP_FCLOSE_OPTION_USER_STREAMS'
          In this case the STREAM should not be a stream but instead be
          the 'user_class' of a user defined stream.  When this option
          is passed, all currently opened streams of that class is
          closed, using the remaining option flags.  E.g. to close all
          user defined streams of class my_class in the read direction
          only do:
          'SP_fclose((SP_stream*)my_class,SP_FCLOSE_OPTION_USER_STREAMS|SP_FCLOSE_OPTION_READ)'.

Return Value
------------

On success, all specified directions has been closed.  Since some
direction may still be open, there are two possible return values on
success:

'SPIO_S_NOERR'
     The stream is still valid, some direction is still not closed.

'SPIO_S_DEALLOCATED'
     The stream has been deallocated and cannot be used further.  All
     directions have been closed.

   On failure, returns a SPIO error code.  Error codes with special
meaning for 'SP_fclose()' are the same as for 'SP_flush_output()', which
see.  Other error codes may also be returned.

See Also
--------

*note cpg-ref-SP_flush_output::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_flush_output,  Next: cpg-ref-SP_fopen,  Prev: cpg-ref-SP_fclose,  Up: cpg-bif

12.3.19 'SP_flush_output()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_flush_output(
       SP_stream *stream,
       spio_t_bits flush_options);

   Ensure that all buffered data reaches its destination.

Arguments
---------

STREAM
     The stream to flush.  This stream should be open for writing.

FLUSH_OPTIONS
     The following bits can be set:

     'SP_FLUSH_OUTPUT_OPTION_NO_FSYNC'

          If this is set, flush will not wait for data to reach the
          disk.  See the 'SP_fclose()' option
          'SP_FCLOSE_OPTION_NO_FSYNC' for more information.

     'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING'

          If this is set, the function should return "quickly" or with a
          'SPIO_E_WOULD_BLOCK' code.

          Can return 'SPIO_E_NOT_SUPPORTED' if the stream cannot support
          non-blocking flush.

     'SP_FLUSH_OUTPUT_OPTION_AUTOFLUSH'
          Only flush stream if it has AUTOFLUSH enabled.

Return Value
------------

On success, all buffered data should have been written and
'SPIO_S_NOERR' or some other success code returned.

   On failure, returns a SPIO error code.  Error codes with special
meaning for 'SP_flush_output()':

'SPIO_E_END_OF_FILE'
     Returned if it is not possible to write more data onto the stream,
     e.g. some underlying device has been closed.

'SPIO_E_WOULD_BLOCK'
     'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING' was set but the operation
     would block.

'SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g. 'SP_FLUSH_OUTPUT_OPTION_NONBLOCKING',
     was passed.

Other error codes may also be returned.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_fopen,  Next: cpg-ref-SP_foreign_stash,  Prev: cpg-ref-SP_flush_output,  Up: cpg-bif

12.3.20 'SP_fopen()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fopen(
       char const *pathname,
       void *reserved,
       spio_t_bits options,
       SP_stream **pstream);

   Opens a file and creates a SICStus stream reading and/or writing to
it.

Arguments
---------

PATHNAME
     The path to the file as an encoded string.  It is expanded by
     'SP_expand_file_name()' unless the option
     'SP_FOPEN_OPTION_NOEXPAND' is specified, in which case the path
     must already have been expanded by 'SP_expand_file_name()'.

RESERVED
     Reserved, should be 'NULL'.

READ_OPTIONS
     The following bits can be set:

     'SP_FOPEN_OPTION_READ'
          Open the file for reading.  The file must exist.

     'SP_FOPEN_OPTION_WRITE'
          Open the file for writing.  The file is overwritten if it
          exists.  The file is created if it does not exist.

     'SP_FOPEN_OPTION_APPEND'
          Open the file for writing but start writing at the end of the
          file if it exists.  The file is created if it does not exist.

     'SP_FOPEN_OPTION_BINARY'
          Open the file as a binary (byte) stream.

     'SP_FOPEN_OPTION_TEXT'
          Open the file as a text stream.  The default character
          encoding is "Latin 1" (i.e. the 8 bit subset of Unicode).  The
          default end of line convention is OS specific.

     'SP_FOPEN_OPTION_AUTOFLUSH'
          After writing to this stream, Prolog predicates will do a
          'flush_output/1'.  In essence this ensures that the stream
          behaves as if it were unbuffered.

     'SP_FOPEN_OPTION_INTERACTIVE'
          Treat this stream as an interactive stream.  Implies
          SP_CREATE_STREAM_OPTION_AUTOFLUSH.

     'SP_FOPEN_OPTION_NO_FSYNC'

          If this is set, flush and close of the stream will not wait
          for data to reach the disk.  See the 'SP_fclose()' option
          'SP_FCLOSE_OPTION_NO_FSYNC' for more information.

     'SP_FOPEN_OPTION_NOEXPAND'
          The 'pathname' has already been expanded with
          'SP_expand_file_name()' or something similar.  This implies
          that 'pathname' is an absolute path.  If this option is not
          specified, 'pathname' is expanded with 'SP_expand_file_name()'
          before use.

PSTREAM
     On successful return, '*pstream' will be set to the created stream.

Return Value
------------

On success, '*pstream' will be set to the created stream and
'SPIO_S_NOERR' or some other success code returned.

   On failure, some SPIO failure code will be returned.  Error codes
with special meaning for 'SP_fopen()':

'SPIO_E_FILE_NOT_FOUND'
     The file does not exist.

'SPIO_E_FILE_ACCESS'
     Insufficient permissions to open or create the file.

'SPIO_E_OPEN_ERROR'
     Generic error during open.

Other error codes may also be returned.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_foreign_stash,  Next: cpg-ref-SP_fprintf,  Prev: cpg-ref-SP_fopen,  Up: cpg-bif

12.3.21 'SP_foreign_stash()'   macro
------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_foreign_stash();

   Obtains a storage location that is unique to the calling foreign
resource.

Return Value
------------

The location, initially set to 'NULL'.

Description
-----------

A dynamic foreign resource that is used by multiple SICStus runtimes in
the same process may need to maintain a global state that is kept
separate for each SICStus runtime.  Each SICStus runtime maintains a
location (containing a 'void*') for each foreign resource.  A foreign
resource can then access this location to store any data that is
specific to the calling SICStus runtime.

   You can use 'SP_foreign_stash()' to get access to a location, where
the foreign resource can store a 'void*'.  Typically this would be a
pointer to a C struct that holds all information that need to be stored
in global variables.  This struct can be allocated and initialized by
the foreign resource init function, it should be deallocated by the
foreign resource deinit function.

   'SP_foreign_stash()' is only available for use in dynamic foreign
resources.

Examples
--------

The value returned by 'SP_foreign_stash()' is only valid until the next
SICStus API call.  The correct way to initialize the location pointed at
by 'SP_foreign_stash()' is therefore:
     struct my_state {...};

     init_my_foreign_resource(...)
     {
        struct my_state *p = SP_malloc(sizeof(struct my_state));
        (*SP_foreign_stash()) = (void*)p;
     }

The following example is incorrect; 'SP_malloc()' may be called between
the time 'SP_foreign_stash()' is called and the time its return value is
used:
     // WRONG
     (*SP_foreign_stash()) = SP_malloc(sizeof(struct my_state));

See Also
--------

*note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_fprintf,  Next: cpg-ref-SP_free,  Prev: cpg-ref-SP_foreign_stash,  Up: cpg-bif

12.3.22 'SP_fprintf()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_fprintf(
        SP_stream *stream,
        char const *fmt, ...);

   Formatted output on the Prolog stream 'stream'.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for output.

FMT
     The format string.  This uses the same syntax as the C library
     'printf' functions.

...
     The data to format.

Return Value
------------

On success, all data has been written and 'SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for 'SP_fprintf()':

'SPIO_E_PARAMETER_ERROR'
     The underlying C library function reported an error while
     formatting the string.

Other error codes may also be returned.

Description
-----------

First the formatting operation will be performed.  The resulting string
will be assumed to be in internal encoding, and will then be output
using the 'SP_put_encoded_string()' function.  This means e.g. that the
'%c' printf conversion specification can only be used for ASCII
characters, and the strings included using a '%s' specification should
also be encoded strings.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_free,  Next: cpg-ref-SP_get_address,  Prev: cpg-ref-SP_fprintf,  Up: cpg-bif

12.3.23 'SP_free()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_free(void *ptr);

   Disposees of the block referenced by 'ptr', which must have been
obtained by a call to 'SP_malloc()' or 'SP_realloc()', and must not have
been released by a call to 'SP_free()' or 'SP_realloc()'.

Arguments
---------

PTR
     Block to dispose of.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_get_address,  Next: cpg-ref-SP_get_arg,  Prev: cpg-ref-SP_free,  Up: cpg-bif

12.3.24 'SP_get_address()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_address(SP_term_ref term,
                    void **p);

   Assigns to '*p' the pointer that corresponds to a Prolog integer

Arguments
---------

TERM
     The SP_term_ref holding the value

P
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_arg,  Next: cpg-ref-SP_get_atom,  Prev: cpg-ref-SP_get_address,  Up: cpg-bif

12.3.25 'SP_get_arg()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_arg(int i,
                SP_term_ref term,
                SP_term_ref arg);

   Assigns to 'arg' the 'i':th argument of a compound term.  This is
similar to calling 'arg/3'.

Arguments
---------

I
     The (one-based) argument number

TERM
     The SP_term_ref holding the compound term

ARG
     The SP_term_ref to be assigned

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_atom,  Next: cpg-ref-SP_get_byte,  Prev: cpg-ref-SP_get_arg,  Up: cpg-bif

12.3.26 'SP_get_atom()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_atom(SP_term_ref term,
                 SP_atom *a);

   Assigns to '*a' the canonical representation of a Prolog atom

Arguments
---------

TERM
     The SP_term_ref holding the value

A
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_byte,  Next: cpg-ref-SP_get_code,  Prev: cpg-ref-SP_get_atom,  Up: cpg-bif

12.3.27 'SP_get_byte()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_byte(
       SP_stream *stream);

   Read a byte from a binary stream.

Arguments
---------

STREAM
     The stream.  Must be a binary stream open for input.

Return Value
------------

On success, the byte just read will be returned, cast to a
'spio_t_error_code'.  The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with 'SPIO_FAILED()'.
Error codes are always negative.

Description
-----------

Note that 'SP_get_byte()' is implemented as a macro and may evaluate the
'stream' argument more than once.

See Also
--------

*note cpg-ref-SP_get_code::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_code,  Next: cpg-ref-SP_get_current_dir,  Prev: cpg-ref-SP_get_byte,  Up: cpg-bif

12.3.28 'SP_get_code()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_code(
       SP_stream *stream);

   Read a character code from a text stream.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for input.

Return Value
------------

On success, the character just read will be returned, cast to a
'spio_t_error_code'.  The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with 'SPIO_FAILED()'.
Error codes are always negative.

Description
-----------

Note that 'SP_get_code()' is implemented as a macro and may evaluate the
'stream' argument more than once.

See Also
--------

*note cpg-ref-SP_get_byte::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_current_dir,  Next: cpg-ref-SP_get_dispatch,  Prev: cpg-ref-SP_get_code,  Up: cpg-bif

12.3.29 'SP_get_current_dir()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     char *
     SP_get_current_dir(void);

   Obtains an encoded string containing the absolute, slash ('/')
terminated, path to the current working directory.  The return value is
allocated with 'SP_malloc' and should be freed with 'SP_free'.

Return Value
------------

The string on success and 'NULL' on error.

See Also
--------

*note cpg-ref-SP_set_current_dir::.  *note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_get_dispatch,  Next: cpg-ref-SP_get_float,  Prev: cpg-ref-SP_get_current_dir,  Up: cpg-bif

12.3.30 'SP_get_dispatch()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SICSTUS_API_STRUCT_TYPE *
     SP_get_dispatch(void *reserved);


Arguments
---------

RESERVED
     Reserved, should be 'NULL'.

Return Value
------------

Returns the dispatch vector of the SICStus runtime.

Description
-----------

This function can be called from any thread.

   This function is special in that it is not accessed through the
dispatch vector; instead, it is exported in the ordinary manner from the
SICStus runtime dynamic library ('sprt4-7-0.dll' under Windows and,
typically, 'libsprt4-7-0.so' under UNIX).

   The address of this function is typically obtained by linking to the
SICStus runtime library or, when using multiple SICStus runtimes, by a
call to 'SP_load_sicstus_run_time()'.

See Also
--------

*note Multiple SICStus Runtimes::.


File: sicstus.info,  Node: cpg-ref-SP_get_float,  Next: cpg-ref-SP_get_functor,  Prev: cpg-ref-SP_get_dispatch,  Up: cpg-bif

12.3.31 'SP_get_float()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_float(SP_term_ref term,
                  double *f);

   Assigns to '*f' the float that corresponds to a Prolog number.

   If the term is an integer that does not fit in a 'double', then the
call will fail.

Arguments
---------

TERM
     The SP_term_ref holding the value

F
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_functor,  Next: cpg-ref-SP_get_integer,  Prev: cpg-ref-SP_get_float,  Up: cpg-bif

12.3.32 'SP_get_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_functor(SP_term_ref term,
                    SP_atom *name,
                    int *arity);

   Assigns to '*name' and '*arity' the canonical representation and
arity of the principal functor of a Prolog compound term.  If the value
of 'term' is an atom, then that atom is assigned to '*name' and 0 is
assigned to '*arity'.  This is similar to calling 'functor/3' with the
first argument bound to a compound term or an atom and the second and
third arguments unbound.

Arguments
---------

TERM
     The SP_term_ref holding the value

NAME
     The location to assign to the functor name

ARITY
     The location to assign to the functor arity

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_integer,  Next: cpg-ref-SP_get_integer_bytes,  Prev: cpg-ref-SP_get_functor,  Up: cpg-bif

12.3.33 'SP_get_integer()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_integer(SP_term_ref term,
                    SP_integer *i);

   Assigns to '*i' the integer that corresponds to a Prolog number.  The
value must fit in '*i' for the operation to succeed.

Arguments
---------

TERM
     The SP_term_ref holding the value

I
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_integer_bytes,  Next: cpg-ref-SP_get_list,  Prev: cpg-ref-SP_get_integer,  Up: cpg-bif

12.3.34 'SP_get_integer_bytes()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_integer_bytes(SP_term_ref term,
                          void *buf,
                          size_t *pbuf_size,
                          int native);

   Extracts from 'term' an an arbitrarily sized integer.

Arguments
---------

TERM
     The SP_term_ref holding the integer

BUF
     The buffer receiving the integer

PBUF_SIZE
     Should point at the size of 'buf'

NATIVE
     See the description below

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

Description
-----------

In the following, assume that the integer referred to by 'term' requires
a minimum of SIZE bytes to store (in twos-complement representation).

  1. If 'term' does not refer to a Prolog integer, zero is returned and
     the other arguments are ignored.
  2. If '*pbuf_size' is less than SIZE, then '*pbuf_size' is updated to
     SIZE and zero is returned.  The fact that '*pbuf_size' has changed
     can be used to distinguish insufficient buffer size from other
     possible errors.  By calling 'SP_get_integer_bytes()' with
     '*pbuf_size' set to zero, you can determine the buffer size needed;
     in this case, 'buf' is ignored.
  3. '*pbuf_size' is set to SIZE.
  4. If 'native' is zero, 'buf' is filled with the twos complement
     representation of the integer, with the least significant bytes
     stored at lower indices in 'buf'.  Note that all of 'buf' is
     filled, even though only SIZE bytes was needed.
  5. If 'native' is non-zero, 'buf' is assumed to point at a native
     '*pbuf_size' byte integral type.  On most platforms, native integer
     sizes of two (16-bit), four (32 bit) and eight (64 bytes) bytes are
     supported.  Note that '*pbuf_size == 1', which would correspond to
     'signed char', is _not_ supported with 'native'.
  6. If an unsupported size is used with 'native', zero is returned.

Examples
--------

The following example gets a Prolog integer into a (presumably 64 bit)
'long long' C integer.
     {
       long long x; // C99, GCC supports this
       size_t sz = sizeof x;
       if (!SP_get_integer_bytes(tr, &x, &sz, 1)) // 1 for native
         .. error handling ..
       .. use x .. // sz may have decreased
     }

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list,  Next: cpg-ref-SP_get_list_codes,  Prev: cpg-ref-SP_get_integer_bytes,  Up: cpg-bif

12.3.35 'SP_get_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list(SP_term_ref term,
                 SP_term_ref head,
                 SP_term_ref tail);

   Assigns to 'head' and 'tail' the head and tail of a Prolog list.

Arguments
---------

TERM
     The SP_term_ref holding the list

HEAD
     The SP_term_ref to be assigned the head

TAIL
     The SP_term_ref to be assigned the tail

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_codes,  Next: cpg-ref-SP_get_list_n_bytes,  Prev: cpg-ref-SP_get_list,  Up: cpg-bif

12.3.36 'SP_get_list_codes()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_codes(SP_term_ref term,
                       char const **s);

   Assigns to '*s' a zero-terminated array containing an encoded string
that corresponds to the given Prolog code list.  The array is subject to
reuse by other support functions, so if the value is going to be used on
a more than temporary basis, it must be moved elsewhere.

Arguments
---------

TERM
     The SP_term_ref holding the code list

S
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_n_bytes,  Next: cpg-ref-SP_get_list_n_codes,  Prev: cpg-ref-SP_get_list_codes,  Up: cpg-bif

12.3.37 'SP_get_list_n_bytes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_n_bytes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         size_t *w,
                         unsigned char *s);

   Copies into the byte array 's' the initial elements of 'term', which
should hold a list of integers in the range [0,255], so that at most 'n'
bytes are used.  The number of bytes actually written is assigned to
'*w'.  'tail' is set to the remainder of the list.  The array 's' must
have room for at least 'n' bytes.

Arguments
---------

TERM
     The SP_term_ref holding the list

TAIL
     The SP_term_ref to be assigned the remainder of the list

N
     Max number of bytes to use

W
     Location to assign to number of bytes actually used

S
     The location to assign to the encoded string

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_list_n_codes,  Next: cpg-ref-SP_get_number_codes,  Prev: cpg-ref-SP_get_list_n_bytes,  Up: cpg-bif

12.3.38 'SP_get_list_n_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_list_n_codes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         size_t *w,
                         char *s);

   Copies into 's' the encoded string representing the character codes
in the initial elements of list 'term', so that at most 'n' bytes are
used.  The number of bytes actually written is assigned to '*w'.  'tail'
is set to the remainder of the list.  The array 's' must have room for
at least 'n' bytes.

   *Please note*: The array 's' is never 'NUL'-terminated.  Any zero
character codes in the list 'term' will be converted to the overlong
UTF-8 sequence '0xC0 0x80'.

Arguments
---------

TERM
     The SP_term_ref holding the code list

TAIL
     The SP_term_ref to be assigned the remainder of the list

N
     Max number of bytes to use

W
     Location to assign to number of bytes actually used

S
     The location to assign to the encoded string

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_number_codes,  Next: cpg-ref-SP_get_stream_counts,  Prev: cpg-ref-SP_get_list_n_codes,  Up: cpg-bif

12.3.39 'SP_get_number_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_number_codes(SP_term_ref term,
                         char const **s);

   Assigns to '*s' a zero-terminated array of characters corresponding
to the printed representation of a Prolog number.  The array is subject
to reuse by other support functions, so if the value is going to be used
on a more than temporary basis, it must be moved elsewhere.

Arguments
---------

TERM
     The SP_term_ref holding the number

S
     The location to assign to the array

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_get_stream_counts,  Next: cpg-ref-SP_get_stream_user_data,  Prev: cpg-ref-SP_get_number_codes,  Up: cpg-bif

12.3.40 'SP_get_stream_counts()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_stream_counts(
        SP_stream *stream,
        spio_t_offset *pitem_count,
        spio_t_offset *pnewline_count,
        spio_t_offset *pline_length,
        spio_t_bits options);

   Obtain the stream counters.

Arguments
---------

STREAM
     The stream.

ITEM_COUNT
     If 'pitem_count' is 'NULL' it is not used, otherwise it is used as
     follows.

     On success, '*pitem_count' is assigned to the number of items read
     from an input-only or bidirectional stream or with the number of
     items written to a output-only stream.

     For binary streams, an "item" is a byte, for text streams it is a
     character.

PNEWLINE_COUNT
     If 'pnewline_count' is 'NULL' it is not used, otherwise it is used
     as follows.

     On success '*pnewline_count' is assigned to the number of newlines
     read from an input-only or bidirectional text stream or with the
     number of newlines written to a output-only text stream.

     For binary streams, '*pnewline_count' is set to zero.

PLINE_LENGTH
     If 'pline_length' is 'NULL' it is not used, otherwise it is used as
     follows.

     On success, '*pline_length' is assigned to the number of characters
     read on the current line from an input-only or bidirectional text
     stream or with the characters written on the current line to a
     output-only text stream.

     For binary streams, '*pline_length' is set to zero.

OPTIONS
     The following bits can be set:

     'SP_GET_STREAM_COUNTS_OPTION_READ'
          Return the real input counts of a read-only or bidirectional
          stream.

     'SP_GET_STREAM_COUNTS_OPTION_WRITE'
          Return the real output counts of a write-only stream.

          Currently, the call will fail with 'SPIO_E_NOT_SUPPORTED' if
          the stream is bidirectional and
          'SP_GET_STREAM_COUNTS_OPTION_WRITE' is specified.  This is
          because there is only one set of counters for each stream and
          these are used to count in the input direction of
          bidirectional streams.  This may be changed in a future
          release.

     At most one of 'SP_GET_STREAM_COUNTS_OPTION_READ' and
     'SP_GET_STREAM_COUNTS_OPTION_WRITE' can be specified.  If neither
     is specified then default behavior is as follows
        * If 'stream' is interactive, a common set of counts shared by
          all interactive streams is returned.

        * If 'stream' is write-only, the output counts are returned.

        * Otherwise, the 'stream' is read-only or bidirectional and the
          input counts are returned.

Return Value
------------

On success, 'SPIO_S_NOERR' or some other success code is returned.

   On failure, returns a SPIO error code.  Error codes with special
meaning for 'SP_get_stream_counts()':

'SPIO_E_NOT_READ'
     'SP_GET_STREAM_COUNTS_OPTION_READ' was specified but 'stream' is
     not an input stream.

'SPIO_E_NOT_WRITE'
     'SP_GET_STREAM_COUNTS_OPTION_WRITE' was specified but 'stream' is
     not an output stream.

'SPIO_E_NOT_SUPPORTED'
     'SP_GET_STREAM_COUNTS_OPTION_WRITE' was specified but 'stream' is a
     bidirectional stream.

Description
-----------

There is only one set of counters for each stream.  For a bidirectional
stream, these counters only count in the input direction and the output
direction does not affect the counts.

   There is a common set of stream counters for all interactive streams.
By default, these will be returned if 'stream' is interactive instead of
the real counts.  This behavior can be changed with the 'options'
argument, see above.

See Also
--------

*note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_get_stream_user_data,  Next: cpg-ref-SP_get_string,  Prev: cpg-ref-SP_get_stream_counts,  Up: cpg-bif

12.3.41 'SP_get_stream_user_data()'
-----------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_get_stream_user_data(
        SP_stream *stream,
        void const *user_class,
        void **puser_data);

   Get the user data of a user defined stream of a particular class.

Arguments
---------

STREAM
     An arbitrary stream.  It is legal, and often useful, to call
     'SP_get_stream_user_data()' on a stream even if it is not known
     whether the stream is in fact a user defined stream of a particular
     class.

PUSER_DATA
     On success, '*puser_data' will be set to the 'user_data' value used
     when the stream was created.

Return Value
------------

On success, '*puser_data' is assigned and 'SPIO_S_NOERR' or some other
success code is returned.

   On failure, e.g. if the stream was not created with this
'user_class', an error code is returned.

Description
-----------

This function is used in order to recognize streams of a particular type
(or "class").  At the same time as it verifies the type of stream it
also returns the 'user_data' which gives the caller a handle to the
internal state of the user defined stream.

   The following sample illustrates how all streams of a particular
class can be found and closed.  This function mimics the behavior of the
'SP_FCLOSE_OPTION_USER_STREAMS' option to 'SP_fclose', see *note
cpg-ref-SP_fclose::.

     spio_t_error_code close_streams(void const *user_class, int force)
     {
       spio_t_error_code ecode = SPIO_E_ERROR;
       SP_stream *stream;
       SP_stream *next_stream;
       void *user_data;
       spio_t_bits fclose_options = 0;

       if (force) fclose_options |= SP_FCLOSE_OPTION_FORCE;

       stream = NULL;           /* means start of list of stream */
       do
         {
           /* Note: We need to do this before closing stream */
           ecode = SP_next_stream(stream, &next_stream);
           if (SPIO_FAILED(ecode)) goto barf;

           if (stream != NULL)
             {
               if (SPIO_SUCCEEDED(SP_get_stream_user_data(stream, user_class, &user_data)))
                 {
                   /* This is the right class of stream, close it */
                   ecode = SP_fclose(stream, fclose_options);
                   if (SPIO_FAILED(ecode))
                     {
                       if (!force) goto barf; /* ignore error if force */
                     }
                 }
             }
           stream = next_stream;
         }
       while (stream != NULL);

       return SPIO_S_NOERR;

      barf:
       return ecode;
     }

See Also
--------

*note cpg-ref-SP_create_stream::.  *note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-SP_get_string,  Next: cpg-ref-SP_getenv,  Prev: cpg-ref-SP_get_stream_user_data,  Up: cpg-bif

12.3.42 'SP_get_string()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_get_string(SP_term_ref term,
                   char const **s);

   Assigns to '*s' a pointer to the encoded string representing the name
of a Prolog atom.  This string must _not_ be modified by the calling
function.

Arguments
---------

TERM
     The SP_term_ref holding the value

S
     The location to assign

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Accessing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_getenv,  Next: cpg-ref-SP_initialize,  Prev: cpg-ref-SP_get_string,  Up: cpg-bif

12.3.43 'SP_getenv()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_getenv(const char *name);

   Retrieves the value of the system property, or if no such system
property exists the environment variable, with the given name.

   The memory for the returned value is managed by Prolog and should be
freed with 'SP_free()'.

Arguments
---------

NAME
     The name of the system property or environment variable.

Return Value
------------

The value of the system property or environment variable, if set.
'NULL' if neither a system property nor an environment variable of that
name exists, or if an error occurs.

See Also
--------

*note System Properties and Environment Variables::.


File: sicstus.info,  Node: cpg-ref-SP_initialize,  Next: cpg-ref-SP_is_atom,  Prev: cpg-ref-SP_getenv,  Up: cpg-bif

12.3.44 'SP_initialize()'   macro
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_initialize(int argc,
     	      char **argv,
     	      SP_options *options);

   Initializes the Prolog engine.

Arguments
---------

ARGC
     The number of elements of the 'argv' vector.

ARGV
     A vector of strings that can be accessed by 'prolog_flag(argv,X)'.
     This argument is copied by 'SP_initialize()' so it can be discarded
     by the caller.  May be passed as 'NULL' if 'argc' is zero.

     Each entry should be an encoded string, i.e. encoded using 'UTF-8'.
     This may not be the encoding used by the operating system when
     invoking 'main()'.  A better alternative is to pass zero for
     'argc', NULL for 'argv' and use 'SP_set_argv()' to pass the 'argv'
     entries.

OPTIONS
     A pointer to an option block.  In most cases it suffice to pass
     'NULL'.

     An option block can be initialized with
     'SP_OPTIONS_STATIC_INITIALIZER' and its 'options' field set to
     point to a 'SP_option' array.  Each 'SP_option' is a typed value.
     Currently the only type is 'SP_option_type_system_property', for
     setting initial system properties (*note System Properties and
     Environment Variables::).

     To pass the system properties 'foo' and 'bar', with values 'true'
     and 'hello', respectively, you would do something like this


            ...
            int res;
            SP_options opts = SP_OPTIONS_STATIC_INITIALIZER;
            SP_option props[2];

            opts.noptions = 0;
            opts.options = &props;
            props[opts.noptions].type = SP_option_type_system_property;
            props[opts.noptions].u.prop.key = "foo";
            props[opts.noptions].u.prop.value = "true";
            opts.noptions++;

            props[opts.noptions].type = SP_option_type_system_property;
            props[opts.noptions].u.prop.key = "bar";
            props[opts.noptions].u.prop.value = "hello";
            opts.noptions++;

            res = SP_initialize(argv, argc, &opts);
            if (res != SP_SUCCESS) {
                 ... /* error handling */
            }
            ...


Return Value
------------

'SP_SUCCESS' if initialization was successful.  If initialization was
successful, further calls to 'SP_initialize()' will be no-ops (and
return 'SP_SUCCESS').

Description
-----------

This must be done before any interface functions are called, except
those annotated as "[preinit]".  The function will allocate data areas
used by Prolog, initialize command line arguments so that they can be
accessed by the 'argv' Prolog flag, and load the Runtime Library.

See Also
--------

*note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_is_atom,  Next: cpg-ref-SP_is_atomic,  Prev: cpg-ref-SP_initialize,  Up: cpg-bif

12.3.45 'SP_is_atom()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_atom(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a atom and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_atomic,  Next: cpg-ref-SP_is_compound,  Prev: cpg-ref-SP_is_atom,  Up: cpg-bif

12.3.46 'SP_is_atomic()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_atomic(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog atomic term.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is an atomic term and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_compound,  Next: cpg-ref-SP_is_float,  Prev: cpg-ref-SP_is_atomic,  Up: cpg-bif

12.3.47 'SP_is_compound()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_compound(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog compound term.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a compound term and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_float,  Next: cpg-ref-SP_is_integer,  Prev: cpg-ref-SP_is_compound,  Up: cpg-bif

12.3.48 'SP_is_float()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_float(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog float.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a float and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_integer,  Next: cpg-ref-SP_is_list,  Prev: cpg-ref-SP_is_float,  Up: cpg-bif

12.3.49 'SP_is_integer()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_integer(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog integer.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a integer and 0 otherwise.

   *Please note*: 'SP_is_integer()' will return true also for integers
that are too large to be passed to 'SP_get_integer()'.  In this case you
will need to use 'SP_get_integer_bytes()' to obtain the value.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_list,  Next: cpg-ref-SP_is_number,  Prev: cpg-ref-SP_is_integer,  Up: cpg-bif

12.3.50 'SP_is_list()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_list(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog list cell, i.e. a
compound term with functor './2'.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if the argument is a list cell and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_number,  Next: cpg-ref-SP_is_variable,  Prev: cpg-ref-SP_is_list,  Up: cpg-bif

12.3.51 'SP_is_number()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_number(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog number.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a number and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_is_variable,  Next: cpg-ref-SP_load,  Prev: cpg-ref-SP_is_number,  Up: cpg-bif

12.3.52 'SP_is_variable()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_is_variable(SP_term_ref term);

   Determines whether the value of 'term' is a Prolog variable.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

1 if it is a variable and 0 otherwise.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_load,  Next: cpg-ref-SP_load_sicstus_run_time,  Prev: cpg-ref-SP_is_variable,  Up: cpg-bif

12.3.53 'SP_load()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_load(char const *filename);


   Calls 'load_files/1'.

Arguments
---------

FILENAME
     The file name, which is treated as a Prolog atom.

Return Value
------------

See 'SP_query_cut_fail()'.

See Also
--------

*note Loading Prolog Code::.


File: sicstus.info,  Node: cpg-ref-SP_load_sicstus_run_time,  Next: cpg-ref-SP_malloc,  Prev: cpg-ref-SP_load,  Up: cpg-bif

12.3.54 'SP_load_sicstus_run_time()'
------------------------------------

Synopsis
--------

  since release 4.0.3

     #include <sicstus/sicstus.h>

     int
     SP_load_sicstus_run_time(SP_get_dispatch_type **pfuncp,
                              void *reserved);


Arguments
---------

PFUNCP
     On success the address of the 'SP_get_dispatch()' function of the
     newly loaded SICStus runtime is stored at this address.

RESERVED
     Reserved, should be 'NULL'.

Return Value
------------

Positive if a new runtime could be loaded, non-positive on error.
*Please note*: The return value was incorrectly described prior to
SICStus Prolog 4.0.5.  Also note that, for historical reasons, the
meaning of the return value is different from the convention used by
most of the SICStus Prolog C API.

Description
-----------

'SP_load_sicstus_run_time()' loads a new SICStus runtime.

   As a special case, if 'SP_load_sicstus_run_time()' is called from a
SICStus runtime that has not been initialized (with 'SP_initialize()')
and that has not previously been loaded as the result of calling
'SP_load_sicstus_run_time()', no new runtime is loaded.  Instead, the
'SP_get_dispatch()' of the runtime itself is returned.  In particular,
the first time 'SP_load_sicstus_run_time()' is called on the initial
SICStus runtime, and if this happens before the initial SICStus runtime
is initialized, no new runtime is loaded.

   Calling 'SP_load_sicstus_run_time()' from a particular runtime can be
done from any thread.

   An application that links statically with the SICStus runtime should
not call 'SP_load_sicstus_run_time()'.

   You should not use pre-linked foreign resources when using multiple
SICStus runtimes in the same process.

   For an example of loading and using multiple SICStus runtimes, see
'library/jasper/spnative.c' that implements this functionality for the
Java interface Jasper.

See Also
--------

*note Multiple SICStus Runtimes::.


File: sicstus.info,  Node: cpg-ref-SP_malloc,  Next: cpg-ref-SP_mutex_lock,  Prev: cpg-ref-SP_load_sicstus_run_time,  Up: cpg-bif

12.3.55 'SP_malloc()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_malloc(size_t size);

   Allocates a block of at least 'size' bytes.

Arguments
---------

SIZE
     Requested number of bytes.

Return Value
------------

'NULL' on failure, the pointer otherwise.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_mutex_lock,  Next: cpg-ref-SP_mutex_unlock,  Prev: cpg-ref-SP_malloc,  Up: cpg-bif

12.3.56 'SP_mutex_lock()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     static SP_mutex volatile MUTEX = SP_MUTEX_INITIALIZER;

     int
     SP_mutex_lock(SP_mutex *pmx);

   Locks the mutex.

Return Value
------------

Zero on error, non-zero on success.

Examples
--------

     static SP_mutex volatile my_mutex = SP_MUTEX_INITIALIZER;
     // only access this counter with my_mutex locked
     int volatile protected_counter = 0;

     // returns the new value of protected_counter
     int increment_the_counter(void)
     {
       int new_value;

       if(SP_mutex_lock(&my_mutex) == 0) goto error_handling;
       // No other thread can update protected_counter here
       new_value = protected_counter+1;
       protected_counter = new_value;
       if (SP_mutex_unlock(&my_mutex) == 0) goto error_handling;
       return new_value;

     error_handling:
       ...
     }

See Also
--------

*note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_mutex_unlock,  Next: cpg-ref-SP_new_term_ref,  Prev: cpg-ref-SP_mutex_lock,  Up: cpg-bif

12.3.57 'SP_mutex_unlock()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     static SP_mutex volatile MUTEX = SP_MUTEX_INITIALIZER;

     int
     SP_mutex_unlock(SP_mutex *pmx);

   Unlocks the mutex.

Return Value
------------

Zero on error, non-zero on success.

Description
-----------

The number of unlocks must match the number of locks and only the thread
that performed the lock can unlock the mutex.

Examples
--------

See the example of 'SP_mutex_lock()'.

See Also
--------

*note OS Threads::.


File: sicstus.info,  Node: cpg-ref-SP_new_term_ref,  Next: cpg-ref-SP_next_solution,  Prev: cpg-ref-SP_mutex_unlock,  Up: cpg-bif

12.3.58 'SP_new_term_ref()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_term_ref
     SP_new_term_ref(void);

   Creates a new SP_term_ref, initialized to the empty list '[]'.

Return Value
------------

The new SP_term_ref.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_next_solution,  Next: cpg-ref-SP_next_stream,  Prev: cpg-ref-SP_new_term_ref,  Up: cpg-bif

12.3.59 'SP_next_solution()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_next_solution(SP_qid query);

   Look for the next solution to the given query.

Arguments
---------

QUERY
     The query, created by 'SP_open_query()'.

Return Value
------------

'SP_SUCCESS' for success, 'SP_FAILURE' for failure, 'SP_ERROR' if an
error condition occurred.

Description
-----------

This will cause the Prolog engine to backtrack over any current solution
of an open query and look for a new one.  The given argument must be the
innermost query that is still open, i.e. it must not have been
terminated explicitly by 'SP_close_query()' or 'SP_cut_query()'.  Only
when the return value is 'SP_SUCCESS' are the values in the query
arguments valid, and will remain so until backtracking into this query
or an enclosing one.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_next_stream,  Next: cpg-ref-SP_open_query,  Prev: cpg-ref-SP_next_solution,  Up: cpg-bif

12.3.60 'SP_next_stream()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_next_stream(SP_stream *stream, SP_stream **pnext);

   Iterate through all Prolog streams.

Arguments
---------

STREAM
     If this is 'NULL' then '*pnext' is set to the first stream in the
     list of streams.  If this is non-'NULL' then the stream following
     STREAM in the list of streams is returned in '*pnext'.

PNEXT
     The returned stream is returned in '*pnext'.

Return Value
------------

On success, '*pnext' is assigned, and 'SPIO_S_NOERR' or some other
success code is returned.  You should use the 'SPIO_FAILED()' macro to
determine if the return value signifies failure or success.

   When 'stream' is the last stream '*pnext' is set to 'NULL'.

   This function can be used to iterate over all Prolog streams.  One
way to use this is together with 'SP_get_stream_user_data' to find all
currently open user defined streams of a particular type.

See Also
--------

*note SICStus Streams::.


File: sicstus.info,  Node: cpg-ref-SP_open_query,  Next: cpg-ref-SP_pred,  Prev: cpg-ref-SP_next_stream,  Up: cpg-bif

12.3.61 'SP_open_query()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_qid
     SP_open_query(SP_pred_ref predicate,
                   SP_term_ref arg1,
                   ...);

   Sets up a query for use by 'SP_next_solution()', 'SP_close_query()',
'SP_cut_query()'.

Arguments
---------

PREDICATE
     The predicate to call.

ARG1...
     The arguments to pass.

Return Value
------------

The query identifier if successful, otherwise 0,

Description
-----------

Note that if a new query is opened while another is already open, the
new query must be terminated before exploring the solutions of the old
one.  That is, queries must be strictly nested.

See Also
--------

*note Finding Multiple Solutions of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_pred,  Next: cpg-ref-SP_predicate,  Prev: cpg-ref-SP_open_query,  Up: cpg-bif

12.3.62 'SP_pred()'
-------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_pred_ref
     SP_pred(SP_atom name_atom,
     	SP_integer arity,
     	SP_atom module_atom);

   Returns a pointer to the predicate definition.

Arguments
---------

NAME_ATOM
     Predicate name.

ARITY
     Arity.

MODULE_ATOM
     Module name.

Return Value
------------

The reference if the predicate is found, 'NULL' otherwise with error
code 'PRED_NOT_FOUND'.

Description
-----------

Faster than 'SP_predicate()'.

See Also
--------

*note Calling Prolog from C::.


File: sicstus.info,  Node: cpg-ref-SP_predicate,  Next: cpg-ref-SP_printf,  Prev: cpg-ref-SP_pred,  Up: cpg-bif

12.3.63 'SP_predicate()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     SP_pred_ref
     SP_predicate(char *name_string,
     	     SP_integer arity,
     	     char *module_string);

   Returns a pointer to the predicate definition.

Arguments
---------

NAME_STRING
     Predicate name.

ARITY
     Arity.

MODULE_STRING
     Module name, optional.  'NULL' and '""' (the empty string) both
     denote the type-in module (*note ref-mod-tyi::).

Return Value
------------

The reference if the predicate is found, 'NULL' otherwise with error
code 'PRED_NOT_FOUND' or, if one of the string arguments are malformed,
'INV_STRING'.

Description
-----------

Slower than 'SP_pred()'.

See Also
--------

*note Calling Prolog from C::.


File: sicstus.info,  Node: cpg-ref-SP_printf,  Next: cpg-ref-SP_put_address,  Prev: cpg-ref-SP_predicate,  Up: cpg-bif

12.3.64 'SP_printf()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_printf(
        char const *fmt,
        ...);

   Same as 'SP_fprintf(SP_stdout, fmt, ...)'.

See Also
--------

*note cpg-ref-SP_fprintf::.


File: sicstus.info,  Node: cpg-ref-SP_put_address,  Next: cpg-ref-SP_put_atom,  Prev: cpg-ref-SP_printf,  Up: cpg-bif

12.3.65 'SP_put_address()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_address(SP_term_ref term,
                    void *pointer);

   Assigns to 'term' a reference to a Prolog integer representing a
pointer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

POINTER
     The pointer

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_atom,  Next: cpg-ref-SP_put_byte,  Prev: cpg-ref-SP_put_address,  Up: cpg-bif

12.3.66 'SP_put_atom()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_atom(SP_term_ref term,
                 SP_atom atom);

   Assigns to 'term' a reference to a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be assigned

ATOM
     The atom

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_byte,  Next: cpg-ref-SP_put_bytes,  Prev: cpg-ref-SP_put_atom,  Up: cpg-bif

12.3.67 'SP_put_byte()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_byte(
       SP_stream *stream,
       int item);

   Write a byte to a binary stream.

Arguments
---------

STREAM
     The stream.  Must be a binary stream open for output.

Return Value
------------

On success, the written byte will be returned, cast to a
'spio_t_error_code'.  The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with 'SPIO_FAILED()'.
Error codes are always negative.

Description
-----------

Note that 'SP_put_byte()' is implemented as a macro and may evaluate the
arguments more than once.  For the same reason, no error checking is
performed on the arguments.

See Also
--------

*note cpg-ref-SP_put_code::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_bytes,  Next: cpg-ref-SP_put_code,  Prev: cpg-ref-SP_put_byte,  Up: cpg-bif

12.3.68 'SP_put_bytes()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_bytes(
       SP_stream *stream,
       spio_t_uint8 const *bytes,
       size_t byte_count,
       spio_t_bits options);

   Write several bytes to a binary stream.

Arguments
---------

STREAM
     The stream.  Must be a binary stream open for output.

BYTES
     A pointer to the data to write.

BYTE_COUNT
     The number of bytes to write.

OPTIONS
     The following bits can be set:

     'SP_PUT_BYTES_OPTION_NONBLOCKING'
          Write the bytes without blocking.

Return Value
------------

On success, all data has been written and 'SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for 'SP_put_bytes()':

'SPIO_E_WOULD_BLOCK'
     'SP_PUT_BYTES_OPTION_NONBLOCKING' was set but the operation would
     block.

Other error codes may also be returned.

See Also
--------

*note cpg-ref-SP_put_byte::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_code,  Next: cpg-ref-SP_put_codes,  Prev: cpg-ref-SP_put_bytes,  Up: cpg-bif

12.3.69 'SP_put_code()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_code(
       SP_stream *stream,
       int item);

   Write a character code to a text stream.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for output.

Return Value
------------

On success, the written character will be returned, cast to a
'spio_t_error_code'.  The value returned on successful return will never
be negative.

   On failure, returns an error code, recognizable with 'SPIO_FAILED()'.
Error codes are always negative.

Description
-----------

Note that 'SP_put_code()' is implemented as a macro and may evaluate the
arguments more than once.  For the same reason, no error checking is
performed on the arguments.

See Also
--------

*note cpg-ref-SP_put_byte::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_codes,  Next: cpg-ref-SP_put_encoded_string,  Prev: cpg-ref-SP_put_code,  Up: cpg-bif

12.3.70 'SP_put_codes()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_codes(
       SP_stream *stream,
       spio_t_wchar const *codes,
       size_t code_count,
       spio_t_bits options);

   Write several codes to a text stream.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for output.

CODES
     A pointer to the data to write.

CODE_COUNT
     The number of character codes to write.  Note that this is the
     number of character codes, not the number of bytes.

OPTIONS
     The following bits can be set:

     'SP_PUT_CODES_OPTION_NONBLOCKING'
          Write the codes without blocking.

Return Value
------------

On success, all data has been written and 'SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for 'SP_put_codes()':

'SPIO_E_WOULD_BLOCK'
     'SP_PUT_CODES_OPTION_NONBLOCKING' was set but the operation would
     block.

Other error codes may also be returned.

See Also
--------

*note cpg-ref-SP_put_code::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_encoded_string,  Next: cpg-ref-SP_put_float,  Prev: cpg-ref-SP_put_codes,  Up: cpg-bif

12.3.71 'SP_put_encoded_string()'
---------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_put_encoded_string(
       SP_stream *stream,
       spio_t_wchar const *encoded_string,
       spio_t_bits options);

   Write an encoded string to a text stream.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for output.

ENCODED_STRING
     An encoded string to write.

OPTIONS
     The following bits can be set:

     'SP_PUT_ENCODED_STRING_OPTION_NONBLOCKING'
          Write the string without blocking.

Return Value
------------

On success, all data has been written and 'SPIO_S_NOERR' or some other
success code returned.

   On failure, returns an error code without transferring any data.
Error codes with special meaning for 'SP_put_encoded_string()':

'SPIO_E_WOULD_BLOCK'
     'SP_PUT_ENCODED_STRING_OPTION_NONBLOCKING' was set but the
     operation would block.

Other error codes may also be returned.

See Also
--------

*note cpg-ref-SP_put_codes::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_put_float,  Next: cpg-ref-SP_put_functor,  Prev: cpg-ref-SP_put_encoded_string,  Up: cpg-bif

12.3.72 'SP_put_float()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_float(SP_term_ref term,
                  double f);

   Assigns to 'term' a reference to a float.

Arguments
---------

TERM
     The SP_term_ref to be assigned

F
     The float (must be finite)

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_functor,  Next: cpg-ref-SP_put_integer,  Prev: cpg-ref-SP_put_float,  Up: cpg-bif

12.3.73 'SP_put_functor()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_functor(SP_term_ref term,
                    SP_atom name,
                    int arity);

   Assigns to 'term' a reference to a compound term with all the
arguments unbound variables.  If 'arity' is 0, assigns the Prolog atom
whose canonical representation is 'name'.  This is similar to calling
'functor/3' with the first argument unbound and the second and third
arguments bound to an atom and an integer, respectively.

Arguments
---------

TERM
     The SP_term_ref to be assigned

NAME
     The name of the functor

ARITY
     The arity of the functor

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_integer,  Next: cpg-ref-SP_put_integer_bytes,  Prev: cpg-ref-SP_put_functor,  Up: cpg-bif

12.3.74 'SP_put_integer()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_integer(SP_term_ref term,
                    SP_integer i);

   Assigns to 'term' a reference to an integer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

I
     The integer

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_integer_bytes,  Next: cpg-ref-SP_put_list,  Prev: cpg-ref-SP_put_integer,  Up: cpg-bif

12.3.75 'SP_put_integer_bytes()'
--------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_integer_bytes(SP_term_ref term,
                          void *buf,
                          size_t buf_size,
                          int native);

   Assigns to 'term' a reference to an arbitrarily sized integer.

Arguments
---------

TERM
     The SP_term_ref to be assigned

BUF
        * If 'native' is zero, 'buf' consists of the 'buf_size' bytes of
          the twos complement representation of the integer.  Less
          significant bytes are at lower indices.
        * If 'native' is nonzero, 'buf' is a pointer to the native
          'buf_size' bytes integer type.

BUF_SIZE
     The size of 'buf'

NATIVE
     See above.  Supported native sizes typically include two, four and
     eight (64bit) bytes.

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list,  Next: cpg-ref-SP_put_list_codes,  Prev: cpg-ref-SP_put_integer_bytes,  Up: cpg-bif

12.3.76 'SP_put_list()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list(SP_term_ref term);

   Assigns to 'term' a reference to a Prolog list whose head and tail
are both unbound variables.

Arguments
---------

TERM
     The SP_term_ref to be assigned

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_codes,  Next: cpg-ref-SP_put_list_n_bytes,  Prev: cpg-ref-SP_put_list,  Up: cpg-bif

12.3.77 'SP_put_list_codes()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_codes(SP_term_ref term,
                       SP_term_ref tail,
                       char const *s);

   Assigns to 'term' a Prolog code list represented by the encoded
string 's', prepended to the value of 'tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the code list

S
     The string to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_n_bytes,  Next: cpg-ref-SP_put_list_n_codes,  Prev: cpg-ref-SP_put_list_codes,  Up: cpg-bif

12.3.78 'SP_put_list_n_bytes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_n_bytes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         unsigned char const *s);

   Assigns to 'term' a list of integers represented by the first 'n'
elements of the byte array 's', prepended to the value of 'tail'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the list

N
     The number of bytes of 's' to convert

S
     The byte array to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_list_n_codes,  Next: cpg-ref-SP_put_number_codes,  Prev: cpg-ref-SP_put_list_n_bytes,  Up: cpg-bif

12.3.79 'SP_put_list_n_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_list_n_codes(SP_term_ref term,
                         SP_term_ref tail,
                         size_t n,
                         char const *s);

   Assigns to 'term' a Prolog code list represented by the first 'n'
*bytes* of the encoded string 's', prepended to the value of 'tail'.

   *Please note*: Some characters may be encoded using more than one
byte so the number of characters may be less than 'n'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

TAIL
     The tail of the code list

N
     The number of character codes of 's' to convert

S
     The string to convert

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_number_codes,  Next: cpg-ref-SP_put_string,  Prev: cpg-ref-SP_put_list_n_codes,  Up: cpg-bif

12.3.80 'SP_put_number_codes()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_number_codes(SP_term_ref term,
                         char const *s);

   Assigns to 'term' a reference to a Prolog number obtained by parsing
's' as if by 'number_codes/2'.

Arguments
---------

TERM
     The SP_term_ref to be assigned

S
     The string to parse

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_string,  Next: cpg-ref-SP_put_term,  Prev: cpg-ref-SP_put_number_codes,  Up: cpg-bif

12.3.81 'SP_put_string()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_string(SP_term_ref term,
                   char const *string);

   Assigns to 'term' a reference to a Prolog atom.

Arguments
---------

TERM
     The SP_term_ref to be assigned

STRING
     The string corresponding to the atom

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_term,  Next: cpg-ref-SP_put_variable,  Prev: cpg-ref-SP_put_string,  Up: cpg-bif

12.3.82 'SP_put_term()'
-----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_term(SP_term_ref to,
                 SP_term_ref from);

   Assigns to 'to' the value of 'from'.

Arguments
---------

TO
     The SP_term_ref to be assigned

FROM
     The SP_term_ref whose value is accessed

Return Value
------------

Zero if the conversion fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_put_variable,  Next: cpg-ref-SP_query,  Prev: cpg-ref-SP_put_term,  Up: cpg-bif

12.3.83 'SP_put_variable()'
---------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_put_variable(SP_term_ref term);

   Assigns to 'term' a reference to a new unbound Prolog variable.

Arguments
---------

TERM
     The SP_term_ref to be assigned

Return Value
------------

Zero if the call fails (as far as failure can be detected), and a
nonzero value otherwise.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_query,  Next: cpg-ref-SP_query_cut_fail,  Prev: cpg-ref-SP_put_variable,  Up: cpg-bif

12.3.84 'SP_query()'
--------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_query(SP_pred_ref predicate,
              SP_term_ref arg1,
              ...);

   Calls a predicate, committing to its first solution.

Arguments
---------

PREDICATE
     The predicate to call.

ARG1...
     The arguments to pass.

Return Value
------------

'SP_SUCCESS' if the goal succeeded, 'SP_FAILURE' if it failed, and
'SP_ERROR' if an error condition occurred.

Description
-----------

Use this if you are only interested in the first solution.  It will
create a goal from the predicate definition and the arguments, call it,
and commit to the first solution found, if any.  If it returns
'SP_SUCCESS', values in the query arguments valid, and will remain so
until backtracking into any enclosing query.

See Also
--------

*note Finding One Solution of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_query_cut_fail,  Next: cpg-ref-SP_raise_exception,  Prev: cpg-ref-SP_query,  Up: cpg-bif

12.3.85 'SP_query_cut_fail()'
-----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_query_cut_fail(SP_pred_ref predicate,
                       SP_term_ref arg1,
                       ...);

   Calls a predicate for side effects, reclaiming any storage used.

Arguments
---------

PREDICATE
     The predicate to call.

ARG1...
     The arguments to pass.

Return Value
------------

'SP_SUCCESS' if the goal succeeded, 'SP_FAILURE' if it failed, and
'SP_ERROR' if an error condition occurred.

Description
-----------

Call this is you are only interested in the side effects of a predicate.
It will try to prove the predicate, cut away the rest of the solutions,
and finally fail.  This will reclaim the storage used after the call,
and throw away any solution found.

See Also
--------

*note Finding One Solution of a Call::.


File: sicstus.info,  Node: cpg-ref-SP_raise_exception,  Next: cpg-ref-SP_read_from_string,  Prev: cpg-ref-SP_query_cut_fail,  Up: cpg-bif

12.3.86 'SP_raise_exception()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void
     SP_raise_exception(SP_term_ref term);

   Raises an exception in the scope of Prolog calling C.

Arguments
---------

TERM
     The SP_term_ref whose value will be the exception term.

Description
-----------

The exception will be stored as pending.  This function is normally used
in the context of a call from Prolog to C, and will cause the exception
to be propagated to Prolog on return from the call.  The effect is as if
'raise_exception/1' was called with the term as argument.

   *Please note*: this should only be called right before returning to
Prolog.

See Also
--------

*note Exception Handling in C::.


File: sicstus.info,  Node: cpg-ref-SP_read_from_string,  Next: cpg-ref-SP_realloc,  Prev: cpg-ref-SP_raise_exception,  Up: cpg-bif

12.3.87 'SP_read_from_string()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_read_from_string(SP_term_ref t,
                         const char *string,
                         SP_term_ref values[])

   Assigns to 'tt' the result of reading a term from the its textual
representation 'string'.  Variables that occur in the term are bound to
the corresponding term in 'val'.

Arguments
---------

TERM
     The SP_term_ref to assign.

STRING
     The string to read from.

VALUES
     The SP_term_refs to bind variables to.  The vector is terminated by
     '0' (zero).  'values' may be 'NULL', which is treated as an empty
     vector.

Return Value
------------

Nonzero on success, and 0 otherwise.

Description
-----------

The variables in the term are ordered according to their first
occurrence during a depth first traversal in increasing argument order.
That is, the same order as used by 'terms:term_variables_bag/2' (*note
lib-terms::).  Variables that do not have a corresponding entry in
'vals' are ignored.  Entries in 'vals' that do not correspond to a
variable in the term are ignored.

   The string should be encoded using the SICStus Prolog internal
encoding.

Examples
--------

This example creates the term 'foo(X,42,42,X)' (without error checking):

     SP_term_ref x = SP_new_term_ref();
     SP_term_ref y = SP_new_term_ref();
     SP_term_ref term = SP_new_term_ref();
     SP_term_ref vals[] = {x,y,x,0}; // zero-terminated

     SP_put_variable(x);
     SP_put_integer(y,42);

     SP_read_from_string(term, "foo(A,B,B,C).", vals);
     #if 0
        A corresponds to vals[0] (x),
        B to vals[1] (y),
        C to vals[2] (x).
        A and C therefore both are bound to
        the variable referred to by x.
        B is bound to the term referred to by y (42).
        So term refers to a term foo(X,42,42,X).
     #endif

   *Note Reading a goal from a string::, for an example of using
'SP_read_from_string()' to call an arbitrary goal.

See Also
--------

*note Creating Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_realloc,  Next: cpg-ref-SP_register_atom,  Prev: cpg-ref-SP_read_from_string,  Up: cpg-bif

12.3.88 'SP_realloc()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_realloc(void *ptr,
                size_t size);

   Changes the size of the block referenced by 'ptr' to 'size' bytes and
returns a pointer to the (possibly moved) block.  The contents will be
unchanged up to the lesser of the new and old sizes.  The block
referenced by 'ptr' must have been obtained by a call to 'SP_malloc()'
or 'SP_realloc()', and must not have been released by a call to
'SP_free()' or 'SP_realloc()'.

Arguments
---------

PTR
     The current block.

SIZE
     Requested number of bytes of the new block.

Return Value
------------

'NULL' on failure, the pointer otherwise.

See Also
--------

*Note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_register_atom,  Next: cpg-ref-SP_restore,  Prev: cpg-ref-SP_realloc,  Up: cpg-bif

12.3.89 'SP_register_atom()'
----------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_register_atom(SP_atom atom);

   Registers the atom 'atom' with the Prolog memory manager by
incrementing its reference counter.

Arguments
---------

ATOM
     The atom to register

Return Value
------------

1 if 'atom' is valid, and 0 otherwise.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_restore,  Next: cpg-ref-SP_set_argv,  Prev: cpg-ref-SP_register_atom,  Up: cpg-bif

12.3.90 'SP_restore()'
----------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_restore(char const *filename);


   Calls 'restore/1'.

Arguments
---------

FILENAME
     The file name, which is treated as a Prolog atom.

Return Value
------------

See 'SP_query_cut_fail()'.

See Also
--------

*note Loading Prolog Code::.


File: sicstus.info,  Node: cpg-ref-SP_set_argv,  Next: cpg-ref-SP_set_current_dir,  Prev: cpg-ref-SP_restore,  Up: cpg-bif

12.3.91 'SP_set_argv()'
-----------------------

Synopsis
--------

  since release 4.0.3

     #include <sicstus/sicstus.h>

     int
     SP_set_argv(int argc,
     	    char **argv,
     	    spio_t_bits options);

   Initializes the 'argv' prolog flag.

Arguments
---------

ARGC
     The number of elements of the 'argv' vector.

ARGV
     A vector of strings that can be accessed by 'prolog_flag(argv,X)'.
     This argument is copied by 'SP_set_argv()' so it can be discarded
     by the caller.  May be passed as 'NULL' if 'argc' is zero.

     The encoding used when converting the entries to atoms is
     determined by the 'options' argument.

OPTIONS

     If 'options' is zero then each entry in 'argv' is assumed to be an
     encoded string, i.e. encoded using 'UTF-8'.  This is the same as
     passing 'argc' and 'argv' to 'SP_initialize()' except that
     'SP_initialize()' will not report failure even if the 'argv'
     entries are not suitable as atom names.  Note that UTF-8 may not be
     the encoding used by the operating system when invoking 'main()'.

     If 'options' is 'SP_SET_ARGV_OPTION_SYSTEM_ENCODING' then each
     entry in 'argv' is assumed to be encoded using some system
     encoding.  This is only useful on Unix-like systems since it is
     preferable, and trivial, to obtain and pass a UTF-8 'argv' vector
     on Windows.

     The system encoding used by 'SP_set_argv()' will be the first
     character encoding specified by the following environment
     variables:

     'SP_CTYPE'
     'LC_ALL (only on Unix)'
     'LC_CTYPE (only on Unix)'
     'LANG (only on Unix)'
     if none of these are set then the operating system will be queried
     in some platform specific way.

     *Please note*: For best results on Unix-like platforms you should
     use a locale based on UTF-8.

Return Value
------------

Zero if the argument entries cannot be converted to atoms, and a nonzero
value otherwise.

Description
-----------

See Also
--------

*note Initializing the Prolog Engine::.


File: sicstus.info,  Node: cpg-ref-SP_set_current_dir,  Next: cpg-ref-SP_set_user_stream_hook,  Prev: cpg-ref-SP_set_argv,  Up: cpg-bif

12.3.92 'SP_set_current_dir()'
------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_set_current_dir(char const *dir);

   Makes a directory pointed to by 'dir' to become the current working
directory.  'path' should be an encoded string.

Arguments
---------

DIR
     Name of the directory to become current.

Return Value
------------

On success, 'SPIO_S_NOERR' or some other success code is returned.

   On failure, an error code is returned and the working directory is
not changed.

See Also
--------

*note cpg-ref-SP_get_current_dir::.  *note OS File System::.


File: sicstus.info,  Node: cpg-ref-SP_set_user_stream_hook,  Next: cpg-ref-SP_set_user_stream_post_hook,  Prev: cpg-ref-SP_set_current_dir,  Up: cpg-bif

12.3.93 'SP_set_user_stream_hook()'   preinit
---------------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef SP_stream *
     SP_UserStreamHook(void *user_data, int which);

     SP_UserStreamHook *
     SP_set_user_stream_hook(SP_UserStreamHook *hook, void *user_data);

   Sets the user-stream hook to 'hook'.  Must be called _before_
'SP_initialize()'.

Arguments
---------

HOOK
     It is called three times, one for each stream.  The 'which'
     argument indicates which stream it is called for.  The value of
     'which' is one of:

     'SP_STREAMHOOK_STDIN'
          Create stream for standard input.
     'SP_STREAMHOOK_STDOUT'
          Create stream for standard output.
     'SP_STREAMHOOK_STDERR'
          Create stream for standard error.

     The hook should return a standard SICStus text I/O stream, as
     described in *note Defining a New Stream::.

USER_DATA
     An arbitrary pointer that will be passed to the 'hook'.

See Also
--------

*note Hookable Standard Streams::.


File: sicstus.info,  Node: cpg-ref-SP_set_user_stream_post_hook,  Next: cpg-ref-SP_signal,  Prev: cpg-ref-SP_set_user_stream_hook,  Up: cpg-bif

12.3.94 'SP_set_user_stream_post_hook()'   preinit
--------------------------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef SP_stream *
     SP_UserStreamPostHook(void *user_data, int which, SP_stream *str);

     SP_UserStreamPostHook *
     SP_set_user_stream_post_hook(SP_UserStreamPostHook *hook, void *user_data);

   Sets the user-stream post-hook to 'hook'.  Must be called _before_
'SP_initialize()'.

Arguments
---------

HOOK
     The user-stream post-hook is, if defined, called after all the
     streams have been defined, once for each of the three standard
     streams.  It has a slightly different prototype:

          void user_stream_post_hook(void *user_data, int which, SP_stream *str)

     where 'user_data' is the value passed to
     'SP_set_user_stream_post_hook' and where 'str' is a pointer to the
     corresponding 'SP_stream' structure.  There are no requirements as
     to what this hook must do; the default behavior is to do nothing at
     all.

     The post-hook is intended to be used to do things that may require
     that all streams have been created.

USER_DATA
     An arbitrary pointer that will be passed to the 'hook'.

See Also
--------

*note Hookable Standard Streams::.


File: sicstus.info,  Node: cpg-ref-SP_signal,  Next: cpg-ref-SP_strdup,  Prev: cpg-ref-SP_set_user_stream_post_hook,  Up: cpg-bif

12.3.95 'SP_signal()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     typedef void
     SP_SigFun (int sig, void *user_data);

     SP_SigFun
     SP_signal(int sig,
               SP_SigFun fun, void *user_data);

   Installs a function 'fun' as a handler for the signal 'sig'.  It will
be called with 'sig' and 'user_data' as arguments.

Arguments
---------

SIG
     The signal

FUN
     The function

USER_DATA
     An extra, user defined value passed to the function.

Return Value
------------

'SP_SIG_ERR' if an error occurs error.  On success, some value different
from 'SP_SIG_ERR'.

Description
-----------

When the OS delivers a signal 'sig' for which 'SP_signal(sig,func,...)'
has been called, SICStus will _not_ call 'func' immediately.  Instead
the call to 'func' will be delayed until it is safe for Prolog to do so,
in much the same way that functions installed by 'SP_event()' are
handled.

   Since the signal handling function 'func' will not be called
immediately upon delivery of the signal to the process it only makes
sense to use 'SP_signal()' to handle certain asynchronous signals such
as 'SIGINT', 'SIGUSR1', 'SIGUSR2'.  Other asynchronous signals handled
specially by the OS, such as 'SIGCHLD' are not suitable for handling via
'SP_signal()'.  Note that the development system installs a handler for
'SIGINT', and, under Windows, 'SIGBREAK', to catch keyboard interrupts.
As of release 4.4, 'library(timeout)' no longer uses any signals.

   When 'func' is called it may only call other (non SICStus) C code and
'SP_event()'.  Note that 'func' will be called in the main thread.

   If 'fun' is one of the special constants 'SP_SIG_IGN' or
'SP_SIG_DFL', then one of two things happens:

  1. If a signal handler for 'sig' has already been installed with
     'SP_signal()', then the SICStus OS-level signal handler is removed
     and replaced with, respectively, 'SIG_IGN' or 'SIG_DFL'.
  2. If a signal handler has not been installed with 'SP_signal()', then
     'SP_signal()' does nothing and returns 'SP_SIG_ERR'.

   A signal handler installed by a foreign resource should be
uninstalled in the deinit function for the foreign resource.  This is to
prevent the handler in the foreign resource from being called after the
code of the foreign resource has been unloaded (e.g. by
'unload_foreign_resource/1').

   Note that 'SP_signal()' is not suitable for installing signal
handlers for synchronous signals like 'SIGSEGV'.

See Also
--------

'SP_event()', *note Signal Handling::.


File: sicstus.info,  Node: cpg-ref-SP_strdup,  Next: cpg-ref-SP_string_from_atom,  Prev: cpg-ref-SP_signal,  Up: cpg-bif

12.3.96 'SP_strdup()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     void *
     SP_strdup(const char *str);

   Allocates a string, which is a duplicates of the given string.  The
memory for the new string is managed by Prolog.

Arguments
---------

STR
     The given string.

Return Value
------------

The pointer, if allocation was successful, otherwise 'NULL'.

See Also
--------

*note OS Memory Management::.


File: sicstus.info,  Node: cpg-ref-SP_string_from_atom,  Next: cpg-ref-SP_term_type,  Prev: cpg-ref-SP_strdup,  Up: cpg-bif

12.3.97 'SP_string_from_atom()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     char const *
     SP_string_from_atom(SP_atom atom);

   Obtains the encoded string holding the characters of a Prolog atom.
This string must _not_ be modified by the calling function.

Arguments
---------

ATOM
     The atom to inspect.

Return Value
------------

The encoded string if 'atom' is valid, and 0 otherwise.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SP_term_type,  Next: cpg-ref-SP_unget_byte,  Prev: cpg-ref-SP_string_from_atom,  Up: cpg-bif

12.3.98 'SP_term_type()'
------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_term_type(SP_term_ref term);

   Determines the type of the value of 'term'.

Arguments
---------

TERM
     The SP_term_ref to be inspected

Return Value
------------

One of:

'SP_TYPE_VARIABLE'
     a variable

'SP_TYPE_INTEGER'
     an integer

'SP_TYPE_FLOAT'
     a float

'SP_TYPE_ATOM'
     an atom

'SP_TYPE_COMPOUND'
     a compound term

'SP_TYPE_ERROR'
     an error occurred.

See Also
--------

*note Testing Prolog Terms::.


File: sicstus.info,  Node: cpg-ref-SP_unget_byte,  Next: cpg-ref-SP_unget_code,  Prev: cpg-ref-SP_term_type,  Up: cpg-bif

12.3.99 'SP_unget_byte()'
-------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_unget_byte(
       SP_stream *stream,
       int item);

   Push back a byte so it can be read again by subsequent read
operations.

Arguments
---------

STREAM
     The stream.  Must be a binary stream open for input.

ITEM
     The byte to push back.  This must be the byte that was most
     recently read from 'stream', e.g. with 'SP_get_byte()'.  As a
     special case, -1 can be put back if the last read operation
     returned end of file, i.e., 'SPIO_E_END_OF_FILE'.

Return Value
------------

On success, the byte has been pushed back and will be read by the next
read operation.  'SPIO_S_NOERR' or some other success code is returned.

   On failure, an error code is returned.

See Also
--------

*note cpg-ref-SP_get_byte::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_unget_code,  Next: cpg-ref-SP_unify,  Prev: cpg-ref-SP_unget_byte,  Up: cpg-bif

12.3.100 'SP_unget_code()'
--------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     spio_t_error_code
     SP_unget_code(
       SP_stream *stream,
       int item);

   Push back a character so it can be read again by subsequent read
operations.

Arguments
---------

STREAM
     The stream.  Must be a text stream open for input.

ITEM
     The character to push back.  This must be the same character that
     was most recently read from 'stream', e.g. with 'SP_get_code()'.
     As a special case, -1 can be put back if the last read operation
     returned end of file, i.e., 'SPIO_E_END_OF_FILE'.

Return Value
------------

On success, the character has been pushed back and will be read by the
next read operation.  'SPIO_S_NOERR' or some other success code is
returned.

   On failure, returns an error code.

See Also
--------

*note cpg-ref-SP_get_code::.  *note Prolog Streams::.


File: sicstus.info,  Node: cpg-ref-SP_unify,  Next: cpg-ref-SP_unregister_atom,  Prev: cpg-ref-SP_unget_code,  Up: cpg-bif

12.3.101 'SP_unify()'
---------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_unify(SP_term_ref x,
              SP_term_ref y)

   Unifies two terms.

Arguments
---------

X
     The one term to unify

Y
     The other term to unify

Return Value
------------

1 if they unify, and 0 otherwise.

Description
-----------

Bear in mind that the unification may unblock some goals.  such goals
are _not_ run in the scope of 'SP_unify()'; they remain pending until
the next Prolog goal is run.

See Also
--------

*note Unifying and Comparing Terms::.


File: sicstus.info,  Node: cpg-ref-SP_unregister_atom,  Next: cpg-ref-SU_initialize,  Prev: cpg-ref-SP_unify,  Up: cpg-bif

12.3.102 'SP_unregister_atom()'
-------------------------------

Synopsis
--------

     #include <sicstus/sicstus.h>

     int
     SP_unregister_atom(SP_atom atom);

   Unregisters the atom 'atom' with the Prolog memory manager by
incrementing its reference counter.

Arguments
---------

ATOM
     The atom to unregister

Return Value
------------

1 if 'atom' is valid, and 0 otherwise.

See Also
--------

*note Creating and Manipulating SP_term_refs::.


File: sicstus.info,  Node: cpg-ref-SU_initialize,  Next: cpg-ref-user_close,  Prev: cpg-ref-SP_unregister_atom,  Up: cpg-bif

12.3.103 'SU_initialize()'   hook
---------------------------------

Synopsis
--------

     int
     SU_initialize(int argc, char *argv[])

   In applications built with '--userhook', 'SU_initialize()' is called
by the main program before 'SP_initialize()'.  Its purpose is to call
interface functions, which must be called before 'SP_initialize()'.  It
is not meaningful to specify this option if '--main=user' or
'--main=none' is given.

Arguments
---------

ARGC
     Number of command-line arguments.

ARGV
     The command-line arguments, should not be modified.

Return Value
------------

Zero on success, and nonzero otherwise.  If a non-zero value is
returned, the application system exits with the return value as error
code.

See Also
--------

*note The Application Builder::.


File: sicstus.info,  Node: cpg-ref-user_close,  Next: cpg-ref-user_flush_output,  Prev: cpg-ref-SU_initialize,  Up: cpg-bif

12.3.104 'user_close()'
-----------------------

Synopsis
--------

     spio_t_error_code
     user_close(
       void **puser_data,
       spio_t_bits close_options
       );

   This is the prototype for one of the "methods" of user defined
streams.  It is used when SICStus wants to close one or both directions
of a user defined stream.

Arguments
---------

PUSER_DATA
     A pointer to the same value as was passed to 'SP_create_stream()'.
     On successful return, if the stream has been closed and any
     resources freed, then '*puser_data' should be set to 'NULL'.

     If 'user_close' fails, it can still set '*puser_data' to 'NULL' to
     signify that the stream is no longer usable.

CLOSE_OPTIONS
     The following bits can be set:

     'SPIO_DEVICE_CLOSE_OPTION_READ'

          The read direction should be closed.  Only set if the device
          was created as an input or bidirectional device.

     'SPIO_DEVICE_CLOSE_OPTION_WRITE'
          The write direction should be closed.  Only set if the device
          was created as an output or bidirectional device.

     'SPIO_DEVICE_CLOSE_OPTION_FORCE'
          The specified directions should be closed without attempting
          to flush any data.  Among other things this option may be
          passed if a previous call to 'user_close' returned an error.

     Note that a bidirectional stream should only close the directions
     specified by the 'close_options'.  Also note that 'user_close' for
     a bidirectional stream may be called several times and that the
     same direction flag, e.g. 'SPIO_DEVICE_CLOSE_OPTION_READ' may be
     specified more than once, even if that direction has already been
     closed successfully.

     Once a call to 'user_close' has set '*puser_data' to 'NULL', none
     of the device "methods" will be called again.  Note that a
     '*puser_data' may be set to 'NULL' even when a failure code is
     returned.  This is useful if the failure is unrecoverable.

     There is no option to specify non-blocking close, it is expected
     that 'user_close' will finish "quickly".  To make this more likely,
     'user_flush_output' is called before non-forcibly closing an output
     stream.

Return Value
------------

On success, return 'SPIO_S_NOERR' or some other success code and set
'*puser_data' if and only if the user data and any other resources have
been freed.

   On failure, return a SPIO error code.  Error codes with special
meaning for 'user_close':

'SPIO_E_END_OF_FILE'
     Returned if there were buffered data and it is not possible to
     write more data onto the stream, e.g. some underlying device has
     been closed.

Other error codes may also be returned.

Description
-----------

Should close one or all directions depending on the 'close_options'.  If
all directions have been closed, the user data should be deallocated and
'*puser_data' set to 'NULL'.

See Also
--------

*note cpg-ref-SP_create_stream::.  *note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-user_flush_output,  Next: cpg-ref-user_read,  Prev: cpg-ref-user_close,  Up: cpg-bif

12.3.105 'user_flush_output()'
------------------------------

Synopsis
--------

     spio_t_error_code
     user_flush_output(
       void *user_data,
       spio_t_bits flush_options
       );

   This is the prototype for one of the "methods" of user defined
streams.  It is used when SICStus wants to write data to the user
defined stream.

Arguments
---------

USER_DATA
     The same value as was passed to 'SP_create_stream()'.

FLUSH_OPTIONS
     The following bits can be set:

     'SPIO_DEVICE_FLUSH_OPTION_NONBLOCKING'

          If this is set, the function should return "quickly" or with a
          'SPIO_E_WOULD_BLOCK' code.

          If your 'user_flush_output' will never block, you can ignore
          this value.

          You should return 'SPIO_E_NOT_SUPPORTED' if
          'user_flush_output' cannot support non-blocking flush.

Return Value
------------

On success, all buffered data should have been written and
'SPIO_S_NOERR' or some other success code returned.

   On failure, return a SPIO error code.  Error codes with special
meaning for 'user_flush_output':

'SPIO_E_END_OF_FILE'
     Returned if it is not possible to write more data onto the stream,
     e.g. some underlying device has been closed.

'SPIO_E_WOULD_BLOCK'
     'SPIO_DEVICE_FLUSH_OPTION_NONBLOCKING' was set but the operation
     would block.

'SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g.
     'SPIO_DEVICE_FLUSH_OPTION_NONBLOCKING', was passed.

Other error codes may also be returned.

Description
-----------

Should ensure that any buffered data is transmitted to its destination.
Can be passed as 'NULL'.

See Also
--------

*note cpg-ref-SP_create_stream::.  *note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-user_read,  Next: cpg-ref-user_write,  Prev: cpg-ref-user_flush_output,  Up: cpg-bif

12.3.106 'user_read()'
----------------------

Synopsis
--------

     spio_t_error_code
     user_read(
       void *user_data,
       void *buf,
       size_t *pbuf_size,
       spio_t_bits read_options
       );

   This is the prototype for one of the "methods" of user defined
streams.  It is used when SICStus need to obtain more data from the user
defined stream.

Arguments
---------

USER_DATA
     The same value as was passed to 'SP_create_stream()'.

BUF
     Points to a buffer allocated by the caller.

PBUF_SIZE
     Points to the size of the buffer.  The buffer is always large
     enough to hold at least one byte (for binary streams) or one
     character (for text streams).  When this function returns
     successfully, '*pbuf_size' should be set to the number of _bytes_
     stored in the buffer, which should always be positive for
     successful return.

     Note that buffer size is measured in bytes also for text streams.

READ_OPTIONS
     The following bits can be set:

     'SPIO_DEVICE_READ_OPTION_BINARY'
          This is always specified if the device was created as a binary
          device.  The buffer should be filled with up to '*pbuf_size'
          bytes.

     'SPIO_DEVICE_READ_OPTION_TEXT'
          This is always specified if the device was created as a text
          device.  The buffer should be filled with wide characters,
          i.e. 'spio_t_wchar'.  Note that '*buf_size' is size in
          _bytes_, not in characters.

     'SPIO_DEVICE_READ_OPTION_NONBLOCKING'
          If this is set then the function should return "quickly",
          either with some data read or with a 'SPIO_E_WOULD_BLOCK'
          code.

          If your 'user_read' will never block, you can ignore this
          value.

          You should return 'SPIO_E_NOT_SUPPORTED' if 'user_read' cannot
          support non-blocking read.

Return Value
------------

On success, '*pbuf_size' should be assigned and 'SPIO_S_NOERR' or some
other success code returned.

   On failure, return a SPIO error code.  Error codes with special
meaning for 'user_read':

'SPIO_E_END_OF_FILE'
     Return this when there are no more data to read.

'SPIO_E_WOULD_BLOCK'
     'SPIO_DEVICE_READ_OPTION_NONBLOCKING' was set but the operation
     would block.

'SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g.
     'SPIO_DEVICE_READ_OPTION_NONBLOCKING', was passed.

Other error codes may also be returned.

Description
-----------

Should fill 'buf' with up to '*buf_size' bytes of data.  Data should be
either bytes, for a binary device, or 'spio_t_wchar' (32 bit) wide
characters, for a text device.

See Also
--------

*note cpg-ref-SP_create_stream::.  *note Defining a New Stream::.


File: sicstus.info,  Node: cpg-ref-user_write,  Prev: cpg-ref-user_read,  Up: cpg-bif

12.3.107 'user_write()'
-----------------------

Synopsis
--------

     spio_t_error_code
     user_write(
       void *user_data,
       void const *buf,
       size_t *pbuf_size,
       spio_t_bits write_options
       );

   This is the prototype for one of the "methods" of user defined
streams.  It is used when SICStus wants to write data to the user
defined stream.

Arguments
---------

USER_DATA
     The same value as was passed to 'SP_create_stream()'.

BUF
     Points to a buffer allocated by the caller containing the data to
     be written.

PBUF_SIZE
     Points to the size of the buffer, always positive.  When this
     function returns successfully, '*pbuf_size' should be set to the
     number of bytes actually written, which should always be positive
     for successful return.

     Note that buffer size is measured in bytes also for text streams.

WRITE_OPTIONS
     The following bits can be set:

     'SPIO_DEVICE_WRITE_OPTION_BINARY'

          This is always specified if the device was created as a binary
          device.  The buffer contains '*pbuf_size' bytes.

     'SPIO_DEVICE_WRITE_OPTION_TEXT'

          This is always specified if the device was created as a text
          device.  The buffer contains wide characters, i.e.
          'spio_t_wchar'.  Note that '*buf_size' is size in _bytes_, not
          in characters.

     'SPIO_DEVICE_WRITE_OPTION_NONBLOCKING'

          If this is set, the function should return "quickly", either
          with some data written or with a 'SPIO_E_WOULD_BLOCK' code.

          If your 'user_write' will never block, you can ignore this
          value.

          You should return 'SPIO_E_NOT_SUPPORTED' if 'user_write'
          cannot support non-blocking write.

Return Value
------------

On success, '*pbuf_size' should be assigned to with the number of bytes
written and 'SPIO_S_NOERR' or some other success code returned.  On
success, something must have been written, e.g. '*pbuf_size' must be set
to a positive value.

   On failure, return a SPIO error code.  Error codes with special
meaning for 'user_write':

'SPIO_E_END_OF_FILE'
     Returned if it is not possible to write more data onto the stream,
     e.g. some underlying device has been closed.

'SPIO_E_WOULD_BLOCK'
     'SPIO_DEVICE_WRITE_OPTION_NONBLOCKING' was set but the operation
     would block.

'SPIO_E_NOT_SUPPORTED'
     Some unsupported option, e.g.
     'SPIO_DEVICE_WRITE_OPTION_NONBLOCKING', was passed.

Other error codes may also be returned.

Description
-----------

Should write up to '*buf_size' bytes of data from 'buf'.  Data could be
either bytes, for a binary device, or wide characters, for a text
device.

See Also
--------

*note cpg-ref-SP_create_stream::.  *note Defining a New Stream::.


File: sicstus.info,  Node: Command Reference Pages,  Next: References,  Prev: C Reference Pages,  Up: Top

13 Command Reference Pages
**************************

* Menu:

* too-sicstus::                     sicstus -- SICStus Prolog Development System
* too-mzn-sicstus::                 mzn-sicstus -- shortcut for MiniZinc with SICStus back-end
* too-spfz::                        spfz -- FlatZinc Interpreter
* too-spdet::                       spdet -- Determinacy Checker
* too-spld::                        spld -- SICStus Prolog Application Builder
* too-splfr::                       splfr -- SICStus Prolog Foreign Resource Linker
* too-splm::                        splm -- SICStus Prolog License Manager
* too-spxref::                      spxref -- Cross Referencer

The reference pages for the SICStus Prolog command line tools follow.

'sicstus(1)'
     SICStus Prolog Development System
'mzn-sicstus(1)   since release 4.3'
     Shortcut for MiniZinc with SICStus back-end
'spfz(1)   since release 4.3'
     FlatZinc Interpreter
'spdet(1)'
     Determinacy Checker
'spld(1)'
     SICStus Prolog Application Builder
'splfr(1)'
     SICStus Prolog Foreign Resource Linker
'splm(1)'
     SICStus Prolog License Manager
'spxref(1)'
     Cross Referencer


File: sicstus.info,  Node: too-sicstus,  Next: too-mzn-sicstus,  Up: Command Reference Pages

13.1 'sicstus' -- SICStus Prolog Development System
===================================================

Synopsis
--------

     % sicstus [OPTIONS] [-- ARGUMENT...]

Description
-----------

The prompt '| ?-' indicates that the execution is in top-level mode.  In
this mode, Prolog queries may be issued and executed interactively.  To
exit from the top level and return to the shell, either type '^D' at the
top level, or call the built-in predicate 'halt/0', or use the 'e'
(exit) command following a '^C' interruption.

   Under Windows, 'sicstus.exe' is a console-based program that can run
in a command prompt window, whereas 'spwin.exe' runs in its own window
and directs the Prolog standard streams to that window.  'spwin.exe' is
a "windowed" executable.

Options
-------

'-f'
     Fast start.  Do Not read any initialization file on startup.  If
     the option is omitted and the initialization file exists, then
     SICStus Prolog will consult it on startup after running any
     initializations and printing the version banners.  The
     initialization file is '.sicstusrc' or 'sicstus.ini' in the users
     home directory, i.e. '~/.sicstusrc' or '~/sicstus.ini'.  *Note
     ref-fdi-syn:: for an explanation of how a file specification
     starting with '~/' is interpreted.

'-i'
     Forced interactive.  Prompt for user input, even if the standard
     input stream does not appear to be a terminal.

'-m'
     Use 'malloc()' et al. for memory allocations.

'--noinfo'
     Start with the 'informational' Prolog flag set to 'off' initially,
     suppressing informational messages.  The flag is set before any
     PROLOG-FILE or initialization file is loaded or any SAVED STATE is
     restored.

'--nologo'
     Start without the initial version message.

'-l PROLOG-FILE'
     Ensure that the file PROLOG-FILE is loaded on startup.  This is
     done before any initialization file is loaded.  The '-l' option can
     be specified more than once, and all files will be loaded in the
     order specified.

'-r SAVED STATE'
     Restore the saved state SAVED STATE on startup.  This is done
     before any PROLOG-FILE or initialization file is loaded.  Only one
     '-r' option is allowed.

'--goal GOAL'
     Read a term from the text GOAL and pass the resulting term to
     'call/1' after all files have been loaded.  As usual GOAL should be
     terminated by a full stop ('.').  Only one '--goal' option is
     allowed.

'-DVAR=VALUE'
     Sets the system property VAR to value VALUE.  Most system
     properties take their default value from the environment but often
     it is convenient to pass a system property directly instead of
     setting the corresponding environment variable.  *Note System
     Properties and Environment Variables:: for details.

'--locale NAME'
     Sets the process locale to the given locale name.  The process
     locale primarily affects the character encoding used for the
     standard streams.

     The default, also available by specifying 'default' as the NAME, is
     to inherit the locale from the environment.

     This option is not supported on Windows.

'--no-locale'
     Do not inherit the process locale from the environment.

     This is, in effect, the default on Windows.

'-Xrs'
     Reduce use of OS-signals.

     On UNIX-like platforms, several OS signals are handled specially in
     a development system.  The option '-Xrs', prevents this and keeps
     the OS default behavior.

     On both UNIX-like platforms and Windows, the development system
     will install handlers for the signal 'SIGINT' (corresponding to a
     'C-c' keyboard interrupt).  On Windows, a signal handler will also
     be added for 'SIGBREAK' (signalled when the console window is
     closed).  The handling of 'SIGINT' and 'SIGBREAK' is not affected
     by '-Xrs'.

'--help'
     Display a help message and exit.

'-- ARGUMENT...   since release 4.0.3'
'-a ARGUMENT...'
     where the arguments can be retrieved from Prolog by
     'prolog_flag(argv, ARGS)', which will unify ARGS with ARGUMENT...
     represented as a list of atoms.

Files
-----

'FILE.pl'
'FILE.pro'
     Prolog source file

'FILE.po'
     Prolog object file

'FILE.sav'
     Prolog saved state file

'.sicstusrc'
'sicstus.ini'
     SICStus Prolog initialization file, looked up in the home directory

See Also
--------

*note Start::, *note System Properties and Environment Variables::.


File: sicstus.info,  Node: too-mzn-sicstus,  Next: too-spfz,  Prev: too-sicstus,  Up: Command Reference Pages

13.2 'mzn-sicstus' -- Shortcut for MiniZinc with SICStus back-end
=================================================================

Synopsis
--------

     % mzn-sicstus [OPTIONS] MZNFILE

Description
-----------

This tool is a shortcut for invoking 'minizinc(1)' with SICStus as the
FlatZinc interpreter and with the appropriate global constraint
definitions.

Options
-------

See 'minizinc(1)'.

See Also
--------

*note lib-zinc::.


File: sicstus.info,  Node: too-spfz,  Next: too-spdet,  Prev: too-mzn-sicstus,  Up: Command Reference Pages

13.3 'spfz' -- FlatZinc Interpreter
===================================

Synopsis
--------

     % spfz [-help | --help | -?] [--version] [-a] [-f] [-n N] [-o OFILE] [-p P] [-r R] [-s] [-t T] [-time T] [-search S] [-s] FZNFILE

Description
-----------

This tool interprets the FlatZinc ('.fzn') file FZNFILE with options
taken from the command line.

Options
-------

'-help, --help, -?'
     print help message
'--version'
     print version
'-a'
     return all solutions (equal to '-n 0')
'-f'
     solver is free to ignore search strategy (does nothing)
'-n N'
     number of solutions (0 = all) (default: 1)
'-o OFILE'
     file to send output to (default: standard output stream)
'-p P'
     number of cores available (does nothing)
'-r R'
     random seed
'-s'
     emit statistics
'-t, -time T'
     time (in ms) cutoff (default: no cutoff)
'-search S'
     optimization method is S, one of 'bab' (the default) and 'restart'

See Also
--------

*note lib-zinc::.


File: sicstus.info,  Node: too-spdet,  Next: too-spld,  Prev: too-spfz,  Up: Command Reference Pages

13.4 'spdet' -- Determinacy Checker
===================================

Synopsis
--------

     % spdet [-r] [-d] [-D] [-i IFILE] FSPEC...

Description
-----------

The determinacy checker can help you spot unwanted nondeterminacy in
your programs.  This tool examines your program source code and points
out places where nondeterminacy may arise.

Options
-------

'-r'
     Process files recursively, fully checking the specified files and
     all the files they load.
'-d'
     Print out declarations that should be added.
'-D'
     Print out all needed declarations.
'-i IFILE'
     An initialization file, which is loaded before processing begins.

See Also
--------

*note The Determinacy Checker::.


File: sicstus.info,  Node: too-spld,  Next: too-splfr,  Prev: too-spdet,  Up: Command Reference Pages

13.5 'spld' -- SICStus Prolog Application Builder
=================================================

Synopsis
--------

     % spld [ OPTION | INPUTFILE ] ...

Description
-----------

The application builder, 'spld', is used for creating stand-alone
executables.  *Note The Application Builder:: for an overview.

   'spld' takes the files specified on the command line and combines
them into an executable file, much like the UNIX 'ld' or the Windows
'link' commands.

   Note that no pathnames passed to 'spld' should contain spaces.  Under
Windows, this can be avoided by using the short version of pathnames as
necessary.

Options
-------

The input to 'spld' can be divided into OPTIONS and FILES, which can be
arbitrarily mixed on the command line.  Anything not interpreted as an
option will be interpreted as an input file.  Do not use spaces in any
file or option passed to 'spld'.  Under Windows you can use the short
file name for files with space in their name.  The following options are
available:

'-?'
'--help'
     Prints out a summary of all options.  This may document more
     options than those described in this manual.

'-v'
'--verbose'
     Print detailed information about each step in the
     compilation/linking sequence.  Multiple occurrences increase
     verbosity.

'-vv'
     Same as -v -v.

'--version'
     Prints out the version number of 'spld' and exits successfully.

'-o'
'--output=FILENAME'
     Specify output file name.  The default depends on the linker (e.g.
     'a.out' on UNIX systems).

'-E'
'--extended-rt'
     Create an extended runtime system.  In addition to the normal set
     of built-in runtime system predicates, extended runtime systems
     include the compiler.  Extended runtime systems require the
     extended runtime library, available from SICS as an add-on product.
     Extended runtime systems need access to license information; see
     *note Extended Runtime Systems::.

'-D'
'--development'
     Create a development system (with top level, debugger, compiler,
     etc.).  The default is to create a runtime system.  Implies
     '--main=prolog'.

'--main=TYPE'

     Specify what the executable should do upon startup.  The possible
     values are:

     'prolog'
          Implies '-D'.  The executable will start the Prolog top level.
          This is the default if '-D' is specified and no '.sav', '.pl',
          or '.po' files are specified.

     'user'
          The user supplies his/her own main program by including C-code
          (object file or source), which defines a function
          'user_main()'.  This option is not compatible with '-D'.
          *Note User-defined Main Programs::.

     'restore'
          The executable will restore a saved state created by
          'save_program/[1,2]'.  This is the default if a '.sav' file is
          found among FILES.  It is only meaningful to specify one
          '.sav' file.  If it was created by 'save_program/2', then the
          given startup goal is run.  Then the executable will any
          Prolog code specified on the command line.  Finally, the goal
          'user:runtime_entry(start)' is run.  The executable exits with
          0 upon normal termination and with 1 on failure or exception.
          Not compatible with '-D'.

     'load'
          The executable will load any Prolog code specified on the
          command line, i.e. files with extension '.pl' or '.po'.  This
          is the default if there are '.pl' or '.po' but no '.sav' files
          among FILES.  Finally, the goal 'user:runtime_entry(start)' is
          run.  The executable exits with 0 upon normal termination and
          with 1 on failure or exception.  Not compatible with '-D'.
          Note that this is almost like '--main==restore' except that no
          saved state will be restored before loading the other files.

     'none'
          No main function is generated.  The main function must be
          supplied in one of the user supplied files.  Not compatible
          with '-D'.

'--window'

     _Win32 only._  Create a windowed executable.  A console window will
     be opened and connected to the Prolog standard streams.  If
     '--main=user' is specified, then 'user_main()' should not set the
     user-stream hooks.  C/C++ source code files specified on the
     command line will be compiled with '-DSP_WIN=1' if this option is
     given.

'--moveable'
'--no-moveable'

     Controls whether to hard-code certain paths into the executable in
     order for it to find the SICStus libraries and bootfiles etc.

     Under UNIX, if '--no-moveable' is specified, then paths are
     hard-coded into executables in order for them to find the SICStus
     libraries and bootfiles.  Two paths are normally hard-coded; the
     value of 'SP_PATH' and, where possible, the runtime library search
     path using the '-R' linker option (or equivalent).  If the linker
     does not support the '-R' option (or an equivalent), then a wrapper
     script is generated instead, which sets 'LD_LIBRARY_PATH' (or
     equivalent).

     The '--moveable' option turns off this behavior, so the executable
     is not dependent on SICStus being installed in a specific place.
     On most platforms the executable can figure out where it is located
     and so can locate any files it need, e.g. using 'SP_APP_DIR' and
     'SP_RT_DIR'.  On some UNIX platforms, however, this is not
     possible.  In these cases, '--moveable' is in effect, the
     executable will rely on the system properties and environment
     variables ('SP_PATH' (*note System Properties and Environment
     Variables::) and 'LD_LIBRARY_PATH' etc.)  to find all relevant
     files.

     Under Windows, '--moveable' is always on, since Windows
     applications do not need to hard-code paths in order for them to
     find out where they are installed.  On UNIX platforms, '--moveable'
     is the default (as of release 4.2) but can be turned off with
     '--no-moveable'.  *Note Runtime Systems on Target Machines:: for
     more information on how SICStus locates its libraries and
     bootfiles.

'-S'
'--static'
     Link statically with SICStus runtime and foreign resources.  When
     '--static' is specified, a static version of the SICStus runtime
     will be used and any SICStus foreign resources specified with
     '--resources' will be statically linked with the executable.  In
     addition, '--static' implies '--embed-rt-sav', '--embed-sav-file'
     and '--resources-from-sav'.

     Even with '--static', 'spld' will go with the linker's default,
     which is usually dynamic.  If you are in a situation where you
     would want 'spld' to use a static library instead of a dynamic one,
     then you will have to hack into 'spld''s configuration file
     'spconfig-VERSION' (normally located in '<installdir>/bin').  We
     recommend that you make a copy of the configuration file and
     specify the new configuration file using '--config=<file>'.  A
     typical modification of the configuration file for this purpose may
     look like:
          [...]
          TCLLIB=-Bstatic -L/usr/local/lib -ltk8.0 -ltcl8.0 -Bdynamic
          [...]
     Use the new configuration file by typing
          % spld [...] -S --config=/home/joe/hacked_spldconfig [...]

     The SICStus runtime depends on certain OS support that is only
     available in dynamically linked executables.  For this reason it
     will probably not work to try to tell the linker to build a
     completely static executable, i.e. an executable that links
     statically also with the C library and that cannot load shared
     objects.

'--shared'
     Create a shared library runtime system instead of an ordinary
     executable.  Implies '--main=none'.

     Can be combined with '--static' to create a all-in-one shared
     library runtime system.

'--resources=RESOURCELIST'
     RESOURCELIST is a comma-separated list of resource names,
     describing which resources should be prelinked with the executable.
     Names can be either simple resource names, for example 'tcltk', or
     they can be complete paths to a foreign resource (with or without
     extensions).  Example
          % spld [...] --resources=tcltk,clpfd,/home/joe/foobar.so
     This will cause 'library(tcltk)', 'library(clpfd)', and
     '/home/joe/foobar.so' to be prelinked with the executable.  See
     also the option '--respath' below.

     It is also possible to embed a "data resource", that is, the
     contents of an arbitrary data file that can be accessed at runtime.

     It is possible to embed any kind of data, but, currently, only
     'restore/1' knows about data resources.  For this reason it only
     makes sense to embed '.sav' files.

     The primary reason to embed files within the executable is to
     create an all-in-one executable, that is, an executable file that
     does not depend on any other files and that therefore is easy to
     run on machines without SICStus installed.  *Note All-in-one
     Executables:: for more information.

'--resources-from-sav'
'--no-resources-from-sav'
     When embedding a saved state as a data resource (with '--resources'
     or '--embed-sav-file'), this option extracts information from the
     embedded saved state about the names of the foreign resources that
     were loaded when the saved state was created.  This is the default
     for static executables when no other resource is specified except
     the embedded saved state.  This option is only supported when a
     saved state is embedded as a data resource.  *Note All-in-one
     Executables:: for more information.

     Use '--no-resources-from-sav' to ensure that this feature is _not_
     enabled.

'--respath=PATH'
     Specify additional paths used for searching for resources.  PATH is
     a list of search-paths, colon separated under UNIX, semicolon
     separated under Windows.  'spld' will always search the default
     library directory as a last resort, so if this option is not
     specified, then only the default resources will be found.  See also
     the '--resources' option above.

'--config=CONFIGFILE'
     Specify another configuration file.  This option is not intended
     for normal use.  The file name may not contain spaces.

'--conf VAR=VALUE   since release 4.0.3'
     Override values from the configuration file.  Can occur multiple
     times.  For instance, '--conf CC=/usr/bin/gcc' would override the
     default C compiler.

'--cflag=CFLAG'
     CFLAG is an option to pass to the C-compiler.  This option can
     occur multiple times.

     The current behavior is that if CFLAG contains commas, then each
     comma-separated part is treated as a separate compiler option.
     This may change in the future, so instead you should use multiple
     occurrences of '--cflag'.  To turn off splitting at commas and
     treat CFLAG as a single option even it contains a comma, you can
     pass the option '--conf SPLIT_OPT_CFLAG=0'.  This can be useful
     with certain options to the 'gcc' compiler.

'--cxx   since release 4.7.0'

     This enables improved handling of C++ code.  It is automatically
     enabled if any C++ source code is detected.

     On some platforms the C++ compiler will be used for linking instead
     of the C compiler.  On some platforms you may need to pass extra
     options to ensure the C++ library is available.

     It can be disabled with '--nocxx', e.g.  if the C++ support causes
     some backward compatibility problem.

'--   since release 4.0.3'
'--LD   since release 4.0.3'
'-LD'
     Do not process the rest of the command line, but send it directly
     to the linker step.  Note that linking is often performed by the
     compiler.

'--sicstus=EXECUTABLE'
     'spld' relies on using SICStus during some stages of its execution.
     The default is the development system installed with the
     distribution.  EXECUTABLE can be used to override this, in case the
     user wants to use another development system.

'--interactive'
'-i'
     Only applicable with '--main=load' or '--main=restore'.  Calls
     'SP_force_interactive()' (*note Initializing the Prolog Engine::)
     before initializing SICStus.

'--userhook'
     This option allows you to define your own version of the
     'SU_initialize()' function.  'SU_initialize()' is called by the
     main program before 'SP_initialize()'.  Its purpose is to call
     interface functions that must be called before 'SP_initialize()',
     such as 'SP_set_user_stream_hook()'.  It is not meaningful to
     specify this option if '--main=user' or '--main=none' is given.

'--locale=LOCALE   since release 4.3'
'--no-locale'

     By default, on UNIX platforms, the executable created by 'spld'
     sets the process locale from the environment.

     Setting the process locale from the environment can suppressed by
     passing the '--no-locale' option to 'spld'.  This corresponds to
     the behavior prior to release 4.3.

     An explicit locale that the process should set on initialization,
     can be passed with the '--locale' option to 'spld'.

     The valid locale names depends on the operating system.  Typically
     you can use the 'locale' utility, with the '-a' option, to list all
     valid locale names.

'--with_jdk=DIR'
'--with_tcltk=DIR'
'--with_tcl=DIR'
'--with_tk=DIR'
'--with_bdb=DIR'

     Specify the installation path for third-party software for foreign
     resources, such as 'jasper', that have special dependencies.  This
     is mostly useful under Windows.  Under UNIX, the installation
     script manages this automatically.

'--keep'
     Keep temporary files and interface code and rename them to
     human-readable names.  Not intended for the casual user, but useful
     if you want to know exactly what code is generated.

'--nocompile'
     Do Not compile, just generate code.  This may be useful in
     Makefiles, for example to generate the header file in a separate
     step.  Implies '--keep'.

'--namebase=NAMEBASE'
     Use NAMEBASE to construct the name of generated files.  This
     defaults to 'spldgen_' or, if '--static' is specified,
     'spldgen_s_'.

'--embed-rt-sav'
'--no-embed-rt-sav'
     '--embed-rt-sav' will embed the SICStus runtime '.sav' file into
     the executable.  This is off by default unless '--static' is
     specified.  It can be forced on (off) by specifying
     '--embed-rt-sav' ('--no-embed-rt-sav').

'--embed-sav-file'
'--no-embed-sav-file'
     '--embed-sav-file' will embed any '.sav' file passed to 'spld' into
     the executable.  This is just a shorthand for avoiding the ugly
     data resource syntax of the '--resources' option.  This is the
     default when '--static' is specified.  It can be forced on (off) by
     specifying '--embed-sav-file' ('--no-embed-sav-file').  A file
     './foo/bar.sav' will be added with the data resource name
     '/bar.sav', i.e. as if '--resources=./foo/bar.sav=/bar.sav' had
     been specified.

'--license-file=LICENSEFILE'

     Specify the path to the license information needed by extended
     runtime systems.  Only relevant with '--extended-rt'.  *Note
     Extended Runtime Systems:: for details.

'--embed-license'
'--no-embed-license'

     Controls whether to embed the license information in the
     executable.  '--no-embed-license' is the default.  Only relevant
     with '--extended-rt'.  *Note Extended Runtime Systems:: for
     details.

'--multi-sp-aware'
     Compile the application with support for using more than one
     SICStus runtime in the same process.  Not compatible with
     '--static' or prelinked foreign resources.  *Note Multiple SICStus
     Runtimes in C:: for details.

   There may be additional, undocumented, options, some of which may be
described with the '--help' option.

Files
-----

Arguments to 'spld' not recognized as options are assumed to be input
files and are handled as follows:

'*.pro'
'*.pl'
'*.po'
     These are interpreted as names of files containing Prolog code and
     will be passed to 'SP_load()' at runtime (if '--main' is 'load' or
     'restore').  *Please note:* If the intention is to make an
     executable that works independently of the working directory at run
     time, then avoid relative file names, for they will be resolved at
     run time, not at 'spld' time.  Use absolute file names instead,
     'SP_APP_DIR', 'SP_LIBRARY_DIR', or embed a '.sav' file as a data
     resource, using '--resource'.

'*.sav'
     These are interpreted as names of files containing saved states and
     will be passed to 'SP_restore()' at runtime if '--main=restore' is
     specified, subject to the above caveat about relative file names.

     It is not meaningful to give more than one '.sav' argument.

'*.so'
'*.sl'
'*.s.o'
'*.o'
'*.obj'
'*.dll'
'*.lib'
'*.dylib'
     These files are assumed to be input files to the linker and will be
     passed on unmodified.

'*.c'
'*.C'
     These files are assumed to be C source code and will be compiled by
     the C-compiler before being passed to the linker.

'*.cc'
'*.cpp'
'*.c++'
     These files are assumed to be C++ source code and will be compiled
     by the C++ compiler before being passed to the linker.

     Prior to release 4.7, these files would be compiled with the C
     compiler.  The '--nocxx' option can be used if the legacy behavior
     is desired.

   If an argument is still not recognized, then it will be passed
unmodified to the linker.

See Also
--------

*Note The Application Builder::.


File: sicstus.info,  Node: too-splfr,  Next: too-splm,  Prev: too-spld,  Up: Command Reference Pages

13.6 'splfr' -- SICStus Prolog Foreign Resource Linker
======================================================

Synopsis
--------

     % splfr [ OPTION | INPUTFILE ] ...

Description
-----------

The foreign resource linker, 'splfr', is used for creating foreign
resources (*note Foreign Resources::).  'splfr' reads terms from a
Prolog file, applying op declarations and extracting any
'foreign_resource/2' fact with first argument matching the resource name
and all 'foreign/[2,3]' facts.  Based on this information, it generates
the necessary glue code, and combines it with any additional C or object
files provided by the user into a linked foreign resource.  The output
file name will be the resource name with a suitable extension.

Options
-------

The input to 'splfr' can be divided into OPTIONs and INPUTFILEs and they
can be arbitrarily mixed on the command line.  Anything not interpreted
as an option will be interpreted as an input file.  Exactly one of the
input files should be a Prolog file.  The following options are
available:

'-?'
'--help'
     Prints out a summary of all options.

'-v'
'--verbose'
     Print detailed information about each step in the
     compilation/linking sequence.  Multiple occurrences increase
     verbosity.

'-vv'
     Same as -v -v.

'--version'
     Prints out the version number of 'spld' and exits successfully.

'--config=CONFIGFILE'
     Specify another configuration file.  This option is not intended
     for normal use.  The file name may not contain spaces.

'--conf VAR=VALUE   since release 4.0.3'
     Override values from the configuration file.  Can occur multiple
     times.  For instance, '--conf CC=/usr/bin/gcc' would override the
     default C compiler.

'--cflag=CFLAG'

     CFLAG is an option to pass to the C-compiler (or C++ compiler).
     This option can occur multiple times.

     The current behavior is that if CFLAG contains commas, then each
     comma-separated part is treated as a separate compiler option.
     This may change in the future, so instead you should use multiple
     occurrences of '--cflag'.  To turn off splitting at commas and
     treat CFLAG as a single option even it contains a comma, you can
     pass the option '--conf SPLIT_OPT_CFLAG=0'.  This can be useful
     with certain options to the 'gcc' compiler.

'--cxxflag=CXXFLAG   since release 4.7.0'

     CXXFLAG is an option to pass to the C++ compiler (in addition to
     any C flags specified with '--cflag').  This option can occur
     multiple times.

'--cxx   since release 4.7.0'

     This enables improved handling of C++ code.  It is automatically
     enabled if any C++ source code is detected.

     On some platforms the C++ compiler will be used for linking instead
     of the C compiler.  On some platforms you may need to pass extra
     options to ensure the C++ library is available.

     It can be disabled with '--nocxx', e.g.  if the C++ support causes
     some backward compatibility problem.

'--   since release 4.0.3'
'--LD   since release 4.0.3'
'-LD'
     Do not process the rest of the command line, but send it directly
     to the compiler/linker.  Note that linking is often performed by
     the compiler.

'--sicstus=EXECUTABLE'
     'splfr' relies on using SICStus during some stages of its
     execution.  The default is the development system installed with
     the distribution.  EXECUTABLE can be used to override this, in case
     the user wants to use another development system.

'--keep'
     Keep temporary files and interface code and rename them to
     human-readable names.  Not intended for the casual user, but useful
     if you want to know exactly what code is generated.

'--resource=RESOURCENAME'
     Specify the resource's name.  This defaults to the basename of the
     Prolog source file found on the command line.

'-o, --output=OUTPUTFILENAME'
     Specify output file name.  This defaults to the name of the
     resource, suffixed with the platform's standard shared object
     suffix (i.e. '.so' on most UNIX dialects, '.dll' under Windows).
     The use of this option is discouraged, except to change the output
     directory.

'-S'
'--static'
     Create a statically linked foreign resource instead of a
     dynamically linked one, which is the default.  A statically linked
     foreign resource is a single object file, which can be prelinked
     into a Prolog system.  See also the 'spld' tool, *note The
     Application Builder::.

'--no-rpath'
     Under UNIX, the default is to embed into the shared object all
     linker library directories for use by the dynamic linker.  For most
     UNIX linkers this corresponds to adding a '-RPATH' for each
     '-LPATH'.  The '--no-rpath' option inhibits this.

'--nocompile'
     Do Not compile, just generate code.  This may be useful in
     Makefiles, for example to generate the header file in a separate
     step.  Implies '--keep'.

'--namebase=NAMEBASE'
     NAMEBASE will be used as part of the name of generated files.  The
     default name base is the resource name (e.g. as specified with
     '--resource').  If '--static' is specified, then the default
     NAMEBASE is the resource name followed by '_s'.

'--header=HEADERNAME'
     Specify the name of the generated header file.  The default is
     'NAMEBASE_glue.h'.  All C files that define foreign functions or
     that call SICStus API functions should include this file.  Among
     other things the generated header file includes prototypes
     corresponding to the 'foreign/[2,3]' declarations in the Prolog
     code.

'--multi-sp-aware'

     Create a (dynamic) foreign resource that can be loaded by several
     SICStus runtimes in the same process, at the same time.  *Note
     Foreign Resources and Multiple SICStus Runtimes:: for details.

'--moveable'
     Do Not embed paths into the foreign resource.

     On platforms that support it, i.e. some versions of UNIX, the
     default behavior of 'splfr' is to add each directory DIR specified
     with '-LDIR' to the search path used by the runtime loader (using
     the SysV 'ld -R' option or similar).  The option '--moveable' turns
     off this behavior.  For additional details, see the corresponding
     option to 'spld' (*note The Application Builder::).

'--structs'
     The Prolog source file uses 'library(structs)'.  This option makes
     'splfr' understand foreign type specifications and translate them
     into C declarations in the generated header file.  See *Note
     lib-structs::.

'--objects   since release 4.3'
     The Prolog source file uses 'library(objects)'.  This option makes
     'splfr' understand that library's syntax extensions.  See *Note
     lib-objects::.

there may be additional, undocumented, options, some of which may be
described with the '--help' option.

Files
-----

Arguments to 'spld' not recognized as options are assumed to be input
files and are handled as follows:

'*.pro'
'*.pl'
     The Prolog file containing the relevant declarations.  Exactly one
     such argument should be given.

'*.so'
'*.sl'
'*.s.o'
'*.o'
'*.obj'
'*.dll'
'*.lib'
'*.dylib'
     These files are assumed to be input files to the linker and will be
     passed on unmodified.

'*.c'
'*.C'

     These files are assumed to be C source code and will be compiled by
     the C-compiler before being passed to the linker.

'*.cc'
'*.cpp'
'*.c++'

     These files are assumed to be C++ source code and will be compiled
     by the C++-compiler before being passed to the linker.

     Prior to release 4.7, these files would be compiled with the C
     compiler.  The '--nocxx' option can be used if the legacy behavior
     is desired.

See Also
--------

*note The Foreign Resource Linker::.


File: sicstus.info,  Node: too-splm,  Next: too-spxref,  Prev: too-splfr,  Up: Command Reference Pages

13.7 'splm' -- SICStus Prolog License Manager
=============================================

Synopsis
--------

     % splm -i SITE
     % splm -a LICENSEDPRODUCT EXPIRATIONDATE CODE

Description
-----------

SICStus Prolog requires a license code to run.  You should have received
from SICS your site name, the expiration date and the code.  This
information is normally entered during installation, but it can also be
entered later on by means of this command-line tool.

   Under Windows, 'splm' must be run by a user with Administrative
rights.  The windowed version of SICStus ('spwin.exe') has a menu item
for license entry, making 'splm' unnecessary under Windows.

   *Please note:* when using 'spwin.exe' for changing the license
information, it too must be run with Administrative rights.

Files
-----

'library/license.pl'

See Also
--------

*note Start::.


File: sicstus.info,  Node: too-spxref,  Prev: too-splm,  Up: Command Reference Pages

13.8 'spxref' -- Cross Referencer
=================================

Synopsis
--------

     % spxref [-R] [-v] [-c] [-i IFILE] [-w WFILE] [-x XFILE] [-u UFILE] FSPEC ...

Description
-----------

The main purpose is to find undefined predicates and unreachable code.
To this end, it begins by looking for initializations, hooks and
'public' directives to start tracing the reachable code from.  If an
entire application is being checked, then it also traces from
'user:runtime_entry/1'.  If individual module files are being checked,
then it also traces from their export lists.

Options
-------

FILE arguments should be given as atoms or as '-', denoting the standard
output stream.

'-R'
     Check an application, i.e. follow 'user:runtime_entry/1', as
     opposed to module declarations.
'-c'
     Generate standard compiler style error messages.
'-v'
     Verbose output.  This echoes the names of the files being read.
'-i IFILE'
     An initialization file, which is loaded before processing begins.
'-w WFILE'
     Warning file.  Warnings are written to the standard error stream by
     default.
'-x XFILE'
     Generate a cross-reference file.  This is not generated by default.
'-m MFILE'
     Generate a file indicating which predicates are imported and which
     are exported for each file.  This is not generated by default.
'-u UFILE'
     Generate a file listing all the undefined predicates.  This is not
     generated by default.

See Also
--------

*note The Cross-Referencer::.


File: sicstus.info,  Node: References,  Next: Predicate Index,  Prev: Command Reference Pages,  Up: Top

References
**********

'[Aggoun & Beldiceanu 90]'
     A. Aggoun and N. Beldiceanu, 'Time Stamps Techniques for the
     Trailed Data in Constraint Logic Programming Systems', Actes du
     se'minaires Programmation en Logique, Tre'gastel, France, May 1990.

'[Aggoun & Beldiceanu 93]'
     A. Aggoun and N. Beldiceanu, 'Extending CHIP in order to Solve
     Complex Scheduling and Placement Problems', Mathl. Comput.
     Modelling, vol. 17, no. 7, pp. 57-73, Pergamon Press Ltd., 1993.

'[Beldiceanu, Carlsson, Flener & Pearson 10]'
     N. Beldiceanu, M. Carlsson, P. Flener, J. Pearson, 'On Matrices,
     Automata, and Double Counting', Constraints 18(1): 108-140, 2013.

'[Beldiceanu, Carlsson & Petit 04]'
     N. Beldiceanu, M. Carlsson, T. Petit, 'Deriving Filtering
     Algorithms from Constraint Checkers', CP, LNCS 3258, Springer,
     2004.

'[Beldiceanu, Carlsson & Rampon 05]'
     N. Beldiceanu, M. Carlsson, J.-X. Rampon, 'Global Constraint
     Catalog', SICS Technical Report T2005-08, 2005.

'[Beldiceanu & Contejean 94]'
     N. Beldiceanu and E. Contejean, 'Introducing Global Constraints in
     CHIP', Mathl. Comput. Modelling, vol. 20, no. 12, pp. 97-123,
     Pergamon Press Ltd., 1994.

'[Bryant 86]'
     R.E. Bryant, 'Graph-Based Algorithms for Boolean Function
     Manipulation', IEEE Trans. on Computers, August, 1986.

'[CHIP 03]'
     'CHIP Finite domain constraints Reference Manual', Release 5.5, pp.
     36-38, 2003.

'[Carlsson 90]'
     M. Carlsson, 'Design and Implementation of an OR-Parallel Prolog
     Engine', SICS Dissertation Series 02, 1990.

'[Carlsson & Beldiceanu 02]'
     M. Carlsson, N. Beldiceanu, 'Arc-Consistency for a Chain of
     Lexicographic Ordering Constraints', SICS Technical Report
     T2002-18, 2002.

'[Carlsson, Beldiceanu & Martin 08]'
     M. Carlsson, N. Beldiceanu, J. Martin, 'A Geometric Constraint over
     k-Dimensional Objects and Shapes Subject to Business Rules', SICS
     Technical Report T2008-04, 2008.

'[Carreiro & Gelernter 89a]'
     N. Carreiro and D. Gelernter, 'Linda in Context', CACM, 32(4) 1989.

'[Carreiro & Gelernter 89b]'
     N. Carreiro and D. Gelernter, 'How to Write Parallel Programs: A
     Guide to the Perplexed', ACM Computing Surveys, September 1989.

'[Clocksin & Mellish 81]'
     W.F. Clocksin and C.S. Mellish, 'Programming in Prolog', Springer,
     1981.

'[Colmerauer 90]'
     Colmerauer A.: An Introduction to Prolog III, CACM, 33(7), 69-90,
     1990.

'[Diaz & Codognet 93]'
     D. Diaz and P. Codognet, 'A Minimal Extension of the WAM for
     clp(FD)', ICLP, MIT Press, 1993.

'[Fruehwirth 98]'
     Th. Fruehwirth, 'Theory and Practice of Constraint Handling Rules',
     Special Issue on Constraint Logic Programming (P. Stuckey and K.
     Marriot, Eds.), Journal of Logic Programming, Vol 37(1-3), pp.
     95-138, October 1998.

'[Gorlick & Kesselman 87]'
     M.M. Gorlick and C.F. Kesselman, 'Timing Prolog Programs Without
     Clocks', Symposium on Logic Programming, pp. 426-432, IEEE Computer
     Society, 1987.

'[Hanak et al. 04]'
     D. Hana'k, T. Szeredi, P. Szeredi: 'FDBG, the CLPFD Debugger
     Library of SICStus Prolog'.  International Workshop on Logic
     Programming Environments (WLPE'04), 2004.

'[Heintze et al. 87]'
     N. Heintze, J. Jaffar, S. Michaylov, P. Stuckey, R. Yap, 'The
     CLP(R) Programmers Manual', Monash University, Clayton, Victoria,
     Australia, Department of Computer Science, 1987.

'[Holzbaur 92a]'
     C. Holzbaur, 'A High-Level Approach to the Realization of CLP
     Languages', JICSLP92 Post-Conference Workshop on Constraint Logic
     Programming Systems, Washington D.C., 1992.

'[Holzbaur 94]'
     C. Holzbaur, 'A Specialized, Incremental Solved Form Algorithm for
     Systems of Linear Inequalities', Austrian Research Institute for
     Artificial Intelligence, Vienna, TR-94-07, 1994.

'[Jaffar & Michaylov 87]'
     J. Jaffar, S. Michaylov, 'Methodology and Implementation of a CLP
     System', ICLP, MIT Press, Cambridge, MA, 1987.

'[Kowalski 74]'
     R.A. Kowalski, 'Logic for Problem Solving', DCL Memo 75, Dept of
     Artificial Intelligence, University of Edinburgh, March, 1974.

'[Kowalski 79]'
     R.A. Kowalski, 'Artificial Intelligence: Logic for Problem
     Solving'.  North Holland, 1979.

'[Letort, Beldiceanu & Carlsson 14]'
     A. Letort, N. Beldiceanu, M. Carlsson, 'Synchronized sweep
     algorithms for scalable scheduling constraints', Constraints, DOI
     10.1007/s10601-014-9172-8, 2014.

'[Lopez-Ortiz 03]'
     A Lopez-Ortiz, CG Quimper, J Tromp, P van Beek, 'A fast and simple
     algorithm for bounds consistency of the alldifferent constraint',
     IJCAI 2003.

'[Mehlhorn 00]'
     K. Mehlhorn and Sven Thiel, 'Faster algorithms for
     bound-consistency of the sortedness and the alldifferent
     constraint', CP, LNCS 1894, Springer, 2000.

'[O'Keefe 90]'
     R.A. O'Keefe, 'The Craft of Prolog', MIT Press, 1990.

'[Ousterhout 94]'
     John K. Ousterhout, 'Tcl and the Tk Toolkit'.  Addison-Wesley,
     1994.

'[Regin 94]'
     J.-C. Regin, 'A filtering algorithm for constraints of difference
     in CSPs', AAAI, pp. 362-367, 1994

'[Regin 96]'
     J.-C. Regin, 'Generalized Arc Consistency for Global Cardinality
     Constraint', AAAI, 1996.

'[Regin 99]'
     J.-C. Regin, 'Arc Consistency for Global Cardinality with Costs',
     CP, LNCS 1713, pp. 390-404, 1999.

'[Schrijvers & Demoen 04]'
     T. Schrijvers and B. Demoen, 'The K.U.Leuven CHR System:
     Implementation and Application', First Workshop on Constraint
     Handling Rules: Selected Contributions (T. Fruehwirth and M.
     Meister, eds.), pp. 1-5, 2004.

'[Sellmann 02]'
     M. Sellmann, 'An Arc Consistency Algorithm for the Minimum Weight
     All Different Constraint', CP, LNCS 2470, Springer, 2002.

'[Razakarison, Carlsson, Beldiceanu & Simonis 13]'
     N. Razakarison, M. Carlsson, N. Beldiceanu and H. Simonis, 'GAC for
     a linear inequality and an atleast constraint with an application
     to learning simple polynomials', Sixth Annual Symposium on
     Combinatorial Search, 2013.

'[Robinson 65]'
     J.A. Robinson, 'A Machine-Oriented Logic Based on the Resolution
     Principle', JACM 12:23-44, January 1965.

'[Roussel 75]'
     P. Roussel, 'Prolog : Manuel de Reference et d'Utilisation', Groupe
     d'Intelligence Artificielle, Marseille-Luminy, 1975.

'[Schimpf 2002]'
     J. Schimpf, 'Logical Loops'.  ICLP, pp. 224-238, MIT Press, 2002.

'[Sterling & Shapiro 86]'
     L. Sterling and E. Shapiro, 'The Art of Prolog'.  The MIT Press,
     Cambridge MA, 1986.

'[Van Hentenryck 89]'
     P. Van Hentenryck, 'Constraint Satisfaction in Logic Programming',
     Logic Programming Series, The MIT Press, 1989.

'[Van Hentenryck et al. 95]'
     P. Van Hentenryck, V. Saraswat and Y. Deville, 'Design,
     implementation and evaluation of the constraint language cc(FD)'.
     In A. Podelski, ed., Constraints: Basics and Trends, LNCS 910.
     Springer, 1995.

'[Warren 83]'
     D.H.D. Warren, 'An Abstract Prolog Instruction Set', Technical Note
     309, SRI International, 1983.


File: sicstus.info,  Node: Predicate Index,  Next: Keystroke Index,  Prev: References,  Up: Top

Predicate Index
***************

 [index ]
* Menu:

* !/0 (built-in, ref page):              mpg-ref-cut.         (line   6)
* !/0, cut:                              ref-sem-ctr-cut.     (line   6)
* #/\ /2 (clpfd):                        Propositional Constraints.
                                                              (line  30)
* #< /2 (clpfd):                         Arithmetic Constraints.
                                                              (line   8)
* #<= /2 (clpfd):                        Propositional Constraints.
                                                              (line  43)
* #<=> /2 (clpfd):                       Reified Constraints. (line  14)
* #<=> /2 (clpfd) <1>:                   Propositional Constraints.
                                                              (line  47)
* #= /2 (clpfd):                         Arithmetic Constraints.
                                                              (line   8)
* #=< /2 (clpfd):                        Arithmetic Constraints.
                                                              (line   8)
* #=> /2 (clpfd):                        Propositional Constraints.
                                                              (line  43)
* #> /2 (clpfd):                         Arithmetic Constraints.
                                                              (line   8)
* #>= /2 (clpfd):                        Arithmetic Constraints.
                                                              (line   8)
* #\ /1 (clpfd):                         Propositional Constraints.
                                                              (line  26)
* #\ /2 (clpfd):                         Propositional Constraints.
                                                              (line  34)
* #\/ /2 (clpfd):                        Propositional Constraints.
                                                              (line  38)
* #\= /2 (clpfd):                        Arithmetic Constraints.
                                                              (line   8)
* 'SU_messages':generate_message/3:      Message Handling Predicates.
                                                              (line  25)
* 'SU_messages':query_abbreviation/3:    Query Handling Predicates.
                                                              (line  34)
* 'SU_messages':query_class/5:           Query Handling Predicates.
                                                              (line  30)
* 'SU_messages':query_input/3:           Query Handling Predicates.
                                                              (line  46)
* 'SU_messages':query_map/4:             Query Handling Predicates.
                                                              (line  58)
* ,/2 (built-in, ref page):              mpg-ref-and.         (line   6)
* ,/2, conjunction:                      ref-sem-ctr.         (line   6)
* -> /2 ;/2, if then else:               ref-sem-ctr-ite.     (line   6)
* -> /2, if then:                        ref-sem-ctr-ite.     (line  29)
* ->/2 (built-in, ref page):             mpg-ref-if_then.     (line   6)
* : /2, module qualifier:                ref-sem-ctr-oth.     (line  16)
* :- /1, directive:                      Directives.          (line   6)
* ;/2 (built-in, ref page):              mpg-ref-or.          (line   6)
* ;/2, disjunction:                      ref-sem-ctr-dis.     (line   6)
* <-/2 (objects):                        obj-exp-send.        (line   6)
* </2 (built-in, ref page):              mpg-ref-less_than.   (line   6)
* <</2 (objects):                        obj-exp-put.         (line   6)
* =../2 (built-in):                      ref-lte-act.         (line  15)
* =../2 (built-in, ref page):            mpg-ref-univ.        (line   6)
* =/2 (built-in):                        ref-lte-met-usu.     (line  10)
* =/2 (built-in, ref page):              mpg-ref-unify.       (line   6)
* =:=/2 (built-in, ref page):            mpg-ref-equal_to.    (line   6)
* =</2 (built-in, ref page):             mpg-ref-not_greater_than.
                                                              (line   6)
* ==/2 (built-in):                       ref-lte-cte-sot.     (line  35)
* ==/2 (built-in, ref page):             mpg-ref-term_equal_to.
                                                              (line   6)
* =\=/2 (built-in, ref page):            mpg-ref-not_equal_to.
                                                              (line   6)
* >/2 (built-in, ref page):              mpg-ref-greater_than.
                                                              (line   6)
* >=/2 (built-in, ref page):             mpg-ref-not_less_than.
                                                              (line   6)
* >>/2 (objects):                        obj-exp-get.         (line   6)
* ?- /1, query:                          Queries.             (line   6)
* ?=/2 (built-in):                       ref-lte-met-usu.     (line  29)
* ?=/2 (built-in, ref page):             mpg-ref-term_unify_decided.
                                                              (line   6)
* @</2 (built-in):                       ref-lte-cte-sot.     (line  35)
* @</2 (built-in, ref page):             mpg-ref-term_less_than.
                                                              (line   6)
* @=</2 (built-in):                      ref-lte-cte-sot.     (line  35)
* @=</2 (built-in, ref page):            mpg-ref-term_not_greater_than.
                                                              (line   6)
* @>/2 (built-in):                       ref-lte-cte-sot.     (line  35)
* @>/2 (built-in, ref page):             mpg-ref-term_greater_than.
                                                              (line   6)
* @>=/2 (built-in):                      ref-lte-cte-sot.     (line  35)
* @>=/2 (built-in, ref page):            mpg-ref-term_not_less_than.
                                                              (line   6)
* \+ /1, not provable:                   ref-sem-ctr-naf.     (line   6)
* \+/1 (built-in, ref page):             mpg-ref-not_provable.
                                                              (line   6)
* \= /2 (built-in):                      ref-lte-met-usu.     (line  24)
* \=/2 (built-in, ref page):             mpg-ref-not_unifiable.
                                                              (line   6)
* \==/2 (built-in):                      ref-lte-cte-sot.     (line  35)
* \==/2 (built-in, ref page):            mpg-ref-term_not_equal_to.
                                                              (line   6)
* ^ /2, existential quantifier:          ref-sem-ctr-oth.     (line   6)
* ^/2 (built-in):                        ref-all-cse-equ.     (line   6)
* ^/2 (built-in, ref page):              mpg-ref-exists.      (line   6)
* {}/1 (clpqr):                          CLPQR Solver Predicates.
                                                              (line  11)
* abolish/[1,2] (built-in):              ref-mdb-rcd.         (line  19)
* abolish/[1,2] (built-in, ref page):    mpg-ref-abolish.     (line   6)
* abort/0 (built-in):                    ref-ere-int.         (line  21)
* abort/0 (built-in, ref page):          mpg-ref-abort.       (line   6)
* absolute_file_name/[2,3] (built-in, ref page): mpg-ref-absolute_file_name.
                                                              (line   6)
* acyclic_term/1 (built-in, ref page):   mpg-ref-acyclic_term.
                                                              (line   6)
* acyclic_term/2 (built-in):             ref-lte-act.         (line  19)
* add_breakpoint/2 (built-in):           Breakpoint Predicates.
                                                              (line  11)
* add_breakpoint/2 (built-in, ref page): mpg-ref-add_breakpoint.
                                                              (line   6)
* add_edges/3 (ugraphs):                 lib-ugraphs.         (line  64)
* add_edges/3 (wgraphs):                 lib-wgraphs.         (line  81)
* add_element/3 (sets):                  lib-sets.            (line  16)
* add_vertices/3 (ugraphs):              lib-ugraphs.         (line  57)
* add_vertices/3 (wgraphs):              lib-wgraphs.         (line  34)
* aggregate/3 (aggregate):               lib-aggregate.       (line 143)
* aggregate/4 (aggregate):               lib-aggregate.       (line 139)
* aggregate_all/3 (aggregate):           lib-aggregate.       (line 151)
* aggregate_all/4 (aggregate):           lib-aggregate.       (line 147)
* all/1 (plunit option):                 PlUnit A Unit Test Box.
                                                              (line 162)
* all_different/[1,2] (clpfd):           Arithmetic-Logical Constraints.
                                                              (line 119)
* all_different_except_0/1 (clpfd):      Arithmetic-Logical Constraints.
                                                              (line 179)
* all_distinct/[1,2] (clpfd):            Arithmetic-Logical Constraints.
                                                              (line 119)
* all_distinct_except_0/1 (clpfd):       Arithmetic-Logical Constraints.
                                                              (line 179)
* all_equal/1 (clpfd):                   Arithmetic-Logical Constraints.
                                                              (line 104)
* all_equal_reif/2 (clpfd):              Arithmetic-Logical Constraints.
                                                              (line 111)
* append/3 (built-in):                   ref-lte-acl.         (line   6)
* append/3 (built-in, ref page):         mpg-ref-append.      (line   6)
* append/[2,5] (lists):                  lib-lists.           (line  19)
* append_length/[3,4] (lists):           lib-lists.           (line 270)
* append_queue/3 (queues):               lib-queues.          (line  74)
* arg/3 (built-in):                      ref-lte-act.         (line  12)
* arg/3 (built-in, ref page):            mpg-ref-arg.         (line   6)
* arithmetic_mean/2 (statistics):        lib-statistics.      (line  39)
* ask_query/4 (built-in):                Query Handling Predicates.
                                                              (line   8)
* ask_query/4 (built-in, ref page):      mpg-ref-ask_query.   (line   6)
* assert/[1,2] (built-in):               ref-mdb-acd.         (line  14)
* assert/[1,2] (built-in, ref page):     mpg-ref-assert.      (line   6)
* asserta/[1,2] (built-in):              ref-mdb-acd.         (line  14)
* asserta/[1,2] (built-in, ref page):    mpg-ref-asserta.     (line   6)
* assertz/[1,2] (built-in):              ref-mdb-acd.         (line  14)
* assertz/[1,2] (built-in, ref page):    mpg-ref-assertz.     (line   6)
* assignment/[2,3] (clpfd):              Arithmetic-Logical Constraints.
                                                              (line 207)
* assoc_to_list/2 (assoc):               lib-assoc.           (line  18)
* atom/1 (built-in, ref page):           mpg-ref-atom.        (line   6)
* atomic/1 (built-in, ref page):         mpg-ref-atomic.      (line   6)
* atomic_type/[1,2,3] (structs):         str-etr.             (line  35)
* atom_chars/2 (built-in):               ref-lte-c2t.         (line   6)
* atom_chars/2 (built-in) <1>:           ref-lte-c2t.         (line  22)
* atom_chars/2 (built-in, ref page):     mpg-ref-atom_chars.  (line   6)
* atom_codes/2 (built-in):               ref-lte-c2t.         (line   6)
* atom_codes/2 (built-in) <1>:           ref-lte-c2t.         (line  11)
* atom_codes/2 (built-in, ref page):     mpg-ref-atom_codes.  (line   6)
* atom_concat/3 (built-in):              ref-lte-atm.         (line  10)
* atom_concat/3 (built-in, ref page):    mpg-ref-atom_concat. (line   6)
* atom_length/2 (built-in):              ref-lte-atm.         (line   6)
* atom_length/2 (built-in, ref page):    mpg-ref-atom_length. (line   6)
* attribute/1 (declaration):             lib-atts.            (line  21)
* attribute_goal/2 (Module):             lib-atts.            (line 122)
* at_end_of_line/[0,1] (built-in):       ref-iou-cin-elf.     (line   6)
* at_end_of_line/[0,1] (built-in, ref page): mpg-ref-at_end_of_line.
                                                              (line   6)
* at_end_of_stream/[0,1] (built-in):     ref-iou-cin-elf.     (line   6)
* at_end_of_stream/[0,1] (built-in, ref page): mpg-ref-at_end_of_stream.
                                                              (line   6)
* automaton/[3,8,9] (clpfd):             Sequence Constraints.
                                                              (line  22)
* avl_change/5 (avl):                    lib-avl.             (line 116)
* avl_delete/4 (avl):                    lib-avl.             (line 157)
* avl_del_max/4 (avl):                   lib-avl.             (line 168)
* avl_del_min/4 (avl):                   lib-avl.             (line 162)
* avl_domain/2 (avl):                    lib-avl.             (line  33)
* avl_fetch/2 (avl):                     lib-avl.             (line  85)
* avl_fetch/3 (avl):                     lib-avl.             (line  90)
* avl_height/2 (avl):                    lib-avl.             (line  57)
* avl_incr/4 (avl):                      lib-avl.             (line 153)
* avl_map/2 (avl):                       lib-avl.             (line 174)
* avl_map/3 (avl):                       lib-avl.             (line 178)
* avl_max/2 (avl):                       lib-avl.             (line  51)
* avl_max/3 (avl):                       lib-avl.             (line  54)
* avl_member/2 (avl):                    lib-avl.             (line  72)
* avl_member/3 (avl):                    lib-avl.             (line  78)
* avl_min/2 (avl):                       lib-avl.             (line  45)
* avl_min/3 (avl):                       lib-avl.             (line  48)
* avl_next/3 (avl):                      lib-avl.             (line  96)
* avl_next/4 (avl):                      lib-avl.             (line 100)
* avl_prev/3 (avl):                      lib-avl.             (line 106)
* avl_prev/4 (avl):                      lib-avl.             (line 110)
* avl_range/2 (avl):                     lib-avl.             (line  38)
* avl_size/2 (avl):                      lib-avl.             (line  61)
* avl_store/4 (avl):                     lib-avl.             (line 147)
* avl_to_list/2 (avl):                   lib-avl.             (line  18)
* bagof/3 (built-in):                    ref-all-cba.         (line  10)
* bagof/3 (built-in, ref page):          mpg-ref-bagof.       (line   6)
* bagof_rd_noblock/3 (linda_client):     lib-linda-client.    (line 101)
* bag_add_element/4 (bags):              lib-bags.            (line 198)
* bag_del_element/4 (bags):              lib-bags.            (line 202)
* bag_intersect/2 (bags):                lib-bags.            (line 194)
* bag_intersection/2 (bags):             lib-bags.            (line 184)
* bag_intersection/2 (bags) <1>:         lib-bags.            (line 188)
* bag_max/2 (bags):                      lib-bags.            (line 129)
* bag_max/3 (bags):                      lib-bags.            (line 144)
* bag_min/2 (bags):                      lib-bags.            (line 135)
* bag_min/2 (bags) <1>:                  lib-bags.            (line 150)
* bag_subtract/3 (bags):                 lib-bags.            (line 206)
* bag_to_list/2 (bags):                  lib-bags.            (line  80)
* bag_to_ord_set/2 (bags):               lib-bags.            (line  85)
* bag_to_ord_set/3 (bags):               lib-bags.            (line  91)
* bag_to_set/2 (bags):                   lib-bags.            (line 101)
* bag_to_set/3 (bags):                   lib-bags.            (line 107)
* bag_union/2 (bags):                    lib-bags.            (line 179)
* bag_union/3 (bags):                    lib-bags.            (line 176)
* bb_delete/2 (built-in):                ref-mdb-bbd.         (line  36)
* bb_delete/2 (built-in, ref page):      mpg-ref-bb_delete.   (line   6)
* bb_get/2 (built-in):                   ref-mdb-bbd.         (line  30)
* bb_get/2 (built-in, ref page):         mpg-ref-bb_get.      (line   6)
* bb_inf/[3,5] (clpqr):                  CLPQR Solver Predicates.
                                                              (line 134)
* bb_inf/[3,5] (clpqr) <1>:              CLPQR Solver Predicates.
                                                              (line 147)
* bb_put/2 (built-in):                   ref-mdb-bbd.         (line  26)
* bb_put/2 (built-in, ref page):         mpg-ref-bb_put.      (line   6)
* bb_update/3 (built-in):                ref-mdb-bbd.         (line  42)
* bb_update/3 (built-in, ref page):      mpg-ref-bb_update.   (line   6)
* begin_tests/[1,2] (plunit declaration): PlUnit A Unit Test Box.
                                                              (line  10)
* between/3 (between):                   lib-between.         (line  11)
* bin_packing/2 (clpfd):                 Placement Constraints.
                                                              (line 131)
* block/1 (built-in, ref page):          mpg-ref-block.       (line   6)
* block/1 (declaration):                 Block Declarations.  (line   6)
* blocked/1 (plunit option):             PlUnit A Unit Test Box.
                                                              (line  36)
* bool_and/2 (clpfd):                    Arithmetic-Logical Constraints.
                                                              (line 353)
* bool_channel/4 (clpfd):                Arithmetic-Logical Constraints.
                                                              (line 373)
* bool_or/2 (clpfd):                     Arithmetic-Logical Constraints.
                                                              (line 360)
* bool_xor/2 (clpfd):                    Arithmetic-Logical Constraints.
                                                              (line 367)
* break/0 (built-in):                    Nested.              (line   6)
* break/0 (built-in) <1>:                ref-lod-rpx.         (line   6)
* break/0 (built-in) <2>:                ref-ere-int.         (line   9)
* break/0 (built-in, ref page):          mpg-ref-break.       (line   6)
* breakpoint_expansion/2 (hook, ref page): mpg-ref-breakpoint_expansion.
                                                              (line   6)
* breakpoint_expansion/2 (user, hook):   Hooks Related to Breakpoints.
                                                              (line   8)
* breakpoint_expansion/2 (user, hook) <1>: Condition Macros.  (line  22)
* byte_count/2 (built-in):               ref-iou-sfh-opn.     (line  80)
* byte_count/2 (built-in) <1>:           ref-iou-sos.         (line  16)
* byte_count/2 (built-in, ref page):     mpg-ref-byte_count.  (line   6)
* call/[1,2,...,255] (built-in, ref page): mpg-ref-call.      (line   6)
* callable/1 (built-in, ref page):       mpg-ref-callable.    (line   6)
* call_cleanup/2 (built-in, ref page):   mpg-ref-call_cleanup.
                                                              (line   6)
* call_residue_vars/2 (built-in, ref page): mpg-ref-call_residue_vars.
                                                              (line   6)
* case/[3,4] (clpfd):                    Extensional Constraints.
                                                              (line  87)
* cast/1 (structs):                      str-cas.             (line   6)
* catch/3 (built-in):                    ref-ere-hex-pgo.     (line   6)
* catch/3 (built-in, ref page):          mpg-ref-catch.       (line   6)
* central_moment/3 (statistics):         lib-statistics.      (line  52)
* character_count/2 (built-in):          ref-iou-sfh-opn.     (line  80)
* character_count/2 (built-in) <1>:      ref-iou-sos.         (line  19)
* character_count/2 (built-in, ref page): mpg-ref-character_count.
                                                              (line   6)
* char_code/2 (built-in):                ref-lte-c2t.         (line   6)
* char_code/2 (built-in) <1>:            ref-lte-c2t.         (line  33)
* char_code/2 (built-in, ref page):      mpg-ref-char_code.   (line   6)
* char_conversion/2 (built-in, ref page): mpg-ref-char_conversion.
                                                              (line   6)
* checkbag/2 (bags):                     lib-bags.            (line  51)
* chr_constraint/1 (CHR declaration):    CHR Constraint Declaration.
                                                              (line   6)
* chr_flag/3 (chr):                      CHR Debugging Predicates.
                                                              (line  32)
* chr_leash/1 (chr):                     CHR Debugging Predicates.
                                                              (line  23)
* chr_notrace/0 (chr):                   CHR Debugging Predicates.
                                                              (line  17)
* chr_option/2 (CHR declaration):        CHR Semantics.       (line  76)
* chr_show_store/1 (chr):                CHR Debugging Predicates.
                                                              (line  51)
* chr_trace/0 (chr):                     CHR Debugging Predicates.
                                                              (line  11)
* chr_type/1 (CHR declaration):          CHR Constraint Declaration.
                                                              (line  68)
* circuit/[1,2] (clpfd):                 Graph Constraints.   (line  15)
* class/1 (objects):                     obj-exp-class.       (line   6)
* class_ancestor/2 (objects):            obj-exp-class_ancestor.
                                                              (line   6)
* class_method/1 (objects):              obj-exp-class_method.
                                                              (line   6)
* class_of/2 (objects):                  obj-exp-class_of.    (line   6)
* class_superclass/2 (objects):          obj-exp-class_superclass.
                                                              (line   6)
* clause/[2,3] (built-in):               ref-mdb-acl.         (line   6)
* clause/[2,3] (built-in, ref page):     mpg-ref-clause.      (line   6)
* cleanup/1 (plunit option):             PlUnit A Unit Test Box.
                                                              (line  97)
* close/1 (built-in):                    ref-iou-sfh-cst.     (line   6)
* close/[1,2] (built-in, ref page):      mpg-ref-close.       (line   6)
* close_all_streams/0 (file_systems):    lib-file_systems.    (line 124)
* close_client/0 (linda_client):         lib-linda-client.    (line  30)
* clpfd:dispatch_global/4:               The Global Constraint Programming Interface.
                                                              (line  23)
* clpfd:full_answer/0:                   Answer Constraints.  (line  20)
* clumped/2 (lists):                     lib-lists.           (line 788)
* clumps/2 (lists):                      lib-lists.           (line 771)
* comclient_clsid_from_progid/2 (comclient): COM Client Predicates.
                                                              (line  29)
* comclient_create_instance/2 (comclient): COM Client Predicates.
                                                              (line  56)
* comclient_equal/2 (comclient):         COM Client Predicates.
                                                              (line  25)
* comclient_exception_code/2 (comclient): COM Client Predicates.
                                                              (line 105)
* comclient_exception_culprit/2 (comclient): COM Client Predicates.
                                                              (line 107)
* comclient_exception_description/2 (comclient): COM Client Predicates.
                                                              (line 109)
* comclient_garbage_collect/0 (comclient): COM Client Predicates.
                                                              (line   8)
* comclient_get_active_object/2 (comclient): COM Client Predicates.
                                                              (line  62)
* comclient_iid_from_name/2 (comclient): COM Client Predicates.
                                                              (line  46)
* comclient_invoke_method_fun/3 (comclient): COM Client Predicates.
                                                              (line  69)
* comclient_invoke_method_proc/2 (comclient): COM Client Predicates.
                                                              (line  73)
* comclient_invoke_put/3 (comclient):    COM Client Predicates.
                                                              (line  76)
* comclient_is_exception/1 (comclient):  COM Client Predicates.
                                                              (line  94)
* comclient_is_object/1 (comclient):     COM Client Predicates.
                                                              (line  14)
* comclient_name_from_iid/2 (comclient): COM Client Predicates.
                                                              (line  52)
* comclient_progid_from_clsid/2 (comclient): COM Client Predicates.
                                                              (line  34)
* comclient_release/1 (comclient):       COM Client Predicates.
                                                              (line  80)
* comclient_valid_object/1 (comclient):  COM Client Predicates.
                                                              (line  21)
* compare/3 (built-in, ref page):        mpg-ref-compare.     (line   6)
* compile/1 (built-in):                  ref-mod-lod.         (line   6)
* compile/1 (built-in, ref page):        mpg-ref-compile.     (line   6)
* complement/2 (ugraphs):                lib-ugraphs.         (line  81)
* compose/3 (ugraphs):                   lib-ugraphs.         (line  86)
* compound/1 (built-in, ref page):       mpg-ref-compound.    (line   6)
* condition/1 (plunit option):           PlUnit A Unit Test Box.
                                                              (line  56)
* cons/3 (lists):                        lib-lists.           (line 352)
* consult/1 (built-in, ref page):        mpg-ref-consult.     (line   6)
* contains_term/2 (terms):               lib-terms.           (line 207)
* contains_var/2 (terms):                lib-terms.           (line 228)
* convlist/3 (lists):                    lib-lists.           (line 565)
* copy_term/[2,3] (built-in):            ref-lte-cpt.         (line   6)
* copy_term/[2,3] (built-in, ref page):  mpg-ref-copy_term.   (line   6)
* correlation/3 (statistics):            lib-statistics.      (line 110)
* correspond/4 (lists):                  lib-lists.           (line  40)
* count/4 (clpfd):                       Arithmetic-Logical Constraints.
                                                              (line  36)
* covariance/3 (statistics):             lib-statistics.      (line 107)
* coverage_data/1 (built-in):            Coverage Analysis.   (line  40)
* coverage_data/1 (built-in, ref page):  mpg-ref-coverage_data.
                                                              (line   6)
* create/2 (objects):                    obj-exp-create.      (line   6)
* create_mutable/2 (built-in):           ref-lte-mut.         (line  35)
* create_mutable/2 (built-in, ref page): mpg-ref-create_mutable.
                                                              (line   6)
* cumlist/[4,5,6] (lists):               lib-lists.           (line 413)
* cumulative/[1,2] (clpfd):              Scheduling Constraints.
                                                              (line  13)
* cumulatives/[2,3] (clpfd):             Scheduling Constraints.
                                                              (line  66)
* current_atom/1 (built-in, ref page):   mpg-ref-current_atom.
                                                              (line   6)
* current_breakpoint/5 (built-in):       Built-in Predicates for Breakpoint Handling.
                                                              (line  71)
* current_breakpoint/5 (built-in) <1>:   Breakpoint Predicates.
                                                              (line  61)
* current_breakpoint/5 (built-in, ref page): mpg-ref-current_breakpoint.
                                                              (line   6)
* current_char_conversion/2 (built-in, ref page): mpg-ref-current_char_conversion.
                                                              (line   6)
* current_class/1 (objects):             obj-exp-current_class.
                                                              (line   6)
* current_directory/[1,2] (file_systems): lib-file_systems.   (line 305)
* current_host/1 (sockets):              lib-sockets.         (line 174)
* current_input/1 (built-in):            ref-iou-sfh-cis.     (line   9)
* current_input/1 (built-in, ref page):  mpg-ref-current_input.
                                                              (line   6)
* current_key/2 (built-in):              ref-mdb-idb.         (line  42)
* current_key/2 (built-in, ref page):    mpg-ref-current_key. (line   6)
* current_module/[1,2] (built-in):       ref-mod-ilm.         (line  15)
* current_module/[1,2] (built-in, ref page): mpg-ref-current_module.
                                                              (line   6)
* current_op/3 (built-in):               ref-syn-ops-ops.     (line  16)
* current_op/3 (built-in, ref page):     mpg-ref-current_op.  (line   6)
* current_output/1 (built-in):           ref-iou-sfh-cos.     (line   8)
* current_output/1 (built-in, ref page): mpg-ref-current_output.
                                                              (line   6)
* current_predicate/2 (built-in):        ref-mod-ilm-def.     (line  11)
* current_predicate/[1,2] (built-in, ref page): mpg-ref-current_predicate.
                                                              (line   6)
* current_prolog_flag/2 (built-in, ref page): mpg-ref-current_prolog_flag.
                                                              (line   6)
* current_stream/3 (built-in):           ref-iou-sfh-bos.     (line   6)
* current_stream/3 (built-in, ref page): mpg-ref-current_stream.
                                                              (line   6)
* cyclic_term/1 (terms):                 lib-terms.           (line 199)
* datime/[1,2] (system):                 lib-system.          (line  17)
* db_close/1 (bdb):                      The Predicates.      (line  66)
* db_close_env/1 (bdb):                  The Predicates.      (line  23)
* db_compress/[2,3] (bdb):               The Predicates.      (line 126)
* db_current/5 (bdb):                    The Predicates.      (line  70)
* db_current_env/2 (bdb):                The Predicates.      (line  27)
* db_current_iterator/3 (bdb):           The Predicates.      (line 171)
* db_enumerate/3 (bdb):                  The Predicates.      (line 107)
* db_erase/[2,3] (bdb):                  The Predicates.      (line  98)
* db_export/[2,3] (bdb):                 The Predicates.      (line 178)
* db_fetch/3 (bdb):                      The Predicates.      (line  81)
* db_findall/3 (bdb):                    The Predicates.      (line 117)
* db_import/[2,3] (bdb):                 The Predicates.      (line 187)
* db_iterator_done/1 (bdb):              The Predicates.      (line 168)
* db_iterator_next/3 (bdb):              The Predicates.      (line 163)
* db_make_iterator/[2,3] (bdb):          The Predicates.      (line 153)
* db_open/[4,5] (bdb):                   The Predicates.      (line  33)
* db_open_env/[2,3] (bdb):               The Predicates.      (line   9)
* db_reference/1 (built-in, ref page):   mpg-ref-db_reference.
                                                              (line   6)
* db_store/3 (bdb):                      The Predicates.      (line  76)
* db_sync/1 (bdb):                       The Predicates.      (line 148)
* debug/0 (built-in):                    Basic Debug.         (line  11)
* debug/0 (built-in, ref page):          mpg-ref-debug.       (line   6)
* debugger_command_hook/2 (hook, ref page): mpg-ref-debugger_command_hook.
                                                              (line   6)
* debugger_command_hook/2 (user, hook):  Hooks Related to Breakpoints.
                                                              (line  73)
* debugger_command_hook/2 (user, hook) <1>: Breakpoint Predicates.
                                                              (line 118)
* debugging/0 (built-in):                Undefined Predicates.
                                                              (line  27)
* debugging/0 (built-in) <1>:            Basic Debug.         (line 103)
* debugging/0 (built-in, ref page):      mpg-ref-debugging.   (line   6)
* debug_message/0 (objects):             obj-exp-debug_message.
                                                              (line   6)
* decreasing_prefix/[3,4] (lists):       lib-lists.           (line 766)
* define_method/3 (objects):             obj-exp-define_method.
                                                              (line   6)
* delete/[3,4] (lists):                  lib-lists.           (line  46)
* delete_directory/[1,2] (file_systems): lib-file_systems.    (line  73)
* delete_file/1 (file_systems):          lib-file_systems.    (line  69)
* del_edges/3 (ugraphs):                 lib-ugraphs.         (line  68)
* del_edges/3 (wgraphs):                 lib-wgraphs.         (line  85)
* del_element/3 (sets):                  lib-sets.            (line  21)
* del_vertices/3 (ugraphs):              lib-ugraphs.         (line  60)
* del_vertices/3 (wgraphs):              lib-wgraphs.         (line  77)
* depth_bound/2 (terms):                 lib-terms.           (line 254)
* descendant_of/2 (objects):             obj-exp-descendant_of.
                                                              (line   6)
* destroy/1 (objects):                   obj-exp-destroy.     (line   6)
* dif/2 (built-in):                      ref-lte-met-usu.     (line  35)
* dif/2 (built-in, ref page):            mpg-ref-dif.         (line   6)
* diffn/[1,2] (clpfd):                   Placement Constraints.
                                                              (line  98)
* directory_exists/1 (file_systems):     lib-file_systems.    (line  90)
* directory_exists/2 (file_systems):     lib-file_systems.    (line  90)
* directory_members_of_directory/[1,2,3] (file_systems): lib-file_systems.
                                                              (line 152)
* directory_member_of_directory/2 (file_systems): lib-file_systems.
                                                              (line 129)
* directory_member_of_directory/3 (file_systems): lib-file_systems.
                                                              (line 136)
* directory_member_of_directory/4 (file_systems): lib-file_systems.
                                                              (line 144)
* directory_must_exist/1 (file_systems): lib-file_systems.    (line 118)
* directory_must_exist/2 (file_systems): lib-file_systems.    (line 118)
* directory_property/[2,3] (file_systems): lib-file_systems.  (line 209)
* direct_message/4 (objects):            obj-exp-direct_message.
                                                              (line   6)
* disable_breakpoints/1 (built-in):      Breakpoint Predicates.
                                                              (line  79)
* disable_breakpoints/1 (built-in, ref page): mpg-ref-disable_breakpoints.
                                                              (line   6)
* discontiguous/1 (built-in, ref page):  mpg-ref-discontiguous.
                                                              (line   6)
* discontiguous/1 (declaration):         Discontiguous Declarations.
                                                              (line   6)
* disjoint/2 (sets):                     lib-sets.            (line  31)
* disjoint1/[1,2] (clpfd):               Placement Constraints.
                                                              (line   9)
* disjoint2/[1,2] (clpfd):               Placement Constraints.
                                                              (line  46)
* disjoint_union/3 (sets):               lib-sets.            (line 148)
* dispatch_global/4 (clpfd):             The Global Constraint Programming Interface.
                                                              (line  23)
* display/1 (built-in):                  ref-iou-tou-dsp.     (line   6)
* display/1 (built-in, ref page):        mpg-ref-display.     (line   6)
* dispose/1 (structs):                   str-cdf.             (line   6)
* do/2 (built-in, ref page):             mpg-ref-do.          (line   6)
* do/2, do loop:                         ref-sem-ctr-dol.     (line   6)
* domain/3 (clpfd):                      Membership Constraints.
                                                              (line   8)
* dump/3 (clpqr):                        CLPQR Solver Predicates.
                                                              (line 187)
* dynamic/1 (built-in, ref page):        mpg-ref-dynamic.     (line   6)
* dynamic/1 (declaration):               Dynamic Declarations.
                                                              (line   6)
* edges/2 (ugraphs):                     lib-ugraphs.         (line  44)
* edges/2 (wgraphs):                     lib-wgraphs.         (line  34)
* element/2 (clpfd):                     Extensional Constraints.
                                                              (line  20)
* element/3 (clpfd):                     Extensional Constraints.
                                                              (line   8)
* elif/1 (conditional directive):        ref-lod-cnd.         (line   6)
* else/0 (conditional directive):        ref-lod-cnd.         (line   6)
* empty_assoc/1 (assoc):                 lib-assoc.           (line  15)
* empty_avl/1 (avl):                     lib-avl.             (line  15)
* empty_bag/1 (bags):                    lib-bags.            (line 112)
* empty_fdset/1 (clpfd):                 FD Set Operations.   (line  20)
* empty_interval/2 (clpfd):              FD Set Operations.   (line  35)
* empty_queue/1 (queues):                lib-queues.          (line  23)
* enable_breakpoints/1 (built-in):       Breakpoint Predicates.
                                                              (line  79)
* enable_breakpoints/1 (built-in, ref page): mpg-ref-enable_breakpoints.
                                                              (line   6)
* endif/0 (conditional directive):       ref-lod-cnd.         (line   6)
* end_class/[0,1] (objects):             obj-exp-end_class.   (line   6)
* end_tests/1 (plunit declaration):      PlUnit A Unit Test Box.
                                                              (line  13)
* ensure_loaded/1 (built-in):            ref-mod-lod.         (line   6)
* ensure_loaded/1 (built-in, ref page):  mpg-ref-ensure_loaded.
                                                              (line   6)
* entailed/1 (clpqr):                    CLPQR Solver Predicates.
                                                              (line  72)
* environ/[2,3] (system):                lib-system.          (line  30)
* erase/1 (built-in):                    ref-mdb-rcd.         (line  19)
* erase/1 (built-in, ref page):          mpg-ref-erase.       (line   6)
* error/1 (plunit option):               PlUnit A Unit Test Box.
                                                              (line 210)
* error/2 (plunit option):               PlUnit A Unit Test Box.
                                                              (line 210)
* error_exception/1 (hook, ref page):    mpg-ref-error_exception.
                                                              (line   6)
* error_exception/1 (user, hook):        ref-ere-hex.         (line  24)
* error_exception/1 (user, hook) <1>:    Exceptions Debug.    (line  16)
* exception/1 (plunit option):           PlUnit A Unit Test Box.
                                                              (line 201)
* exclude/[3,4,5] (lists):               lib-lists.           (line 583)
* execution_state/[1,2] (built-in):      Built-in Predicates for Breakpoint Handling.
                                                              (line  17)
* execution_state/[1,2] (built-in) <1>:  Accessing Past Debugger States.
                                                              (line  21)
* execution_state/[1,2] (built-in) <2>:  Breakpoint Predicates.
                                                              (line  87)
* execution_state/[1,2] (built-in, ref page): mpg-ref-execution_state.
                                                              (line   6)
* expand_term/2 (built-in):              ref-lod-exp.         (line  63)
* expand_term/2 (built-in, ref page):    mpg-ref-expand_term. (line   6)
* fail/0 (built-in, ref page):           mpg-ref-fail.        (line   6)
* fail/0 (plunit option):                PlUnit A Unit Test Box.
                                                              (line 194)
* false/0 (built-in, ref page):          mpg-ref-false.       (line   6)
* fdbg_annotate/[3,4] (fdbg):            FDBG Writing Visualizers.
                                                              (line  69)
* fdbg_assign_name/2 (fdbg):             FDBG Naming Terms.   (line  10)
* fdbg_current_name/2 (fdbg):            FDBG Naming Terms.   (line  16)
* fdbg_get_name/2 (fdbg):                FDBG Naming Terms.   (line  20)
* fdbg_guard/3 (fdbg):                   FDBG Debugging Global Constraints.
                                                              (line  15)
* fdbg_labeling_step/2 (fdbg):           FDBG Annotation.     (line  25)
* fdbg_label_show/3 (fdbg):              FDBG Built-In Visualizers.
                                                              (line  35)
* fdbg_legend/[1,2] (fdbg):              FDBG Writing Visualizers.
                                                              (line  88)
* fdbg_off/0 (fdbg):                     FDBG Options.        (line  17)
* fdbg_on/[0,1] (fdbg):                  FDBG Options.        (line   8)
* fdbg_show/2 (fdbg):                    FDBG Built-In Visualizers.
                                                              (line  14)
* fdbg_start_labeling/1 (fdbg):          FDBG Annotation.     (line  21)
* fdbg_transform_actions/3 (fdbg):       FDBG Writing Legend Printers.
                                                              (line  15)
* fdset_add_element/3 (clpfd):           FD Set Operations.   (line  83)
* fdset_complement/2 (clpfd):            FD Set Operations.   (line 132)
* fdset_del_element/3 (clpfd):           FD Set Operations.   (line  87)
* fdset_disjoint/2 (clpfd):              FD Set Operations.   (line  91)
* fdset_eq/2 (clpfd):                    FD Set Operations.   (line 111)
* fdset_intersect/2 (clpfd):             FD Set Operations.   (line  95)
* fdset_intersection/[2,3] (clpfd):      FD Set Operations.   (line  99)
* fdset_interval/3 (clpfd):              FD Set Operations.   (line  39)
* fdset_max/2 (clpfd):                   FD Set Operations.   (line  52)
* fdset_member/2 (clpfd):                FD Set Operations.   (line 106)
* fdset_min/2 (clpfd):                   FD Set Operations.   (line  48)
* fdset_parts/4 (clpfd):                 FD Set Operations.   (line  24)
* fdset_singleton/2 (clpfd):             FD Set Operations.   (line  43)
* fdset_size/2 (clpfd):                  FD Set Operations.   (line  57)
* fdset_subset/2 (clpfd):                FD Set Operations.   (line 116)
* fdset_subtract/3 (clpfd):              FD Set Operations.   (line 120)
* fdset_to_list/2 (clpfd):               FD Set Operations.   (line  68)
* fdset_to_range/2 (clpfd):              FD Set Operations.   (line  78)
* fdset_union/[2,3] (clpfd):             FD Set Operations.   (line 125)
* fdvar_portray/3 (fdbg, hook):          FDBG Customizing Output.
                                                              (line   9)
* fd_batch/1 (clpfd):                    Posting Constraints. (line  31)
* fd_closure/2 (clpfd):                  Reflection Predicates.
                                                              (line  81)
* fd_degree/2 (clpfd):                   Reflection Predicates.
                                                              (line  48)
* fd_dom/2 (clpfd):                      Reflection Predicates.
                                                              (line  42)
* fd_failures/2 (clpfd):                 Reflection Predicates.
                                                              (line  57)
* fd_flag/3 (clpfd):                     The Global Constraint Programming Interface.
                                                              (line 137)
* fd_global/[3,4] (clpfd):               The Global Constraint Programming Interface.
                                                              (line  83)
* fd_max/2 (clpfd):                      Reflection Predicates.
                                                              (line  24)
* fd_min/2 (clpfd):                      Reflection Predicates.
                                                              (line  18)
* fd_neighbors/2 (clpfd):                Reflection Predicates.
                                                              (line  75)
* fd_purge/1 (clpfd):                    Forgetting Constraints.
                                                              (line  14)
* fd_set/2 (clpfd):                      Reflection Predicates.
                                                              (line  36)
* fd_set_failures/2 (clpfd):             Reflection Predicates.
                                                              (line  65)
* fd_size/2 (clpfd):                     Reflection Predicates.
                                                              (line  30)
* fd_statistics/[0,2] (clpfd):           Statistics Predicates.
                                                              (line  11)
* fd_var/1 (clpfd):                      Reflection Predicates.
                                                              (line  13)
* fetch_slot/2 (objects):                obj-exp-fetch_slot.  (line   6)
* file_exists/1 (file_systems):          lib-file_systems.    (line 102)
* file_exists/2 (file_systems):          lib-file_systems.    (line 102)
* file_members_of_directory/[1,2,3] (file_systems): lib-file_systems.
                                                              (line 191)
* file_member_of_directory/[2,3,4] (file_systems): lib-file_systems.
                                                              (line 172)
* file_must_exist/1 (file_systems):      lib-file_systems.    (line 110)
* file_must_exist/2 (file_systems):      lib-file_systems.    (line 110)
* file_property/[2,3] (file_systems):    lib-file_systems.    (line 294)
* file_search_path/2 (hook, ref page):   mpg-ref-file_search_path.
                                                              (line   6)
* file_search_path/2 (user, hook):       ref-fdi-fsp-def.     (line   6)
* findall/[3,4] (built-in):              ref-all-cba-cal.     (line   6)
* findall/[3,4] (built-in, ref page):    mpg-ref-findall.     (line   6)
* find_chr_constraint/1 (chr):           CHR Debugging Predicates.
                                                              (line  56)
* first_bound/2 (clpfd):                 Enumeration Predicates.
                                                              (line  28)
* first_bound/2 (clpfd) <1>:             Enumeration Predicates.
                                                              (line 166)
* fixme/1 (plunit option):               PlUnit A Unit Test Box.
                                                              (line  47)
* float/1 (built-in, ref page):          mpg-ref-float.       (line   6)
* flush_output/1 (built-in):             ref-iou-sfh-flu.     (line   6)
* flush_output/[0,1] (built-in, ref page): mpg-ref-flush_output.
                                                              (line   6)
* forall/1 (plunit option):              PlUnit A Unit Test Box.
                                                              (line  76)
* forall/2 (aggregate):                  lib-aggregate.       (line 115)
* foreach/2 (aggregate):                 lib-aggregate.       (line 121)
* foreign/[2,3] (hook, ref page):        mpg-ref-foreign.     (line   6)
* foreign/[2,3] (Module, hook):          Conversion Declarations.
                                                              (line  30)
* foreign_resource/2 (hook, ref page):   mpg-ref-foreign_resource.
                                                              (line   6)
* foreign_resource/2 (Module, hook):     Conversion Declarations.
                                                              (line  10)
* foreign_type/2 (structs):              str-fty-dty.         (line   6)
* format/[2,3] (built-in):               ref-iou-cou-fou.     (line   6)
* format/[2,3] (built-in, ref page):     mpg-ref-format.      (line   6)
* format_to_codes/[3,4] (codesio):       lib-codesio.         (line  15)
* fractile/3 (statistics):               lib-statistics.      (line 120)
* freeze/2 (built-in, ref page):         mpg-ref-freeze.      (line   6)
* free_of_term/2 (terms):                lib-terms.           (line 212)
* free_of_var/2 (terms):                 lib-terms.           (line 234)
* free_variables/4 (aggregate):          lib-aggregate.       (line 155)
* frozen/2 (built-in, ref page):         mpg-ref-frozen.      (line   6)
* full_answer/0 (clpfd):                 Answer Constraints.  (line  20)
* functor/3 (built-in):                  ref-lte-act.         (line   6)
* functor/3 (built-in, ref page):        mpg-ref-functor.     (line   6)
* fzn_dump/[2,3] (zinc):                 FlatZinc Exported Predicates.
                                                              (line 344)
* fzn_identifier/3 (zinc):               FlatZinc Exported Predicates.
                                                              (line 152)
* fzn_load_file/2 (zinc):                FlatZinc Exported Predicates.
                                                              (line  36)
* fzn_load_stream/2 (zinc):              FlatZinc Exported Predicates.
                                                              (line  28)
* fzn_objective/2 (zinc):                FlatZinc Exported Predicates.
                                                              (line 181)
* fzn_output/1 (zinc):                   FlatZinc Exported Predicates.
                                                              (line 122)
* fzn_post/1 (zinc):                     FlatZinc Exported Predicates.
                                                              (line 110)
* fzn_run_file/[1,2] (zinc):             FlatZinc Exported Predicates.
                                                              (line 324)
* fzn_run_stream/[1,2] (zinc):           FlatZinc Exported Predicates.
                                                              (line 296)
* fzn_solve/1 (zinc):                    FlatZinc Exported Predicates.
                                                              (line 115)
* garbage_collect/0 (built-in):          ref-mgc-gcd.         (line  21)
* garbage_collect/0 (built-in, ref page): mpg-ref-garbage_collect.
                                                              (line   6)
* garbage_collect_atoms/0 (built-in):    ref-mgc-ago-agc.     (line  18)
* garbage_collect_atoms/0 (built-in, ref page): mpg-ref-garbage_collect_atoms.
                                                              (line   6)
* generate_message/3 (hook, ref page):   mpg-ref-generate_message.
                                                              (line   6)
* generate_message/3 (SU_messages):      Message Handling Predicates.
                                                              (line  25)
* generate_message_hook/3 (hook, ref page): mpg-ref-generate_message_hook.
                                                              (line   6)
* generate_message_hook/3 (user, hook):  Message Handling Predicates.
                                                              (line  19)
* gen_assoc/3 (assoc):                   lib-assoc.           (line  24)
* gen_int/1 (between):                   lib-between.         (line  23)
* gen_label/3 (trees):                   lib-trees.           (line  11)
* gen_nat/1 (between):                   lib-between.         (line  17)
* geometric_mean/2 (statistics):         lib-statistics.      (line  46)
* geost/[2,3,4] (clpfd):                 Placement Constraints.
                                                              (line 152)
* getrand/1 (random):                    lib-random.          (line  24)
* get_address/3 (structs):               str-afd.             (line  11)
* get_assoc/3 (assoc):                   lib-assoc.           (line  34)
* get_atts/2 (Module):                   lib-atts.            (line  39)
* get_byte/[1,2] (built-in):             ref-iou-cin-cha.     (line   6)
* get_byte/[1,2] (built-in, ref page):   mpg-ref-get_byte.    (line   6)
* get_char/[1,2] (built-in):             ref-iou-cin-cha.     (line  12)
* get_char/[1,2] (built-in, ref page):   mpg-ref-get_char.    (line   6)
* get_code/[1,2] (built-in):             ref-iou-cin-cha.     (line   9)
* get_code/[1,2] (built-in, ref page):   mpg-ref-get_code.    (line   6)
* get_contents/3 (structs):              str-afd.             (line   6)
* get_label/3 (trees):                   lib-trees.           (line  16)
* get_mutable/2 (built-in):              ref-lte-mut.         (line  39)
* get_mutable/2 (built-in, ref page):    mpg-ref-get_mutable. (line   6)
* get_next_assoc/4 (assoc):              lib-assoc.           (line  47)
* get_prev_assoc/4:                      lib-assoc.           (line  59)
* global_cardinality/[2,3] (clpfd):      Arithmetic-Logical Constraints.
                                                              (line  51)
* goal_expansion/5 (hook, ref page):     mpg-ref-goal_expansion.
                                                              (line   6)
* goal_expansion/5 (Module, hook):       ref-lod-exp.         (line  45)
* goal_source_info/3 (built-in):         ref-ere-err.         (line 113)
* goal_source_info/3 (built-in) <1>:     Message Handling Predicates.
                                                              (line  42)
* goal_source_info/3 (built-in, ref page): mpg-ref-goal_source_info.
                                                              (line   6)
* ground/1 (built-in, ref page):         mpg-ref-ground.      (line   6)
* group/[3,4,5] (lists):                 lib-lists.           (line 658)
* halt/[0,1] (built-in):                 ref-ere-int.         (line  12)
* halt/[0,1] (built-in, ref page):       mpg-ref-halt.        (line   6)
* harmonic_mean/2 (statistics):          lib-statistics.      (line  49)
* head/2 (lists):                        lib-lists.           (line 362)
* if/1 (conditional directive):          ref-lod-cnd.         (line   6)
* if/3 (built-in, ref page):             mpg-ref-if.          (line   6)
* if/3, soft cut:                        ref-sem-ctr-ite.     (line  48)
* illarg/[3,4] (types):                  lib-types.           (line  80)
* in/1 (linda_client):                   lib-linda-client.    (line  66)
* in/2 (clpfd):                          Membership Constraints.
                                                              (line  15)
* in/2 (linda_client):                   lib-linda-client.    (line  79)
* include/1 (built-in, ref page):        mpg-ref-include.     (line   6)
* include/1 (declaration):               Include Declarations.
                                                              (line   6)
* include/[3,4,5] (lists):               lib-lists.           (line 615)
* increasing_prefix/[3,4] (lists):       lib-lists.           (line 761)
* indomain/1 (clpfd):                    Enumeration Predicates.
                                                              (line  15)
* inf/[2,4] (clpqr):                     CLPQR Solver Predicates.
                                                              (line  86)
* inherit/1 (objects):                   obj-exp-inherit.     (line   6)
* initialization/1 (built-in, ref page): mpg-ref-initialization.
                                                              (line   6)
* initialization/1 (declaration):        Initializations.     (line   6)
* instance/2 (built-in):                 ref-mdb-acl.         (line   6)
* instance/2 (built-in, ref page):       mpg-ref-instance.    (line   6)
* instance_method/1 (objects):           obj-exp-instance_method.
                                                              (line   6)
* integer/1 (built-in, ref page):        mpg-ref-integer.     (line   6)
* intersect/2 (sets):                    lib-sets.            (line  47)
* intersection/[2,3] (sets):             lib-sets.            (line  82)
* in_noblock/1 (linda_client):           lib-linda-client.    (line  72)
* in_set/2 (clpfd):                      Membership Constraints.
                                                              (line  20)
* is/2 (built-in):                       ref-ari-eae.         (line  15)
* is/2 (built-in, ref page):             mpg-ref-is.          (line   6)
* is/2 (declaration):                    Is2 Declarations.    (line   6)
* is_assoc/1 (assoc):                    lib-assoc.           (line  65)
* is_avl/1 (avl):                        lib-avl.             (line  24)
* is_bag/1 (bags):                       lib-bags.            (line  38)
* is_fdset/1 (clpfd):                    FD Set Operations.   (line  16)
* is_json_term/[1,2] (json):             lib-json.            (line 165)
* is_list/1 (lists):                     lib-lists.           (line  67)
* is_mutarray/1 (mutarray):              lib-mutarray.        (line  19)
* is_mutdict/1 (mutdict):                lib-mutdict.         (line  23)
* is_ordset/1 (ordsets):                 lib-ordsets.         (line  24)
* is_process/1 (process):                lib-process.         (line 454)
* is_queue/1 (queues):                   lib-queues.          (line  38)
* is_set/1 (sets):                       lib-sets.            (line  36)
* jasper_call/4 (jasper):                Jasper Library Predicates.
                                                              (line  74)
* jasper_create_global_ref/3 (jasper):   Jasper Library Predicates.
                                                              (line 152)
* jasper_create_local_ref/3 (jasper):    Jasper Library Predicates.
                                                              (line 161)
* jasper_deinitialize/1 (jasper):        Jasper Library Predicates.
                                                              (line  69)
* jasper_delete_global_ref/2 (jasper):   Jasper Library Predicates.
                                                              (line 157)
* jasper_delete_local_ref/2 (jasper):    Jasper Library Predicates.
                                                              (line 166)
* jasper_initialize/[1,2] (jasper):      Jasper Library Predicates.
                                                              (line   9)
* jasper_is_instance_of/3 (jasper):      Jasper Library Predicates.
                                                              (line 193)
* jasper_is_jvm/1 (jasper):              Jasper Library Predicates.
                                                              (line 170)
* jasper_is_object/[1,2] (jasper):       Jasper Library Predicates.
                                                              (line 175)
* jasper_is_same_object/3 (jasper):      Jasper Library Predicates.
                                                              (line 185)
* jasper_new_object/5 (jasper):          Jasper Library Predicates.
                                                              (line 115)
* jasper_new_object/5 (jasper) <1>:      Deprecated Jasper Predicates.
                                                              (line   8)
* jasper_null/2 (jasper):                Jasper Library Predicates.
                                                              (line 204)
* jasper_null/2 (jasper) <1>:            Jasper Library Predicates.
                                                              (line 208)
* jasper_object_class_name/3 (jasper):   Jasper Library Predicates.
                                                              (line 199)
* json_from_atom/[2,3] (json):           lib-json.            (line 184)
* json_from_codes/[2,3] (json):          lib-json.            (line 179)
* json_read/[2,3] (json):                lib-json.            (line 156)
* json_to_atom/[2,3] (json):             lib-json.            (line 174)
* json_to_codes/[2,3] (json):            lib-json.            (line 169)
* json_write/[2,3] (json):               lib-json.            (line 161)
* keyclumped/2 (lists):                  lib-lists.           (line 795)
* keyclumps/2 (lists):                   lib-lists.           (line 779)
* keymerge/3 (samsort):                  lib-samsort.         (line  37)
* keysort/2 (built-in):                  ref-lte-cte-sor.     (line   6)
* keysort/2 (built-in, ref page):        mpg-ref-keysort.     (line   6)
* keysorting/[2,3] (clpfd):              Arithmetic-Logical Constraints.
                                                              (line 284)
* keys_and_values/3 (lists):             lib-lists.           (line  73)
* kurtosis/2 (statistics):               lib-statistics.      (line  64)
* labeling/1 (clpb):                     CLPB Interface.      (line  28)
* labeling/2 (clpfd):                    Enumeration Predicates.
                                                              (line  20)
* last/2 (lists):                        lib-lists.           (line  91)
* last/3 (lists):                        lib-lists.           (line 356)
* later_bound/2 (clpfd):                 Enumeration Predicates.
                                                              (line  28)
* later_bound/2 (clpfd) <1>:             Enumeration Predicates.
                                                              (line 166)
* leash/1 (built-in):                    Basic Debug.         (line  48)
* leash/1 (built-in, ref page):          mpg-ref-leash.       (line   6)
* legend_portray/3 (fdbg, hook):         FDBG Customizing Output.
                                                              (line  24)
* length/2 (built-in):                   ref-lte-acl.         (line  13)
* length/2 (built-in, ref page):         mpg-ref-length.      (line   6)
* length/3 (bags):                       lib-bags.            (line 158)
* length_bound/2 (terms):                lib-terms.           (line 260)
* lex_chain/[1,2] (clpfd):               Arithmetic-Logical Constraints.
                                                              (line 317)
* library_directory/1 (hook, ref page):  mpg-ref-library_directory.
                                                              (line   6)
* linda/[0,1] (linda):                   lib-linda-server.    (line  18)
* linda_client/1 (linda_client):         lib-linda-client.    (line  19)
* linda_timeout/2 (linda_client):        lib-linda-client.    (line  54)
* line_count/2 (built-in):               ref-iou-sfh-opn.     (line  80)
* line_count/2 (built-in) <1>:           ref-iou-sos.         (line  24)
* line_count/2 (built-in, ref page):     mpg-ref-line_count.  (line   6)
* line_position/2 (built-in):            ref-iou-sfh-opn.     (line  80)
* line_position/2 (built-in) <1>:        ref-iou-sos.         (line  29)
* line_position/2 (built-in, ref page):  mpg-ref-line_position.
                                                              (line   6)
* listing/[0,1] (built-in):              Syntax Errors.       (line  28)
* listing/[0,1] (built-in) <1>:          ref-mod-idp.         (line  23)
* listing/[0,1] (built-in, ref page):    mpg-ref-listing.     (line   6)
* list_queue/2 (queues):                 lib-queues.          (line  88)
* list_to_assoc/2 (assoc):               lib-assoc.           (line  74)
* list_to_avl/2 (avl):                   lib-avl.             (line 130)
* list_to_bag/2 (bags):                  lib-bags.            (line  96)
* list_to_fdset/2 (clpfd):               FD Set Operations.   (line  63)
* list_to_mutarray/2 (mutarray):         lib-mutarray.        (line  22)
* list_to_mutdict/2 (mutdict):           lib-mutdict.         (line  26)
* list_to_ord_set/2 (ordsets):           lib-ordsets.         (line  31)
* list_to_set/2 (sets):                  lib-sets.            (line  73)
* list_to_tree/2 (trees):                lib-trees.           (line  22)
* lmdb_close/1 (lmdb):                   LMDB The Predicates. (line  37)
* lmdb_compress/2 (lmdb):                LMDB The Predicates. (line  82)
* lmdb_create/[2,3] (lmdb):              LMDB The Predicates. (line   9)
* lmdb_enumerate/3 (lmdb):               LMDB The Predicates. (line  65)
* lmdb_erase/2 (lmdb):                   LMDB The Predicates. (line  61)
* lmdb_export/2 (lmdb):                  LMDB The Predicates. (line 139)
* lmdb_fetch/3 (lmdb):                   LMDB The Predicates. (line  45)
* lmdb_findall/3 (lmdb):                 LMDB The Predicates. (line  74)
* lmdb_import/2 (lmdb):                  LMDB The Predicates. (line 143)
* lmdb_iterator_done/1 (lmdb):           LMDB The Predicates. (line 117)
* lmdb_iterator_next/3 (lmdb):           LMDB The Predicates. (line 112)
* lmdb_make_iterator/3 (lmdb):           LMDB The Predicates. (line  98)
* lmdb_open/[2,3] (lmdb):                LMDB The Predicates. (line  16)
* lmdb_property/2 (lmdb):                LMDB The Predicates. (line 120)
* lmdb_store/3 (lmdb):                   LMDB The Predicates. (line  40)
* lmdb_sync/1 (lmdb):                    LMDB The Predicates. (line  94)
* lmdb_with_db/[2,3] (lmdb):             LMDB The Predicates. (line  27)
* lmdb_with_iterator/3 (lmdb):           LMDB The Predicates. (line 106)
* load_files/[1,2] (built-in):           ref-sls-ssl.         (line   6)
* load_files/[1,2] (built-in, ref page): mpg-ref-load_files.  (line   6)
* load_foreign_resource/1 (built-in):    Interface Predicates.
                                                              (line   8)
* load_foreign_resource/1 (built-in, ref page): mpg-ref-load_foreign_resource.
                                                              (line   6)
* make_directory/1 (file_systems):       lib-file_systems.    (line  97)
* make_sub_bag/2 (bags):                 lib-bags.            (line 163)
* mapbag/2 (bags):                       lib-bags.            (line  55)
* mapbag/3 (bags):                       lib-bags.            (line  61)
* maplist/[2,3,4] (lists):               lib-lists.           (line 449)
* map_assoc/2 (assoc):                   lib-assoc.           (line  87)
* map_assoc/3 (assoc):                   lib-assoc.           (line  94)
* map_list_queue/3 (queues):             lib-queues.          (line 125)
* map_product/5 (lists):                 lib-lists.           (line 483)
* map_queue/[2,3] (queues):              lib-queues.          (line 114)
* map_queue_list/3 (queues):             lib-queues.          (line 120)
* map_tree/3 (trees):                    lib-trees.           (line  27)
* max/2 (statistics):                    lib-statistics.      (line  21)
* maximize/1 (clpqr):                    CLPQR Solver Predicates.
                                                              (line 122)
* maximize/[2,3] (clpfd):                Enumeration Predicates.
                                                              (line  36)
* maximum/2 (clpfd):                     Arithmetic Constraints.
                                                              (line  91)
* maximum_arg/2 (clpfd):                 Arithmetic Constraints.
                                                              (line 110)
* max_assoc/3 (assoc):                   lib-assoc.           (line 105)
* max_cliques/2 (ugraphs):               lib-ugraphs.         (line 160)
* max_member/[2,3] (lists):              lib-lists.           (line 687)
* max_path/5 (ugraphs):                  lib-ugraphs.         (line 121)
* max_path/5 (wgraphs):                  lib-wgraphs.         (line 110)
* maybe/[0,1,2] (random):                lib-random.          (line  48)
* mean/2 (statistics):                   lib-statistics.      (line  39)
* median/2 (statistics):                 lib-statistics.      (line 113)
* member/2 (built-in):                   ref-lte-acl.         (line  21)
* member/2 (built-in, ref page):         mpg-ref-member.      (line   6)
* member/3 (bags):                       lib-bags.            (line 116)
* memberchk/2 (built-in):                ref-lte-acl.         (line  18)
* memberchk/2 (built-in, ref page):      mpg-ref-memberchk.   (line   6)
* memberchk/3 (bags):                    lib-bags.            (line 121)
* merge/[3,4] (samsort):                 lib-samsort.         (line  15)
* message/4 (objects):                   obj-exp-message.     (line   6)
* message_hook/3 (hook, ref page):       mpg-ref-message_hook.
                                                              (line   6)
* message_hook/3 (user, hook):           Message Handling Predicates.
                                                              (line  30)
* meta_predicate/1 (built-in, ref page): mpg-ref-meta_predicate.
                                                              (line   6)
* meta_predicate/1 (declaration):        Meta-Predicate Declarations.
                                                              (line   6)
* meta_predicate/1 (declaration) <1>:    ref-mod-met.         (line   6)
* min/2 (statistics):                    lib-statistics.      (line  18)
* minimize/1 (clpqr):                    CLPQR Solver Predicates.
                                                              (line 116)
* minimize/[2,3] (clpfd):                Enumeration Predicates.
                                                              (line  36)
* minimum/2 (clpfd):                     Arithmetic Constraints.
                                                              (line  85)
* minimum_arg/2 (clpfd):                 Arithmetic Constraints.
                                                              (line 101)
* min_assoc/3 (assoc):                   lib-assoc.           (line 111)
* min_max/3 (statistics):                lib-statistics.      (line  24)
* min_member/[2,3] (lists):              lib-lists.           (line 698)
* min_path/5 (ugraphs):                  lib-ugraphs.         (line 126)
* min_path/5 (wgraphs):                  lib-wgraphs.         (line 115)
* min_paths/3 (ugraphs):                 lib-ugraphs.         (line 130)
* min_paths/3 (wgraphs):                 lib-wgraphs.         (line 120)
* min_tree/3 (ugraphs):                  lib-ugraphs.         (line 156)
* min_tree/3 (wgraphs):                  lib-wgraphs.         (line 150)
* ml_standard_deviation/2 (statistics):  lib-statistics.      (line  89)
* ml_variance/2 (statistics):            lib-statistics.      (line  73)
* mode/1 (built-in, ref page):           mpg-ref-mode.        (line   6)
* mode/1 (declaration):                  Mode Declarations.   (line   6)
* mode/2 (statistics):                   lib-statistics.      (line  31)
* module/[2,3] (built-in, ref page):     mpg-ref-module.      (line   6)
* module/[2,3] (declaration):            Module Declarations. (line   6)
* module/[2,3] (declaration) <1>:        ref-mod-lod.         (line  34)
* multifile/1 (built-in, ref page):      mpg-ref-multifile.   (line   6)
* multifile/1 (declaration):             Multifile Declarations.
                                                              (line   6)
* multi_cumulative/[2,3] (clpfd):        Scheduling Constraints.
                                                              (line 142)
* must_be/4 (types):                     lib-types.           (line  65)
* mutable/1 (built-in):                  ref-lte-mut.         (line  48)
* mutable/1 (built-in, ref page):        mpg-ref-mutable.     (line   6)
* mutarray_append/2 (mutarray):          lib-mutarray.        (line  63)
* mutarray_gen/3 (mutarray):             lib-mutarray.        (line  49)
* mutarray_get/3 (mutarray):             lib-mutarray.        (line  53)
* mutarray_last/2 (mutarray):            lib-mutarray.        (line  42)
* mutarray_length/2 (mutarray):          lib-mutarray.        (line  33)
* mutarray_put/3 (mutarray):             lib-mutarray.        (line  56)
* mutarray_set_length/2 (mutarray):      lib-mutarray.        (line  36)
* mutarray_to_list/2 (mutarray):         lib-mutarray.        (line  46)
* mutarray_update/4 (mutarray):          lib-mutarray.        (line  59)
* mutdict_append/2 (mutdict):            lib-mutdict.         (line  77)
* mutdict_clear/1 (mutdict):             lib-mutdict.         (line  61)
* mutdict_delete/2 (mutdict):            lib-mutdict.         (line  57)
* mutdict_empty/1 (mutdict):             lib-mutdict.         (line  33)
* mutdict_gen/3 (mutdict):               lib-mutdict.         (line  39)
* mutdict_get/3 (mutdict):               lib-mutdict.         (line  43)
* mutdict_items/2 (mutdict):             lib-mutdict.         (line  72)
* mutdict_keys/2 (mutdict):              lib-mutdict.         (line  64)
* mutdict_put/3 (mutdict):               lib-mutdict.         (line  47)
* mutdict_size/1 (mutdict):              lib-mutdict.         (line  36)
* mutdict_update/4 (mutdict):            lib-mutdict.         (line  52)
* mutdict_values/2 (mutdict):            lib-mutdict.         (line  68)
* mzn_load_file/[2,3] (zinc):            MiniZinc Exported Predicates.
                                                              (line 234)
* mzn_load_file/[2,3] (zinc) <1>:        MiniZinc Exported Predicates.
                                                              (line 257)
* mzn_run_file/[1,2] (zinc):             MiniZinc Exported Predicates.
                                                              (line 119)
* mzn_run_model/[1,2] (zinc):            MiniZinc Exported Predicates.
                                                              (line 146)
* mzn_to_fzn/[2,3] (zinc):               MiniZinc Exported Predicates.
                                                              (line 308)
* name/2 (built-in):                     ref-lte-c2t.         (line   6)
* name/2 (built-in) <1>:                 ref-lte-c2t.         (line  26)
* name/2 (built-in, ref page):           mpg-ref-name.        (line   6)
* neighbors/3 (ugraphs):                 lib-ugraphs.         (line  77)
* neighbors/3 (wgraphs):                 lib-wgraphs.         (line  34)
* neighbours/3 (ugraphs):                lib-ugraphs.         (line  77)
* neighbours/3 (wgraphs):                lib-wgraphs.         (line  34)
* new/[2,3] (structs):                   str-cdf.             (line   6)
* new_mutarray/1 (mutarray):             lib-mutarray.        (line  26)
* new_mutarray/2 (mutarray):             lib-mutarray.        (line  29)
* new_mutdict/1 (mutdict):               lib-mutdict.         (line  30)
* nextto/3 (lists):                      lib-lists.           (line  97)
* nl/[0,1] (built-in):                   ref-iou-cou-nln.     (line   6)
* nl/[0,1] (built-in, ref page):         mpg-ref-nl.          (line   6)
* nodebug/0 (built-in):                  Basic Debug.         (line  98)
* nodebug/0 (built-in, ref page):        mpg-ref-nodebug.     (line   6)
* nodebug_message/0 (objects):           obj-exp-nodebug_message.
                                                              (line   6)
* nondet/0 (plunit option):              PlUnit A Unit Test Box.
                                                              (line  68)
* nonmember/2 (built-in):                ref-lte-acl.         (line  24)
* nonmember/2 (built-in, ref page):      mpg-ref-nonmember.   (line   6)
* nonvar/1 (built-in, ref page):         mpg-ref-nonvar.      (line   6)
* normalize/2 (statistics):              lib-statistics.      (line 126)
* nospy/1 (built-in):                    Plain Spypoint.      (line  43)
* nospy/1 (built-in, ref page):          mpg-ref-nospy.       (line   6)
* nospyall/0 (built-in):                 Plain Spypoint.      (line  50)
* nospyall/0 (built-in, ref page):       mpg-ref-nospyall.    (line   6)
* notrace/0 (built-in):                  Basic Debug.         (line  98)
* notrace/0 (built-in, ref page):        mpg-ref-notrace.     (line   6)
* now/1 (system):                        lib-system.          (line  14)
* nozip/0 (built-in):                    Basic Debug.         (line  98)
* nozip/0 (built-in, ref page):          mpg-ref-nozip.       (line   6)
* nth0/[3,4] (lists):                    lib-lists.           (line 104)
* nth1/[3,4] (lists):                    lib-lists.           (line 110)
* null_foreign_term/2 (structs):         str-nul.             (line   6)
* number/1 (built-in, ref page):         mpg-ref-number.      (line   6)
* numbervars/1 (varnumbers):             lib-varnumbers.      (line  40)
* numbervars/3 (built-in):               ref-lte-anv.         (line   6)
* numbervars/3 (built-in, ref page):     mpg-ref-numbervars.  (line   6)
* number_chars/2 (built-in):             ref-lte-c2t.         (line   6)
* number_chars/2 (built-in) <1>:         ref-lte-c2t.         (line  22)
* number_chars/2 (built-in, ref page):   mpg-ref-number_chars.
                                                              (line   6)
* number_codes/2 (built-in):             ref-lte-c2t.         (line   6)
* number_codes/2 (built-in) <1>:         ref-lte-c2t.         (line  16)
* number_codes/2 (built-in, ref page):   mpg-ref-number_codes.
                                                              (line   6)
* numlist/[2,3,5] (between):             lib-between.         (line  34)
* nvalue/2 (clpfd):                      Arithmetic-Logical Constraints.
                                                              (line 191)
* occurrences_of_term/3 (terms):         lib-terms.           (line 220)
* occurrences_of_var/3 (terms):          lib-terms.           (line 240)
* odbc_db_open/3 (odbc):                 ODBC Predicates.     (line  12)
* odbc_db_open/4 (odbc):                 ODBC Predicates.     (line  17)
* odbc_db_open/5 (odbc):                 ODBC Predicates.     (line  43)
* odbc_env_open/1 (odbc):                ODBC Predicates.     (line   8)
* odbc_list_DSN/2 (odbc):                ODBC Predicates.     (line  50)
* once/1:                                ref-sem-ctr-ite.     (line  39)
* once/1 (built-in, ref page):           mpg-ref-once.        (line   6)
* one_longer/2 (lists):                  lib-lists.           (line 134)
* on_exception/3 (built-in):             ref-ere-leg.         (line  12)
* on_exception/3 (built-in, ref page):   mpg-ref-on_exception.
                                                              (line   6)
* op/3 (built-in):                       ref-syn-ops-ops.     (line   6)
* op/3 (built-in, ref page):             mpg-ref-op.          (line   6)
* open/[3,4] (built-in):                 ref-iou-sfh-sob.     (line  37)
* open/[3,4] (built-in) <1>:             ref-iou-sfh-opn.     (line   6)
* open/[3,4] (built-in, ref page):       mpg-ref-open.        (line   6)
* open_codes_stream/2 (codesio):         lib-codesio.         (line  44)
* open_null_stream/1 (built-in):         ref-iou-sfh-opn.     (line  80)
* open_null_stream/1 (built-in, ref page): mpg-ref-open_null_stream.
                                                              (line   6)
* ordered/[1,2] (lists):                 lib-lists.           (line 674)
* ordering/1 (clpqr):                    CLPQR Solver Predicates.
                                                              (line 182)
* ordering/1 (clpqr) <1>:                CLPQR Variable Ordering.
                                                              (line   6)
* ordset_order/3 (ordsets):              lib-ordsets.         (line 124)
* ord_add_element/3 (ordsets):           lib-ordsets.         (line  37)
* ord_del_element/3 (ordsets):           lib-ordsets.         (line  40)
* ord_disjoint/2 (ordsets):              lib-ordsets.         (line  44)
* ord_disjoint_union/3 (ordsets):        lib-ordsets.         (line 101)
* ord_intersect/2 (ordsets):             lib-ordsets.         (line  47)
* ord_intersection/[2,3,4] (ordsets):    lib-ordsets.         (line  51)
* ord_list_to_assoc/2 (assoc):           lib-assoc.           (line  82)
* ord_list_to_avl/2 (avl):               lib-avl.             (line 124)
* ord_member/2 (ordsets):                lib-ordsets.         (line  62)
* ord_nonmember/2 (ordsets):             lib-ordsets.         (line  65)
* ord_seteq/2 (ordsets):                 lib-ordsets.         (line  68)
* ord_setproduct/3 (ordsets):            lib-ordsets.         (line  72)
* ord_subset/2 (ordsets):                lib-ordsets.         (line  89)
* ord_subtract/3 (ordsets):              lib-ordsets.         (line  93)
* ord_symdiff/3 (ordsets):               lib-ordsets.         (line  97)
* ord_union/[2,3,4] (ordsets):           lib-ordsets.         (line 109)
* otherwise/0 (built-in, ref page):      mpg-ref-otherwise.   (line   6)
* out/1 (linda_client):                  lib-linda-client.    (line  62)
* pairfrom/4 (sets):                     lib-sets.            (line  40)
* partition/5 (lists):                   lib-lists.           (line 652)
* path/3 (ugraphs):                      lib-ugraphs.         (line 135)
* path/3 (wgraphs):                      lib-wgraphs.         (line 125)
* peek_byte/[1,2] (built-in):            ref-iou-cin-pee.     (line   9)
* peek_byte/[1,2] (built-in, ref page):  mpg-ref-peek_byte.   (line   6)
* peek_char/[1,2] (built-in):            ref-iou-cin-pee.     (line  16)
* peek_char/[1,2] (built-in, ref page):  mpg-ref-peek_char.   (line   6)
* peek_code/[1,2] (built-in):            ref-iou-cin-pee.     (line  12)
* peek_code/[1,2] (built-in, ref page):  mpg-ref-peek_code.   (line   6)
* perm/2 (lists):                        lib-lists.           (line 141)
* perm2/4 (lists):                       lib-lists.           (line 155)
* permutation/2 (lists):                 lib-lists.           (line 147)
* phrase/[2,3] (built-in):               ref-gru-exa.         (line  30)
* phrase/[2,3] (built-in, ref page):     mpg-ref-phrase.      (line   6)
* pointer_object/2 (objects):            obj-exp-pointer_object.
                                                              (line   6)
* population_standard_deviation/2 (statistics): lib-statistics.
                                                              (line  89)
* population_variance/2 (statistics):    lib-statistics.      (line  73)
* portray/1 (hook, ref page):            mpg-ref-portray.     (line   6)
* portray/1 (user, hook):                ref-iou-tou-por.     (line   6)
* portray/1 (user, hook) <1>:            CLPQR Fragments and Bits.
                                                              (line  12)
* portray_assoc/1 (assoc):               lib-assoc.           (line 117)
* portray_avl/1 (avl):                   lib-avl.             (line  65)
* portray_bag/1 (bags):                  lib-bags.            (line  42)
* portray_clause/[1,2] (built-in):       ref-iou-tou-pcl.     (line   6)
* portray_clause/[1,2] (built-in, ref page): mpg-ref-portray_clause.
                                                              (line   6)
* portray_message/2 (hook, ref page):    mpg-ref-portray_message.
                                                              (line   6)
* portray_message/2 (user, hook):        Message Handling Predicates.
                                                              (line  14)
* portray_queue/1 (queues):              lib-queues.          (line  31)
* power_set/2 (sets):                    lib-sets.            (line  78)
* predicate_property/2 (built-in):       ref-lps-app.         (line   6)
* predicate_property/2 (built-in) <1>:   ref-mod-ilm-vis.     (line  12)
* predicate_property/2 (built-in) <2>:   ref-mod-ilm-vis.     (line  17)
* predicate_property/2 (built-in) <3>:   ref-mod-ilm-vis.     (line  42)
* predicate_property/2 (built-in, ref page): mpg-ref-predicate_property.
                                                              (line   6)
* prefix/2 (lists):                      lib-lists.           (line 370)
* prefix_length/3 (lists):               lib-lists.           (line 284)
* print/[1,2] (built-in):                ref-iou-tou-dsp.     (line   6)
* print/[1,2] (built-in, ref page):      mpg-ref-print.       (line   6)
* print_coverage/[0,1] (built-in):       Coverage Analysis.   (line  46)
* print_coverage/[0,1] (built-in, ref page): mpg-ref-print_coverage.
                                                              (line   6)
* print_message/2 (built-in):            Message Handling Predicates.
                                                              (line   8)
* print_message/2 (built-in, ref page):  mpg-ref-print_message.
                                                              (line   6)
* print_message_lines/3 (built-in):      Message Handling Predicates.
                                                              (line  37)
* print_message_lines/3 (built-in, ref page): mpg-ref-print_message_lines.
                                                              (line   6)
* print_profile/[0,1] (built-in):        Execution Profiling. (line  57)
* print_profile/[0,1] (built-in, ref page): mpg-ref-print_profile.
                                                              (line   6)
* process_create/[2,3] (process):        lib-process.         (line 275)
* process_id/1 (process):                lib-process.         (line 448)
* process_id/2 (process):                lib-process.         (line 451)
* process_kill/[1,2] (process):          lib-process.         (line 470)
* process_release/1 (process):           lib-process.         (line 458)
* process_wait/[2,3] (process):          lib-process.         (line 406)
* profile_data/1 (built-in):             Execution Profiling. (line  51)
* profile_data/1 (built-in, ref page):   mpg-ref-profile_data.
                                                              (line   6)
* profile_reset/0 (built-in):            Execution Profiling. (line  47)
* profile_reset/0 (built-in) <1>:        Coverage Analysis.   (line  35)
* profile_reset/0 (built-in, ref page):  mpg-ref-profile_reset.
                                                              (line   6)
* projecting_assert/1 (clpqr):           CLPQR Solver Predicates.
                                                              (line 222)
* project_attributes/2 (Module):         lib-atts.            (line 137)
* prolog_flag/[2,3] (built-in):          ref-iou-tin-trm.     (line  40)
* prolog_flag/[2,3] (built-in, ref page): mpg-ref-prolog_flag.
                                                              (line   6)
* prolog_load_context/2 (built-in, ref page): mpg-ref-prolog_load_context.
                                                              (line   6)
* prompt/2 (built-in):                   ref-iou-tin-cpr.     (line   6)
* prompt/2 (built-in, ref page):         mpg-ref-prompt.      (line   6)
* proper_length/2 (lists):               lib-lists.           (line 159)
* proper_prefix/2 (lists):               lib-lists.           (line 376)
* proper_prefix_length/3 (lists):        lib-lists.           (line 294)
* proper_segment/2 (lists):              lib-lists.           (line 404)
* proper_suffix/2 (lists):               lib-lists.           (line 388)
* proper_suffix_length/3 (lists):        lib-lists.           (line 314)
* public/1 (built-in, ref page):         mpg-ref-public.      (line   6)
* public/1 (declaration):                Public Declarations. (line   6)
* put_assoc/4 (assoc):                   lib-assoc.           (line 124)
* put_atts/2 (Module):                   lib-atts.            (line  54)
* put_byte/[1,2] (built-in):             ref-iou-cou-cha.     (line   6)
* put_byte/[1,2] (built-in, ref page):   mpg-ref-put_byte.    (line   6)
* put_char/[1,2] (built-in):             ref-iou-cou-cha.     (line  12)
* put_char/[1,2] (built-in, ref page):   mpg-ref-put_char.    (line   6)
* put_code/[1,2] (built-in):             ref-iou-cou-cha.     (line   9)
* put_code/[1,2] (built-in, ref page):   mpg-ref-put_code.    (line   6)
* put_contents/3 (structs):              str-afd.             (line   6)
* put_label/[4,5] (trees):               lib-trees.           (line  32)
* query_abbreviation/3 (hook, ref page): mpg-ref-query_abbreviation.
                                                              (line   6)
* query_abbreviation/3 (SU_messages):    Query Handling Predicates.
                                                              (line  34)
* query_class/5 (hook, ref page):        mpg-ref-query_class. (line   6)
* query_class/5 (SU_messages):           Query Handling Predicates.
                                                              (line  30)
* query_class_hook/5 (hook, ref page):   mpg-ref-query_class_hook.
                                                              (line   6)
* query_class_hook/5 (user, hook):       Query Handling Predicates.
                                                              (line  23)
* query_hook/6 (hook, ref page):         mpg-ref-query_hook.  (line   6)
* query_hook/6 (user, hook):             Query Handling Predicates.
                                                              (line  16)
* query_input/3 (hook, ref page):        mpg-ref-query_input. (line   6)
* query_input/3 (SU_messages):           Query Handling Predicates.
                                                              (line  46)
* query_input_hook/3 (hook, ref page):   mpg-ref-query_input_hook.
                                                              (line   6)
* query_input_hook/3 (user, hook):       Query Handling Predicates.
                                                              (line  39)
* query_map/4 (hook, ref page):          mpg-ref-query_map.   (line   6)
* query_map/4 (SU_messages):             Query Handling Predicates.
                                                              (line  58)
* query_map_hook/4 (hook, ref page):     mpg-ref-query_map_hook.
                                                              (line   6)
* query_map_hook/4 (user, hook):         Query Handling Predicates.
                                                              (line  51)
* queue_append/3 (queues):               lib-queues.          (line  82)
* queue_cons/3 (queues):                 lib-queues.          (line  55)
* queue_head/2 (queues):                 lib-queues.          (line  44)
* queue_last/[2,3] (queues):             lib-queues.          (line  63)
* queue_length/2 (queues):               lib-queues.          (line  98)
* queue_list/2 (queues):                 lib-queues.          (line  93)
* queue_member/2 (queues):               lib-queues.          (line 103)
* queue_memberchk/2 (queues):            lib-queues.          (line 109)
* queue_tail/2 (queues):                 lib-queues.          (line  49)
* raise_exception/1 (built-in):          ref-ere-leg.         (line  12)
* raise_exception/1 (built-in, ref page): mpg-ref-raise_exception.
                                                              (line   6)
* random/[1,3] (random):                 lib-random.          (line  61)
* random_member/2 (random):              lib-random.          (line  68)
* random_numlist/4 (random):             lib-random.          (line  97)
* random_perm2/4 (random):               lib-random.          (line  92)
* random_permutation/2 (random):         lib-random.          (line  86)
* random_select/3 (random):              lib-random.          (line  72)
* random_subseq/3 (random):              lib-random.          (line  78)
* random_ugraph/3 (ugraphs):             lib-ugraphs.         (line 152)
* random_wgraph/4 (wgraphs):             lib-wgraphs.         (line 145)
* range/2 (statistics):                  lib-statistics.      (line  27)
* range_to_fdset/2 (clpfd):              FD Set Operations.   (line  73)
* rd/[1,2] (linda_client):               lib-linda-client.    (line  86)
* rd_noblock/1 (linda_client):           lib-linda-client.    (line  92)
* reachable/3 (ugraphs):                 lib-ugraphs.         (line 148)
* reachable/3 (wgraphs):                 lib-wgraphs.         (line 140)
* read/[1,2] (built-in):                 ref-iou-tin-trm.     (line   6)
* read/[1,2] (built-in, ref page):       mpg-ref-read.        (line   6)
* read_from_codes/2 (codesio):           lib-codesio.         (line  34)
* read_line/[1,2] (built-in, ref page):  mpg-ref-read_line.   (line   6)
* read_record/[1,2] (csv):               lib-csv.             (line 100)
* read_records/[1,2] (csv):              lib-csv.             (line 106)
* read_record_from_codes/[2,3] (csv):    lib-csv.             (line 112)
* read_term/[2,3] (built-in):            ref-iou-tin-trm.     (line   6)
* read_term/[2,3] (built-in, ref page):  mpg-ref-read_term.   (line   6)
* read_term_from_codes/3 (codesio):      lib-codesio.         (line  39)
* reconsult/1 (built-in, ref page):      mpg-ref-reconsult.   (line   6)
* recorda/3 (built-in):                  ref-mdb-idb.         (line  31)
* recorda/3 (built-in, ref page):        mpg-ref-recorda.     (line   6)
* recorded/3 (built-in, ref page):       mpg-ref-recorded.    (line   6)
* recordz/3 (built-in):                  ref-mdb-idb.         (line  35)
* recordz/3 (built-in, ref page):        mpg-ref-recordz.     (line   6)
* reduce/2 (ugraphs):                    lib-ugraphs.         (line 139)
* reduce/2 (wgraphs):                    lib-wgraphs.         (line 130)
* register_event_listener/[2,3] (prologbeans): PB Prolog Server Interface.
                                                              (line 135)
* register_query/[2,3] (prologbeans):    PB Prolog Server Interface.
                                                              (line  73)
* regular/2 (clpfd):                     Sequence Constraints.
                                                              (line 329)
* relation/3 (clpfd):                    Extensional Constraints.
                                                              (line  27)
* remove_breakpoints/1 (built-in):       Built-in Predicates for Breakpoint Handling.
                                                              (line  43)
* remove_breakpoints/1 (built-in) <1>:   Breakpoint Predicates.
                                                              (line  79)
* remove_breakpoints/1 (built-in, ref page): mpg-ref-remove_breakpoints.
                                                              (line   6)
* remove_dups/2 (lists):                 lib-lists.           (line 164)
* rem_add_link/4 (rem):                  lib-rem.             (line  23)
* rem_create/2 (rem):                    lib-rem.             (line  11)
* rem_equivalent/3 (rem):                lib-rem.             (line  19)
* rem_head/3 (random):                   lib-rem.             (line  15)
* rename_directory/2 (file_systems):     lib-file_systems.    (line  63)
* rename_file/2 (file_systems):          lib-file_systems.    (line  57)
* repeat/0 (built-in, ref page):         mpg-ref-repeat.      (line   6)
* repeat/1 (between):                    lib-between.         (line  29)
* restore/1 (built-in):                  Saving.              (line  23)
* restore/1 (built-in) <1>:              ref-sls-sst.         (line   6)
* restore/1 (built-in, ref page):        mpg-ref-restore.     (line   6)
* retract/1 (built-in):                  ref-mdb-rcd.         (line  19)
* retract/1 (built-in, ref page):        mpg-ref-retract.     (line   6)
* retractall/1 (built-in):               ref-mdb-rcd.         (line  19)
* retractall/1 (built-in, ref page):     mpg-ref-retractall.  (line   6)
* rev/2 (lists):                         lib-lists.           (line 179)
* reverse/2 (lists):                     lib-lists.           (line 172)
* rotate_list/[2,3] (lists):             lib-lists.           (line 324)
* runtime_entry/1 (user, hook):          too-spld.            (line  74)
* run_tests/[0,1,2] (plunit):            PlUnit Running the Test-Suite.
                                                              (line  11)
* same_functor/[2,3,4] (terms):          lib-terms.           (line 302)
* same_length/[2,3] (lists):             lib-lists.           (line 185)
* samkeysort/2 (samsort):                lib-samsort.         (line  30)
* sample_standard_deviation/2 (statistics): lib-statistics.   (line  96)
* sample_variance/2 (statistics):        lib-statistics.      (line  79)
* samsort/[2,3] (samsort):               lib-samsort.         (line  10)
* sat/1 (clpb):                          CLPB Interface.      (line  10)
* save_files/2 (built-in):               Saving.              (line  59)
* save_files/2 (built-in) <1>:           ref-sls-ssl.         (line   6)
* save_files/2 (built-in, ref page):     mpg-ref-save_files.  (line   6)
* save_modules/2 (built-in):             Saving.              (line  59)
* save_modules/2 (built-in) <1>:         ref-sls-ssl.         (line   6)
* save_modules/2 (built-in, ref page):   mpg-ref-save_modules.
                                                              (line   6)
* save_predicates/2 (built-in):          Saving.              (line  59)
* save_predicates/2 (built-in) <1>:      ref-sls-ssl.         (line   6)
* save_predicates/2 (built-in, ref page): mpg-ref-save_predicates.
                                                              (line   6)
* save_program/[1,2] (built-in):         Saving.              (line  10)
* save_program/[1,2] (built-in) <1>:     ref-sls-sst.         (line   6)
* save_program/[1,2] (built-in, ref page): mpg-ref-save_program.
                                                              (line   6)
* scalar_product/[4,5] (clpfd):          Arithmetic Constraints.
                                                              (line  45)
* scalar_product_reif/[5,6] (clpfd):     Arithmetic Constraints.
                                                              (line  76)
* scanlist/[4,5,6] (lists):              lib-lists.           (line 506)
* see/1 (built-in):                      ref-iou-sfh-opn.     (line  47)
* see/1 (built-in, ref page):            mpg-ref-see.         (line   6)
* seeing/1 (built-in):                   ref-iou-sfh-cis.     (line  15)
* seeing/1 (built-in, ref page):         mpg-ref-seeing.      (line   6)
* seek/4 (built-in):                     ref-iou-raf.         (line   6)
* seek/4 (built-in, ref page):           mpg-ref-seek.        (line   6)
* seen/0 (built-in):                     ref-iou-sfh-cst.     (line  29)
* seen/0 (built-in, ref page):           mpg-ref-seen.        (line   6)
* segment/2 (lists):                     lib-lists.           (line 395)
* select/3 (lists):                      lib-lists.           (line  10)
* select/4 (lists):                      lib-lists.           (line 200)
* selectchk/3 (lists):                   lib-lists.           (line  14)
* selectchk/4 (lists):                   lib-lists.           (line 206)
* select_max/[3,4] (lists):              lib-lists.           (line 740)
* select_min/[3,4] (lists):              lib-lists.           (line 733)
* seq_precede_chain/[1,2] (clpfd):       Sequence Constraints.
                                                              (line 410)
* session_get/4 (prologbeans):           PB Prolog Server Interface.
                                                              (line 107)
* session_put/3 (prologbeans):           PB Prolog Server Interface.
                                                              (line 120)
* set/1 (plunit option):                 PlUnit A Unit Test Box.
                                                              (line 179)
* seteq/2 (sets):                        lib-sets.            (line  70)
* setof/3 (built-in):                    ref-all-cse.         (line  10)
* setof/3 (built-in, ref page):          mpg-ref-setof.       (line   6)
* setproduct/3 (sets):                   lib-sets.            (line 132)
* setrand/1 (random):                    lib-random.          (line  27)
* setup/1 (plunit option):               PlUnit A Unit Test Box.
                                                              (line  87)
* set_input/1 (built-in):                ref-iou-sfh-opn.     (line   6)
* set_input/1 (built-in) <1>:            ref-iou-sfh-opn.     (line  33)
* set_input/1 (built-in, ref page):      mpg-ref-set_input.   (line   6)
* set_module/1 (built-in):               ref-mod-tyi.         (line  22)
* set_module/1 (built-in, ref page):     mpg-ref-set_module.  (line   6)
* set_order/3 (sets):                    lib-sets.            (line  66)
* set_output/1 (built-in):               ref-iou-sfh-opn.     (line   6)
* set_output/1 (built-in) <1>:           ref-iou-sfh-opn.     (line  37)
* set_output/1 (built-in, ref page):     mpg-ref-set_output.  (line   6)
* set_prolog_flag/2 (built-in, ref page): mpg-ref-set_prolog_flag.
                                                              (line   6)
* set_stream_position/2 (built-in):      ref-iou-raf.         (line   6)
* set_stream_position/2 (built-in, ref page): mpg-ref-set_stream_position.
                                                              (line   6)
* shorter_list/2 (lists):                lib-lists.           (line 217)
* shutdown/[0,1] (prologbeans):          PB Prolog Server Interface.
                                                              (line  55)
* shutdown_server/0 (linda_client):      lib-linda-client.    (line  34)
* simple/1 (built-in, ref page):         mpg-ref-simple.      (line   6)
* singleton_queue/2 (queues):            lib-queues.          (line  28)
* size_bound/2 (terms):                  lib-terms.           (line 264)
* skewness/2 (statistics):               lib-statistics.      (line  57)
* skip_byte/[1,2] (built-in):            ref-iou-cin-ski.     (line   9)
* skip_byte/[1,2] (built-in, ref page):  mpg-ref-skip_byte.   (line   6)
* skip_char/[1,2] (built-in):            ref-iou-cin-ski.     (line  17)
* skip_char/[1,2] (built-in, ref page):  mpg-ref-skip_char.   (line   6)
* skip_code/[1,2] (built-in):            ref-iou-cin-ski.     (line  13)
* skip_code/[1,2] (built-in, ref page):  mpg-ref-skip_code.   (line   6)
* skip_line/[0,1] (built-in):            ref-iou-cin-ski.     (line  21)
* skip_line/[0,1] (built-in, ref page):  mpg-ref-skip_line.   (line   6)
* sleep/1 (system):                      lib-system.          (line  26)
* smt/1 (clpfd):                         Arithmetic-Logical Constraints.
                                                              (line   8)
* socket_client_open/3 (sockets):        lib-sockets.         (line  55)
* socket_select/7 (sockets):             lib-sockets.         (line 142)
* socket_server_accept/4 (sockets):      lib-sockets.         (line 129)
* socket_server_close/1 (sockets):       lib-sockets.         (line 138)
* socket_server_open/[2,3] (sockets):    lib-sockets.         (line  88)
* solve/2 (clpfd):                       Enumeration Predicates.
                                                              (line 318)
* some/[2,3,4] (lists):                  lib-lists.           (line 540)
* somebag/2 (bags):                      lib-bags.            (line  70)
* somechk/[2,3,4] (lists):               lib-lists.           (line 555)
* somechkbag/2 (bags):                   lib-bags.            (line  75)
* somechk_queue/[2,3] (queues):          lib-queues.          (line 140)
* some_queue/[2,3] (queues):             lib-queues.          (line 130)
* sort/2 (built-in):                     ref-lte-cte-sor.     (line   6)
* sort/2 (built-in, ref page):           mpg-ref-sort.        (line   6)
* sorting/3 (clpfd):                     Arithmetic-Logical Constraints.
                                                              (line 257)
* source_file/[1,2] (built-in):          ref-lps-apf.         (line   6)
* source_file/[1,2] (built-in, ref page): mpg-ref-source_file.
                                                              (line   6)
* spy/[1,2] (built-in):                  Plain Spypoint.      (line  29)
* spy/[1,2] (built-in) <1>:              Breakpoint Predicates.
                                                              (line  54)
* spy/[1,2] (built-in, ref page):        mpg-ref-spy.         (line   6)
* start/[0,1] (prologbeans):             PB Prolog Server Interface.
                                                              (line  15)
* statistics/[0,2] (built-in):           ref-mgc-ove-sta.     (line   6)
* statistics/[0,2] (built-in) <1>:       ref-mgc-gcp.         (line   6)
* statistics/[0,2] (built-in, ref page): mpg-ref-statistics.  (line   6)
* store_slot/2 (objects):                obj-exp-store_slot.  (line   6)
* stream_code/2 (built-in):              ref-iou-sfh-sob.     (line  37)
* stream_code/2 (built-in) <1>:          Prolog Streams.      (line  11)
* stream_code/2 (built-in, ref page):    mpg-ref-stream_code. (line   6)
* stream_position/2 (built-in):          ref-iou-raf.         (line   6)
* stream_position/2 (built-in, ref page): mpg-ref-stream_position.
                                                              (line   6)
* stream_position_data/3 (built-in, ref page): mpg-ref-stream_position_data.
                                                              (line   6)
* stream_property/2 (built-in):          ref-iou-sfh-bos.     (line  15)
* stream_property/2 (built-in, ref page): mpg-ref-stream_property.
                                                              (line   6)
* subcircuit/[1,2] (clpfd):              Graph Constraints.   (line  25)
* sublist/[3,4,5] (lists):               lib-lists.           (line 343)
* subseq/3 (lists):                      lib-lists.           (line 226)
* subseq0/2 (lists):                     lib-lists.           (line 236)
* subseq1/2 (lists):                     lib-lists.           (line 247)
* subset/2 (sets):                       lib-sets.            (line  52)
* subsumes/2 (terms):                    lib-terms.           (line  19)
* subsumeschk/2 (terms):                 lib-terms.           (line  11)
* subsumes_term/2 (built-in):            ref-lte-met-usu.     (line  40)
* subsumes_term/2 (built-in, ref page):  mpg-ref-subsumes_term.
                                                              (line   6)
* subtract/3 (sets):                     lib-sets.            (line 113)
* sub_atom/5 (built-in):                 ref-lte-atm.         (line  16)
* sub_atom/5 (built-in, ref page):       mpg-ref-sub_atom.    (line   6)
* sub_term/2 (terms):                    lib-terms.           (line 247)
* suffix/2 (lists):                      lib-lists.           (line 383)
* suffix_length/3 (lists):               lib-lists.           (line 304)
* sum/3 (clpfd):                         Arithmetic Constraints.
                                                              (line  37)
* sumlist/2 (lists):                     lib-lists.           (line 252)
* sup/[2,4] (clpqr):                     CLPQR Solver Predicates.
                                                              (line  96)
* symdiff/3 (sets):                      lib-sets.            (line 126)
* symmetric_all_different/1 (clpfd):     Arithmetic-Logical Constraints.
                                                              (line 218)
* symmetric_all_distinct/1 (clpfd):      Arithmetic-Logical Constraints.
                                                              (line 218)
* symmetric_closure/2 (ugraphs):         lib-ugraphs.         (line 102)
* symmetric_closure/2 (wgraphs):         lib-wgraphs.         (line  99)
* table/[2,3] (clpfd):                   Extensional Constraints.
                                                              (line  41)
* tail/2 (lists):                        lib-lists.           (line 366)
* taut/2 (clpb):                         CLPB Interface.      (line  21)
* tcl_delete/1 (tcltk):                  Basic Functions.     (line  67)
* tcl_delete/1 (tcltk) <1>:              Predicates for Prolog to Interact with Tcl Interpreters.
                                                              (line  10)
* tcl_eval/3 (tcltk):                    Evaluation Functions.
                                                              (line 118)
* tcl_eval/3 (tcltk) <1>:                Predicates for Prolog to Interact with Tcl Interpreters.
                                                              (line  14)
* tcl_event/3 (tcltk):                   Event Functions.     (line   9)
* tcl_event/3 (tcltk) <1>:               Predicates for Prolog to Interact with Tcl Interpreters.
                                                              (line  19)
* tcl_new/1 (tcltk):                     Basic Functions.     (line  10)
* tcl_new/1 (tcltk) <1>:                 Predicates for Prolog to Interact with Tcl Interpreters.
                                                              (line   6)
* tell/1 (built-in):                     ref-iou-sfh-opn.     (line  60)
* tell/1 (built-in, ref page):           mpg-ref-tell.        (line   6)
* telling/1 (built-in):                  ref-iou-sfh-cos.     (line  15)
* telling/1 (built-in, ref page):        mpg-ref-telling.     (line   6)
* term_depth/2 (terms):                  lib-terms.           (line 270)
* term_expansion/6 (hook, ref page):     mpg-ref-term_expansion.
                                                              (line   6)
* term_expansion/6 (user, hook):         ref-lod-exp.         (line  12)
* term_hash/[2,3,4] (terms):             lib-terms.           (line  40)
* term_order/3 (terms):                  lib-terms.           (line 202)
* term_size/2 (terms):                   lib-terms.           (line 287)
* term_subsumer/3 (terms):               lib-terms.           (line  35)
* term_variables/2 (built-in):           ref-lte-act.         (line  22)
* term_variables/2 (built-in, ref page): mpg-ref-term_variables.
                                                              (line   6)
* term_variables/3 (aggregate):          lib-aggregate.       (line 163)
* term_variables_bag/2 (terms):          lib-terms.           (line 188)
* term_variables_set/2 (terms):          lib-terms.           (line 180)
* test/[1,2] (plunit declaration):       PlUnit A Unit Test Box.
                                                              (line  18)
* test_sub_bag/2 (bags):                 lib-bags.            (line 170)
* throw/1 (built-in):                    ref-ere-rex.         (line   6)
* throw/1 (built-in, ref page):          mpg-ref-throw.       (line   6)
* throws/1 (plunit option):              PlUnit A Unit Test Box.
                                                              (line 201)
* time_out/3 (timeout):                  lib-timeout.         (line  17)
* tk_destroy_window/1 (tcltk):           Housekeeping.        (line  19)
* tk_destroy_window/1 (tcltk) <1>:       Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  74)
* tk_do_one_event/[0,1] (tcltk):         Servicing Tk Events. (line  51)
* tk_do_one_event/[0,1] (tcltk) <1>:     Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  29)
* tk_main_loop/0 (tcltk):                Passing Control to Tk.
                                                              (line  10)
* tk_main_loop/0 (tcltk) <1>:            Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  66)
* tk_main_window/2 (tcltk):              Housekeeping.        (line  12)
* tk_main_window/2 (tcltk) <1>:          Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  70)
* tk_make_window_exist/1 (tcltk):        Housekeeping.        (line  26)
* tk_make_window_exist/1 (tcltk) <1>:    Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  77)
* tk_new/2 (tcltk):                      Basic Functions.     (line  20)
* tk_new/2 (tcltk) <1>:                  Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line   6)
* tk_next_event/[2,3] (tcltk):           Event Functions.     (line  35)
* tk_next_event/[2,3] (tcltk) <1>:       Servicing Tk Events. (line 108)
* tk_next_event/[2,3] (tcltk) <2>:       Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  59)
* tk_num_main_windows/1 (tcltk):         Housekeeping.        (line  38)
* tk_num_main_windows/1 (tcltk) <1>:     Predicates for Prolog to Interact with Tcl Interpreters with Tk Extensions.
                                                              (line  80)
* told/0 (built-in):                     ref-iou-sfh-cst.     (line  26)
* told/0 (built-in, ref page):           mpg-ref-told.        (line   6)
* top_sort/2 (ugraphs):                  lib-ugraphs.         (line 116)
* top_sort/2 (wgraphs):                  lib-wgraphs.         (line 105)
* trace/0 (built-in):                    Basic Debug.         (line  31)
* trace/0 (built-in, ref page):          mpg-ref-trace.       (line   6)
* transitive_closure/2 (ugraphs):        lib-ugraphs.         (line  90)
* transitive_closure/2 (wgraphs):        lib-wgraphs.         (line  94)
* transitive_reduction/2 (ugraphs):      lib-ugraphs.         (line  93)
* transpose/2 (lists):                   lib-lists.           (line 262)
* transpose_ugraph/2 (ugraphs):          lib-ugraphs.         (line  71)
* transpose_wgraph/2 (wgraphs):          lib-wgraphs.         (line  89)
* tree_size/2 (trees):                   lib-trees.           (line  45)
* tree_to_list/2 (trees):                lib-trees.           (line  49)
* trimcore/0 (built-in):                 ref-mgc-ove-rsp.     (line   6)
* trimcore/0 (built-in, ref page):       mpg-ref-trimcore.    (line   6)
* true/0 (built-in, ref page):           mpg-ref-true.        (line   6)
* true/0 (plunit option):                PlUnit A Unit Test Box.
                                                              (line 140)
* true/1 (plunit option):                PlUnit A Unit Test Box.
                                                              (line 140)
* type_definition/[2,3] (structs):       str-etr.             (line  11)
* ugraph_to_wgraph/2 (wgraphs):          lib-wgraphs.         (line  50)
* ugraph_to_wgraph/3 (wgraphs):          lib-wgraphs.         (line  64)
* unbiased_standard_deviation/2 (statistics): lib-statistics. (line  96)
* unbiased_variance/2 (statistics):      lib-statistics.      (line  79)
* undefine_method/3 (objects):           obj-exp-undefine_method.
                                                              (line   6)
* unify_with_occurs_check/2 (built-in):  ref-lte-met-usu.     (line  20)
* unify_with_occurs_check/2 (built-in, ref page): mpg-ref-unify_with_occurs_check.
                                                              (line   6)
* uninherit/1 (objects):                 obj-exp-uninherit.   (line   6)
* union/[2,3,4] (sets):                  lib-sets.            (line 160)
* unknown/2 (built-in):                  Undefined Predicates.
                                                              (line  21)
* unknown/2 (built-in) <1>:              ref-ere-hex-hup.     (line  46)
* unknown/2 (built-in, ref page):        mpg-ref-unknown.     (line   6)
* unknown_predicate_handler/3 (hook, ref page): mpg-ref-unknown_predicate_handler.
                                                              (line   6)
* unknown_predicate_handler/3 (user, hook): Undefined Predicates.
                                                              (line   6)
* unknown_predicate_handler/3 (user, hook) <1>: ref-ere-hex-hup.
                                                              (line   6)
* unload_foreign_resource/1 (built-in):  Interface Predicates.
                                                              (line  24)
* unload_foreign_resource/1 (built-in, ref page): mpg-ref-unload_foreign_resource.
                                                              (line   6)
* unregister_event_listener/1 (prologbeans): PB Prolog Server Interface.
                                                              (line 169)
* unregister_query/1 (prologbeans):      PB Prolog Server Interface.
                                                              (line 105)
* update_mutable/2 (built-in):           ref-lte-mut.         (line  43)
* update_mutable/2 (built-in, ref page): mpg-ref-update_mutable.
                                                              (line   6)
* user:breakpoint_expansion/2 (hook):    Hooks Related to Breakpoints.
                                                              (line   8)
* user:breakpoint_expansion/2 (hook) <1>: Condition Macros.   (line  22)
* user:debugger_command_hook/2 (hook):   Hooks Related to Breakpoints.
                                                              (line  73)
* user:debugger_command_hook/2 (hook) <1>: Breakpoint Predicates.
                                                              (line 118)
* user:error_exception/1 (hook):         ref-ere-hex.         (line  24)
* user:error_exception/1 (hook) <1>:     Exceptions Debug.    (line  16)
* user:file_search_path/2 (hook):        ref-fdi-fsp-def.     (line   6)
* user:generate_message_hook/3 (hook):   Message Handling Predicates.
                                                              (line  19)
* user:message_hook/3 (hook):            Message Handling Predicates.
                                                              (line  30)
* user:portray/1 (hook):                 ref-iou-tou-por.     (line   6)
* user:portray/1 (hook) <1>:             CLPQR Fragments and Bits.
                                                              (line  12)
* user:portray_message/2 (hook):         Message Handling Predicates.
                                                              (line  14)
* user:query_class_hook/5 (hook):        Query Handling Predicates.
                                                              (line  23)
* user:query_hook/6 (hook):              Query Handling Predicates.
                                                              (line  16)
* user:query_input_hook/3 (hook):        Query Handling Predicates.
                                                              (line  39)
* user:query_map_hook/4 (hook):          Query Handling Predicates.
                                                              (line  51)
* user:runtime_entry/1 (hook):           too-spld.            (line  74)
* user:term_expansion/6 (hook):          ref-lod-exp.         (line  12)
* user:unknown_predicate_handler/3 (hook): Undefined Predicates.
                                                              (line   6)
* user:unknown_predicate_handler/3 (hook) <1>: ref-ere-hex-hup.
                                                              (line   6)
* use_module/[1,2,3] (built-in):         ref-mod-lod.         (line  27)
* use_module/[1,2,3] (built-in, ref page): mpg-ref-use_module.
                                                              (line   6)
* value_precede_chain/[2,3] (clpfd):     Sequence Constraints.
                                                              (line 404)
* var/1 (built-in, ref page):            mpg-ref-var.         (line   6)
* variant/2 (terms):                     lib-terms.           (line  31)
* varnumbers/[2,3] (varnumbers):         lib-varnumbers.      (line  44)
* verify_attributes/3 (Module):          lib-atts.            (line  71)
* vertices/2 (ugraphs):                  lib-ugraphs.         (line  35)
* vertices/2 (wgraphs):                  lib-wgraphs.         (line  34)
* vertices_edges_to_ugraph/3 (ugraphs):  lib-ugraphs.         (line  28)
* vertices_edges_to_wgraph/3 (wgraphs):  lib-wgraphs.         (line  69)
* view/0 (gauge):                        lib-gauge.           (line  16)
* volatile/1 (built-in, ref page):       mpg-ref-volatile.    (line   6)
* volatile/1 (declaration):              Volatile Declarations.
                                                              (line   6)
* weighted_mean/3 (statistics):          lib-statistics.      (line  42)
* weighted_standard_deviation/3 (statistics): lib-statistics. (line 102)
* weighted_variance/3 (statistics):      lib-statistics.      (line  84)
* wgraph_to_ugraph/2 (wgraphs):          lib-wgraphs.         (line  37)
* when/2 (built-in, ref page):           mpg-ref-when.        (line   6)
* with_output_to_codes/[2,3,4] (codesio): lib-codesio.        (line  53)
* write/[1,2] (built-in):                ref-iou-tou-wrt.     (line   6)
* write/[1,2] (built-in, ref page):      mpg-ref-write.       (line   6)
* writeq/[1,2] (built-in):               ref-iou-tou-wrt.     (line   6)
* writeq/[1,2] (built-in, ref page):     mpg-ref-writeq.      (line   6)
* write_canonical/[1,2] (built-in):      ref-iou-tou-wrt.     (line   6)
* write_canonical/[1,2] (built-in, ref page): mpg-ref-write_canonical.
                                                              (line   6)
* write_record/[1,2] (csv):              lib-csv.             (line 119)
* write_records/[1,2] (csv):             lib-csv.             (line 124)
* write_record_to_codes/2 (csv):         lib-csv.             (line 128)
* write_term/[2,3] (built-in):           ref-iou-tou-wrt.     (line   6)
* write_term/[2,3] (built-in, ref page): mpg-ref-write_term.  (line   6)
* write_term_to_codes/[3,4] (codesio):   lib-codesio.         (line  28)
* write_to_codes/[2,3] (codesio):        lib-codesio.         (line  21)
* xml_parse/[2,3] (xml):                 lib-xml.             (line  69)
* xml_pp/1 (xml):                        lib-xml.             (line  98)
* xml_subterm/2 (xml):                   lib-xml.             (line  92)
* zip/0 (built-in):                      Basic Debug.         (line  25)
* zip/0 (built-in, ref page):            mpg-ref-zip.         (line   6)

