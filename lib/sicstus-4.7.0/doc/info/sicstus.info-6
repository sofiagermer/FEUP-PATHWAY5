This is sicstus.info, produced by makeinfo version 6.5 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated July 7, 2021.


File: sicstus.info,  Node: obj-inh,  Next: obj-tcl,  Prev: obj-scl,  Up: lib-objects

10.29.3 Inheritance
-------------------

* Menu:

* obj-inh-sih::                         Single Inheritance
* obj-inh-mih::                         Multiple Inheritance
* obj-inh-ask::                         Asking About Classes and Objects

This section describes the additional features (and the additional
complexity) of defining classes with inheritance in SICStus Objects.
Most of what was said about classes in the previous section remains true
in these examples.


File: sicstus.info,  Node: obj-inh-sih,  Next: obj-inh-mih,  Up: obj-inh

10.29.3.1 Single Inheritance
............................

The simplest case is when a new class inherits some properties (slots
and methods) from a single superclass.  That superclass may, in turn, be
defined in terms of its superclass, etc.  The new class, its superclass,
its superclass's superclass (if any) and so on are all ancestors of the
new class.

Class Definitions
-----------------

The definition of a class with a single superclass begins with a
'class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] +  SUPERCLASS.

where the list of SLOTDEF descriptions may be empty.  In that case, the
definition can simplified to

     :- class CLASSNAME = SUPERCLASS.

   The class SUPERCLASS must be a defined class when this definition is
given.

   In SICStus Objects, a subclass inherits all the slots of its
superclass.  And, by default, it inherits all the methods of its
superclass.  The remainder of this section describes what the programmer
can do to control this inheritance.

Slots
-----

A class's slots are a combination of those explicitly defined in its
slot description list and the slots it inherits from its superclass.  In
SICStus Objects, a class inherits all the slots of its superclass.  It
follows that a class inherits all the slots of all its ancestors.

   The programmer's control over inheritance of slots is limited.  It is
not possible to rename an inherited slot, nor is it possible to change
its type, unless it is a class slot.  It is possible to change a slot's
initial value.  And, it is possible to effectively change a slot's
visibility.

   To change the initial value or the type (when allowed) of a slot,
include a new SLOTDEF in the list of slot descriptions for the class,
with the same slot name and a new type or initial value.  The type of a
class slot can only be changed to a subclass of the type of the
superclass's slot.  The new initial value must still be a constant of
the appropriate type.

   The 'named_point' class, defined earlier, could have better been
defined from the point class, which began as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   The definition of the 'named_point' class would then begin with

     :- class named_point =
             [public name:atom,
              public x:float=1.0] + point.

   This 'named_point' class has public slots named 'name', 'x' and 'y',
with the same types and initial values as the earlier 'named_point'
definition, which did not use inheritance.  This 'named_point' class
also inherits all the methods of the 'point' class, which saves us from
having to write them again (and maintain them).

   A slot that was private or protected in a superclass may be defined
as public.  This will cause get and put methods to be generated in the
subclass.  A slot that was public in a superclass may be defined as
protected or private, but this does not prevent it from inheriting the
get and put methods of the superclass.  For that, the 'uninherit/1'
directive, defined below, is needed.

Methods
-------

In SICStus Objects, by default, a class inherits all the methods of its
superclass.  The programmer has more control over the inheritance of
methods than the inheritance of slots, however.  In particular, methods
can be uninherited and they can be redefined.

   To prevent a method from being inherited, use the 'uninherit/1'
directive.  For example, suppose that the class 'point' is defined as
before.  That is, its definition begins as follows:

     :- class point =
             [public x:float=0,
              public y:float=0].

   Because both slots are public, a put method is automatically
generated for each, which allows their values to be changed.

   The definition of a new class 'fixed_point' might begin as follows:

     :- class fixed_point = point.

     :- uninherit
             point << (x/l),
             point << (y/l).

     Self <- create(X, Y) :-
             store_slot(x, X),
             store_slot(y, Y).

   The parentheses are necessary because of the precedences of the '<<'
and '/' operators.

   Because the put methods from 'point' are not inherited, no instance
of the 'fixed_point' class can change its 'x' and 'y' values once
created--unless the class definition contains another method for doing
so.  The get methods are inherited from 'point', however.

   To redefine a method, simply include method clauses for its message
within a class's definition.  The new method clauses replace, or shadow,
the inherited method clauses for this class.

   Another way to prevent the 'x' and 'y' slots of the 'fixed_point'
class from being modified would be to shadow the put methods.  For
example, they might be redefined as

     Self << x(_) :-
             format(user_error, "cannot modify x slot value.~n.", []),
             fail.

     Self << y(_) :-
             format(user_error, "cannot modify y slot value.~n", []),
             fail.

   Now attempts to modify the 'x' or 'y' values of a fixed point object
generate a specific error message and fail.  A more complicated version
would raise an appropriate exception.

Send Super
----------

Even when a superclass's method is shadowed or uninherited, it is
possible to use the superclass's method inside a method clause for the
new class.  This makes it possible to define a "wrapper" for the
superclass's method, which invokes the superclass's method without
having to duplicate its code.  This technique works with all message
types.

   Sending a message to a superclass is done with a command of the form

     super MESSAGEOP MESSAGE

where MESSAGEOP is one of the message operators ('<<', '>>' or '<-') and
MESSAGE is a message defined for the superclass.  A generalization of
this syntax may be used to specify which superclass to send the message
to.  This is discussed in *note obj-inh-mih::.

   Sending a message to a class's superclass can only be done within a
message clause.


File: sicstus.info,  Node: obj-inh-mih,  Next: obj-inh-ask,  Prev: obj-inh-sih,  Up: obj-inh

10.29.3.2 Multiple Inheritance
..............................

It is possible for a class to be defined with more than one superclass.
Because the class inherits properties from multiple superclasses, this
is referred to as multiple inheritance.

   Multiple inheritance is a complex and controversial topic.  What
should be done about conflicting slot or method definitions?  (This is
sometimes called a "name clash.")  What should be done about slots that
are inherited from two or more superclasses, but that originate with a
common ancestor class?  (This is sometimes called "repeated
inheritance".)  Different systems take different approaches.

   SICStus Objects supports multiple inheritance in a limited but still
useful way.  It does not allow repeated inheritance, and it places all
the responsibility for resolving name clashes on the programmer.  This
section describes the multiple inheritance features of SICStus Objects.

Class Definitions
-----------------

The definition of a class with multiple superclasses begins with a
'class/1' directive of the form

     :- class CLASSNAME = [SLOTDEF, ...] + SUPERCLASS + ....

   The list of slot descriptions and the superclasses to the right of
the '=' can appear in any order, without changing the class being
defined.  In fact, the slot descriptions can be partitioned into more
than one list, without changing the class.  However, it is best to adopt
a fairly simple style of writing class definition and use it
consistently.

   Just as the slot names in a list of slot descriptions must be
distinct, superclass names should not be repeated.

Slots
-----

In SICStus Objects, the programmer has no control over multiple
inheritance of slots.  All slots from all superclasses are inherited.
And, the superclasses should have no slot names in common.

   As a consequence, in SICStus Objects no superclasses of a class
should have a common ancestor.  The only exception would be the unusual
case where that common ancestor has no slots.

Methods
-------

By default, all methods are inherited from all superclasses.  Any of the
superclasses' methods can be uninherited, as described earlier, by using
the 'uninherit/1' directive.

   If the same message is defined for more than one superclass, however,
then you must choose at most one method to inherit for the message.  You
may choose none.  You may do this by defining a new method for the
message (shadowing the superclasses' methods), or by using the
'uninherit/1' directive, or by using the 'inherit/1' directive.

   The following is considered a classic example of multiple
inheritance.

     :- class toy.             % no slots in this class

     Self >> size(small).

     Self >> rolls(false).

     :- end_class toy.

     :- class truck.         % no slots in this class

     Self >> size(large).

     Self >> rolls(true).

     :- end_class truck.

   The idea expressed in these definitions is that most toys are small
and do not roll.  On the other hand, most trucks are large, but they do
roll.  A toy truck shares one feature with each class, but we can hardly
expect a compiler to choose the correct one.

   The definition of a new class, toy_truck, might begin with

     :- class toy_truck = toy + truck.

   Rather than redefine the get methods for 'size' and 'rolls', we can
specify which to inherit in two ways.  One way is positive, stating
which to inherit, and the other way is negative, stating which not to
inherit.

   The positive version would be

     :- inherit
             toy >> (size/1),
             truck >> (rolls/1).

   This is more convenient when a message is defined in several
superclasses, because all but the chosen method are uninherited.  And,
it is probably easier to understand.

   The negative version would be

     :- uninherit
             toy >> (rolls/1),
             truck >> (size/1).

   The 'toy_truck' class would exhibit the same behavior with either
definition.

   It is possible to define methods that access the shadowed or
uninherited methods of the superclasses, by sending the message to the
superclasses.  In the case of multiple inheritance, however, it may be
necessary to specify which superclass to send the message to.

   The 'toy_truck' class, for example, might define these methods:

     Self >> uninherited_size(S) :-
             super(truck) >> size(S).

     Self >> uninherited_rolls(R) :-
             super(toy) >> rolls(R).

   They provide access to the unchosen methods from 'toy_truck''s
superclasses.

   While these examples with the toy_truck class are clearly "toy"
examples, the same techniques can be used in more realistic cases.

Abstract and Mixin Classes
--------------------------

While SICStus Objects only supports a limited form of multiple
inheritance, its facilities are sufficient for working with so-called
"mixin classes".

   The idea is to construct similar classes by first defining a class
that contains the things the desired classes have in common.  Typically,
this will be an "abstract class", which will have no instances itself.
Then, provide the features that differentiate the desired classes with a
set of mixin classes

   Mixin classes that have nothing in common can safely be mixed
together, to build the desired classes.  The mixin classes will usually
be abstract classes, also, because they are too specialized for their
instances to be useful on their own.

   The date_stamp class defined earlier would make a good mixin class.
A similar 'time_stamp' class might be (partially) defined as follows:

     :- class time_stamp =
             [hour:integer,
              minute:integer,
              second:integer].

     Self <- create :-
             time(time(Hour, Minute, Second)),
             store_slot(hour, Hour),
             store_slot(minute, Minute),
             store_slot(second, Second).

   Another mixin class might be used to "register" objects in the Prolog
database.

     :- class registry = [name:atom].

     Self <- create(Name) :-
             Self << name(Name),
             assert(registered(Name, Self)).

     Self <- destroy :-
             Self >> name(Name),
             retract(registered(Name, Self)).

   The 'registry' mixin class could have been used with the 'point'
class to define the 'named_point' class, which was an example from an
earlier section.

   The ability to send a message to an object's superclass is useful
when working with mixin classes.  Suppose the definition of a new class
begins with

     :- NEWCLASS = OLDCLASS + date + time + registry.

where OLDCLASS is some previously defined class that lacks the features
provided by the 'date', 'time' and 'registry' classes.  (In fact, they
should not have any slot names in common.)  Then its create method can
be defined by

     Self <- create(Name) :-
             super(OldClass) <- create,
             super(date) <- create,
             super(time) <- create,
             super(registry) <- create(Name).

   This avoids the need to duplicate the code in the create methods of
OldClass and all three mixin classes.


File: sicstus.info,  Node: obj-inh-ask,  Prev: obj-inh-mih,  Up: obj-inh

10.29.3.3 Asking About Classes and Objects
..........................................

It is possible to determine, at run time, what classes are defined, how
they are related by inheritance, what class an object belongs to, etc.
This section describes the predicates used for those purposes.  Most of
the predicates involve the class hierarchy, so they are properly
described in the section on inheritance.  But, several can be useful
even in programs that use only simple classes.

   Most of these predicates come in pairs, where one predicate involves
one class or its direct superclasses, and the other predicate involves
all ancestors.  For example, the 'class_superclass/2' and
'class_ancestor/2' predicates connect a currently defined class to its
superclass(es) and to all its ancestors, respectively.

   In all of these predicates, the ancestors of a class include not only
superclasses and their ancestors, but also the class itself.  A class
cannot be a superclass of itself, by the rules of defining classes.
However, it is convenient to consider every class an ancestor of itself,
because then we may say that every property of a class is defined in one
of its ancestors, without having to say "the class itself or a
superclass or a superclass of a superclass, etc."

Objects
-------

The 'class_of/2' predicate is used to test whether an object is of a
particular type or to determine the type of an object.  Similarly, the
'descendant_of/2' predicate relates an object to all ancestors of its
class.  (Remember that the object's class is, itself, an ancestor class
of the object.)

   Both require the first argument (the object) to be instantiated.
That is, the predicates cannot be used to find objects of a given class.
If you need to search among all the objects of a class, then you must
provide a way to do it.  One way to do this is to assert a fact
connecting the class name to every object, when it is created.  The
named_point example of the previous section took that idea a step
further by allowing each object to have a different name.

   The 'pointer_object/2' predicate relates an object's address (a
pointer) to the object.  Remember that an instance of CLASS is
represented by a term of the form

     CLASS(ADDRESS)

   The 'pointer_object/2' predicate requires that one of its arguments
be instantiated, but it may be either one.  Hence, just by knowing the
address of an object (which possibly was returned by a foreign function)
it is possible to determine the object's type.

   Most Prolog programmers can safely ignore the 'pointer_object/2'
predicate, unless they are using SICStus Objects with foreign functions
or with the Structs package.

Classes
-------

The 'current_class/1' predicate is used to ask whether a class is
currently defined or to get the names of all currently defined classes.

   The 'class_superclass/2' predicate is used to test whether one class
is a superclass of another, or to find a class's superclasses, or to
find a class's subclasses, or to find all subclass-superclass pairs.
The 'class_ancestor/2' predicate is used in the same ways for the
ancestor relation between currently defined classes.

   As an example, the following goal finds all the ancestors of each
currently defined class.

     | ?- setof(C-As,
     	   (current_class(C),
     	    setof(A, class_ancestor(C,A), As)),
     	   L).

   It binds 'L' to a list of terms of the form CLASS-ANCESTORLIST, with
one term for each currently defined class.

   Arguably, this predicate violates the principle of information
hiding, by letting you ask about how a class is defined.  Therefore, you
should generally avoid it.  It may be useful, however, in debugging and
in building programmer support tools.

Messages
--------

The 'message/4' predicate is used to ask whether a message is defined
for a class or to find what messages are defined for a class, etc.  It
does not distinguish between messages whose methods are defined in the
class itself and those that are inherited from a superclass.

   The 'direct_message/4' predicate is used to ask whether a message is
not only defined for a class, but whether the method for that message is
defined in the class itself.  It can also be used to determine which
methods are defined in a class.  This ability to look inside a class
definition makes 'direct_message/4' an egregious violator of the
principle of information hiding.  Thus it, like 'class_ancestor/2',
should mainly be confined to use in programmer support applications.

   Both 'message/4' and 'direct_message/4' take the message operator as
an argument, along with the class, message name and arity.  Hence it is
possible to use these predicates to ask about get, put or send messages.

   It is not possible to ask about a class's slots, nor should it be.
However, it is possible (and quite reasonable) to ask about the get and
put messages that are defined for a class.  For example, the following
goal finds all the 1-argument messages that are defined for both the get
and put message operators in the class CLASS.

     | ?- setof(Message,
     	   (message(CLASS, <<, Msg, 1),
     	    message(CLASS, >>, Msg, 1)),
     	   L).

   There may or may not be slots corresponding to these messages; that
detail is hidden in the definition of CLASS.  However, it should be
possible to use CLASS as if the slots were there.

   As an example, recall the polar coordinate interface to the point
class, which defined get and put methods for 'r' and 'theta', even
though data was represented inside an object by rectangular coordinates
'x' and 'y'.


File: sicstus.info,  Node: obj-tcl,  Next: obj-tech,  Prev: obj-inh,  Up: lib-objects

10.29.4 Term Classes
--------------------

* Menu:

* obj-tcl-stcl::                        Simple Term Classes
* obj-tcl-rtrm::                        Restricted Term Classes
* obj-tcl-tce::                         Specifying a Term Class Essence

Sometimes it is convenient to be able to send messages to ordinary
Prolog terms as if they were objects.  Prolog terms are easier to create
than objects, and unlike objects, they are automatically garbage
collected (see *note obj-tech-lim::).  Of course, unlike objects, Prolog
terms cannot be modified.  However, when a particular class of objects
never needs to be dynamically modified, and does not need to be
subclassed, it may be appropriate to define it as a "term class".

   A term class is defined much like an ordinary class: it begins with a
':- class' directive defining the class and its slots, follows with
clauses defining the methods for this class, and ends with an ':-
end_class' directive, the end of the file, or another ':- class'
directive.  The only difference is in the form of the ':- class'
directive introducing a term class definition.


File: sicstus.info,  Node: obj-tcl-stcl,  Next: obj-tcl-rtrm,  Up: obj-tcl

10.29.4.1 Simple Term Classes
.............................

The simplest sort of term class declaration has the following form:
     :- class CLASSNAME = term(TERM).

   This declares that any term that unifies with TERM is an instance of
class CLASSNAME.  For example, you might declare:
     :- class rgb_color = term(color(_Red,_Green,_Blue)).

     color(R,_G,_B) >> red(R).
     color(_R,G,_B) >> green(G).
     color(_R,_G,B) >> blue(B).

     :- end_class rgb_color.

   This would declare any term whose principal functor is 'color' and
arity is three to be an object of class 'rgb_color'.  Given this
declaration, entering the goal
     color(0.5, 0.1, 0.6) >> blue(B)

would bind 'B' to 0.6.

   Note that you cannot use 'create/2' to create a term class instance.
Since they are just ordinary terms, you can create them the same way you
would create any ordinary Prolog term.  Similarly, you cannot modify an
existing term class instance.

   You may specify a term class as the type of a slot of an ordinary
class.  This is effectively the same as specifying the type to be
'term'.  In particular, fetching and storing term class slots is not
very efficient.  Also, the default value for slots of term class type is
''''; this is because not enough is known about a simple term class to
determine a better default.  For an explanation of how to avoid these
pitfalls, see *note obj-tcl-tce::.


File: sicstus.info,  Node: obj-tcl-rtrm,  Next: obj-tcl-tce,  Prev: obj-tcl-stcl,  Up: obj-tcl

10.29.4.2 Restricted Term Classes
.................................

The intention of the 'rgb_color' class presented above is to represent a
color as a triple of floating point numbers between 0.0 and 1.0.  But
the above definition does not restrict the arguments of the 'color' term
in any way: _any_ 'color/3' term is considered to be an instance of the
'rgb_color' class.

   The second form of term class declaration allows you to specify
constraints on instances of a term class.  The form of such a
declaration is as follows:
     :- class CLASSNAME = term(TERM, CONSTRAINT).

   This declares that any term that unifies with TERM and satisfies
CONSTRAINT is an instance of class CLASSNAME.  The CONSTRAINT term is an
ordinary Prolog goal, which will usually share variables with TERM.

   To extend our 'rgb_color' class example so that only 'color/3' terms
whose arguments are all floats between 0.0 and 1.0 are instances of
'rgb_color', we would instead begin the definition as follows:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0)).

   Note the parentheses around the constraint in this example.  Whenever
the constraint contains multiple goals separated by commas, you will
need to surround the goal with parentheses.

   With this definition of the 'rgb_color' class, only 'color/3' terms
whose arguments are all floating point numbers between 0 and 1 inclusive
will be considered to be instances of 'rgb_color'.


File: sicstus.info,  Node: obj-tcl-tce,  Prev: obj-tcl-rtrm,  Up: obj-tcl

10.29.4.3 Specifying a Term Class Essence
.........................................

As mentioned above, it is possible to specify a term class as the type
of a slot of some other object.  For example, we might declare

     :- class colored_rectangle = [
             public origin:point,
             public size:size,
             public color:rgb_color].

   This will store an 'rgb_color' object (i.e., a 'color/3' term) in the
'color' slot of each 'colored_rectangle' object.  Unfortunately, though,
SICStus Objects cannot tell what is the best way to store a term object,
and therefore it stores it the same way it stores a slot declared to be
of 'term' type: using the Prolog database.  This has all the efficiency
disadvantages of 'term' slots.  In this case, however, we know that all
that really needs to be saved in order to save an 'rgb_color' object is
the three arguments.  We also know that each of these arguments is a
floating point number, and because precision is not terribly critical in
representing colors, each of these numbers can be stored as a 'float',
rather than a 'double'.  In effect, we know that the _essence_ of a
'rgb_color' object is these three numbers; if we have them, then we can
easily construct the 'color/3' term.  If we provide this information in
the declaration of the 'rgb_color' class, then SICStus Objects can store
instances of the 'rgb_color' class as 3 separate floats, rather than as
a term, significantly improving the performance of creating or
destroying a 'colored_rectangle' object, as well as accessing or
modifying its 'color' slot.

   The essence of a term class is specified with the following form of
'class' declaration:
     :- class CLASSNAME = term(TERM, CONSTRAINT, ESSENCE).

where ESSENCE is of the form
     [NAME1:TYPE1=i[Variable1], NAME2:TYPE2=i[Variable2], ...]

and each NAME is a distinct atom naming a slot, each TYPE is a slot type
as specified in *note obj-scl-slt::, and each VARIABLE is an unbound
variable appearing in TERM.  Providing a term essence not only makes
storage of terms in ordinary object slots more efficient, it also gives
a name to each "essential" slot of the term class.  This allows you to
use 'fetch_slot' to fetch the slots of this class.

   To extend our 'rgb_color' example, we might introduce the 'rgb_color'
class with this declaration:
     :- class rgb_color =
              term(color(Red,Green,Blue),
                   (float(Red),   Red >= 0.0,   Red =< 1.0,
                    float(Green), Green >= 0.0, Green =< 1.0,
                    float(Blue),  Blue >= 0.0,  Blue =< 1.0),
                   [red:float=Red, green:float=Green, blue:float=Blue]).

   This declaration defines the 'rgb_color' class exactly as the example
declaration of the previous section: every 'color/3' term whose
arguments are all floating point numbers between 0.0 and 1.0 inclusive
are instances of 'rgb_color'.  The difference is that with this
declaration, ordinary classes that have slots of type 'rgb_color', such
as the 'colored_rectangle' example above, will be stored more
efficiently, and their 'rgb_color' slots will be accessed and modified
much more efficiently.  Also, it will be possible to use
'fetch_slot(red, Red)' in the methods of the 'rgb_color' class to fetch
to red component of the message recipient, and similarly for 'green' and
'blue'.


File: sicstus.info,  Node: obj-tech,  Next: obj-exp,  Prev: obj-tcl,  Up: lib-objects

10.29.5 Technical Details
-------------------------

* Menu:

* obj-tech-syn::                        Syntax of Class Definitions
* obj-tech-lim::                        Limitations

This section will be expanded in future versions of SICStus Objects.
For now, it provides a BNF grammar for the syntax of class definitions
and a short list of some limitations of SICStus Objects.


File: sicstus.info,  Node: obj-tech-syn,  Next: obj-tech-lim,  Up: obj-tech

10.29.5.1 Syntax of Class Definitions
.....................................

The following BNF grammar gives a concise description of the syntax of
class definitions.  It assumes an understanding of Prolog syntax for the
following items: "variable", "atom", "compound_term", and "constant".
Slot types, particularly the 'address', 'class' and 'pointer' types,
were discussed in an earlier section.

CLASS_DEF          ::= CLASS_BEGIN { CLAUSE | METHOD } CLASS_END

CLASS_BEGIN        ::= ':- class' CLASS_NAME OPT_CLASS_SPEC '.'

OPT_CLASS_SPEC     ::= EMPTY | '=' CLASS_SPEC

CLASS_SPEC         ::= MULTI_PARENT_OR_SLOTS | TERM_CLASS_SPEC

CLAUSE             ::= HEAD OPT_BODY '.'

HEAD               ::= ATOM | COMPOUND_TERM '.'

METHOD             ::= MESSAGE_HEAD OPT_BODY '.'

MESSAGE_HEAD       ::= MESSAGE_GOAL

CLASS_END          ::= ':- end_class' OPT_CLASS_NAME '.'
                   | EMPTY /* if followed by CLASS_BEGIN or EOF */

MESSAGE            ::= ATOM | COMPOUND_TERM

MULTI_PARENT_OR_SLOTS::= PARENT_OR_SLOTS { '+' PARENT_OR_SLOTS }

PARENT_OR_SLOTS    ::= CLASS_NAME | '[]' | '[' SLOT_DEF {',' SLOT_DEF }
                   ']'

SLOT_DEF           ::= OPT_VISIBILITY SLOT_NAME ':' SLOT_TYPE
                   OPT_INIT_VALUE

OPT_VISIBILITY     ::= EMPTY | 'private' | 'protected' | 'public'

OPT_INIT_VALUE     ::= EMPTY | '=' CONSTANT

TERM_CLASS_SPEC    ::= 'term('TERM OPT_GOAL_ESSENCE')'

OPT_GOAL_ESSENCE   ::= EMPTY | ',' GOAL OPT_ESSENCE

OPT_ESSENCE        ::= EMPTY | ',' ESSENCE

ESSENCE            ::= '[' VARIABLE ':' SLOT_TYPE { ',' VARIABLE ':'
                   SLOT_TYPE } ']'

OPT_BODY           ::= EMPTY | ':-' BODY

BODY               ::= MESSAGE_OR_GOAL { ',' MESSAGE_OR_GOAL }

MESSAGE_OR_GOAL    ::= MESSAGE_GOAL | GOAL

MESSAGE_GOAL       ::= VARIABLE MESSAGE_OPERATOR MESSAGE

MESSAGE_OPERATOR   ::= '<<' | '>>' | '<-'

OPT_CLASS_NAME     ::= EMPTY | CLASS_NAME

CLASS_NAME         ::= ATOM

SLOT_NAME          ::= ATOM

SLOT_TYPE          ::= 'integer'
                   | 'short'
                   | 'char'
                   | 'unsigned_short'
                   | 'unsigned_char'
                   | 'float'
                   | 'double'
                   | 'atom'
                   | 'address'
                   | 'term'
                   | CLASS_NAME
                   | 'pointer(ATOM)'


File: sicstus.info,  Node: obj-tech-lim,  Prev: obj-tech-syn,  Up: obj-tech

10.29.5.2 Limitations
.....................

This section summarizes the current limitations of SICStus Objects.

Debugging
---------

When you debug SICStus Objects programs that were compiled using the
'obj_decl' module, you are tracing the translated version of your code.
This includes all method clauses and (some) message sending commands.

   The source-linked debugger cannot connect compiled SICStus Objects
code with the source code.

Garbage Collection
------------------

There is no garbage collection of objects.  It is the responsibility of
the programmer to keep track of unused objects.  In particular, avoid
doing the following:

     | ?- create(CLASS, OBJECT).

   Unless the create message for CLASS made some provision for finding
the new object again, it is now lost.  It cannot be used, and it cannot
be destroyed.

Multiple Inheritance
--------------------

The provisions for multiple inheritance in this version of SICStus
Objects are limited.  In particular, there is no control over the
inheritance of slots, which makes repeated inheritance impossible.
However, it does support the mixin style of multiple inheritance.

Persistence
-----------

While objects are more persistent than Prolog variables, there is no
automatic way to save objects from one execution of your program to the
next.  Hence they are less persistent than the clauses in the Prolog
database.

   If you need to save a set of objects from one Prolog session to
another, then copy the objects to the Prolog database as terms, and save
them to a '.sav' file.  Then, after you reload the '.sav' file, rebuild
the objects.  Keep in mind that addresses are not valid from one session
to another.

   In short, there is no way to avoid initializing objects at run time.


File: sicstus.info,  Node: obj-exp,  Next: obj-glo,  Prev: obj-tech,  Up: lib-objects

10.29.6 Exported Predicates
---------------------------

* Menu:

* obj-exp-send::                        <-/2
* obj-exp-put::                         <</2
* obj-exp-get::                         >>/2
* obj-exp-class::                       class/1
* obj-exp-class_ancestor::              class_ancestor/2
* obj-exp-class_method::                class_method/1
* obj-exp-class_superclass::            class_superclass/2
* obj-exp-class_of::                    class_of/2
* obj-exp-create::                      create/2
* obj-exp-current_class::               current_class/1
* obj-exp-debug_message::               debug_message/0
* obj-exp-define_method::               define_method/3
* obj-exp-descendant_of::               descendant_of/2
* obj-exp-destroy::                     destroy/1
* obj-exp-direct_message::              direct_message/4
* obj-exp-end_class::                   end_class/[0,1]
* obj-exp-fetch_slot::                  fetch_slot/2
* obj-exp-inherit::                     inherit/1
* obj-exp-instance_method::             instance_method/1
* obj-exp-message::                     message/4
* obj-exp-nodebug_message::             nodebug_message/0
* obj-exp-pointer_object::              pointer_object/2
* obj-exp-store_slot::                  store_slot/2
* obj-exp-undefine_method::             undefine_method/3
* obj-exp-uninherit::                   uninherit/1

The following reference pages, alphabetically arranged, describe the
exported SICStus Objects predicates.  They can be imported by an
embedded command:

     :- use_module(library(objects)).


File: sicstus.info,  Node: obj-exp-send,  Next: obj-exp-put,  Up: obj-exp

10.29.6.1 '<-/2'
................

Synopsis
--------

+OBJ '<-' +MESG

Arguments
---------

OBJ
     "object"

MESG
     "term"

Description
-----------

Sends MESG to OBJ.  A send message.  The class of OBJ must have a method
defined for this message.

   A clause with '<-/2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error will only be raised if the
code that sends the message is compiled with debugging enabled (see
'debug_message'), or if the message is not determined at compile-time.
In other circumstances, the message will simply fail.

   Calls to the '<-/2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<</2', '>>/2', 'direct_message/4', 'message/4'


File: sicstus.info,  Node: obj-exp-put,  Next: obj-exp-get,  Prev: obj-exp-send,  Up: obj-exp

10.29.6.2 '<</2'
................

Synopsis
--------

+OBJ '<<' +ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"

Description
-----------

Sends a message to 'Obj' to store the value of 'Att' in the object.  A
put message.  'Att' must be an attribute that can be stored in objects
of 'Obj''s class.

   A clause with '<</2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

   Put methods are automatically generated for public slots.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see 'debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the '<</2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<-/2', '>>/2', 'direct_message/4', 'message/4', 'store_slot/2'


File: sicstus.info,  Node: obj-exp-get,  Next: obj-exp-class,  Prev: obj-exp-put,  Up: obj-exp

10.29.6.3 '>>/2'
................

Synopsis
--------

+OBJ '>>' +-ATT

Arguments
---------

OBJ
     "object"

ATT
     "term"

Description
-----------

Sends a message to OBJ that fetches the value of ATT from the object.  A
get message.  ATT must be an attribute to fetch from OBJ's class.

   A clause with '>>/2' as the principal functor of its head is a method
definition clause.  Such clauses only occur within the scope of a class
definition.  They are expanded at compile time.

   Get methods are automatically generated for public slots.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'domain_error'

     MESG is not "callable" or OBJ is not a valid object.

'existence_error'

     MESG is not a defined message for OBJ.

Caveat
------

For reasons of efficiency, an Existence Error exception will only be
raised if the code that sends the message is compiled with debugging
enabled (see 'debug_message'), or if the message is not determined at
compile-time.  In other circumstances, the message will simply fail.

   Calls to the '>>/2' predicate will be compiled into more efficient
code if the 'obj_decl' module is loaded at compile time.

See Also
--------

'<-/2', '<</2', 'direct_message/4', 'message/4', 'fetch_slot/2'


File: sicstus.info,  Node: obj-exp-class,  Next: obj-exp-class_ancestor,  Prev: obj-exp-get,  Up: obj-exp

10.29.6.4 'class/1'  declaration
................................

Synopsis
--------

':- class CLASSNAME.'

   ':- class CLASSNAME = [SLOTDEF, ...].'

   ':- class CLASSNAME = SUPER.'

   ':- class CLASSNAME = [SLOTDEF, ...] + SUPER + ....'

   ':- class CLASSNAME = term(TERM).'

   ':- class CLASSNAME = term(TERM, GOAL).'

   ':- class CLASSNAME = term(TERM, GOAL, ESSENCE).'

Arguments
---------

CLASSNAME
     "atom"

SLOTDEF
     "term"

SUPER
     "atom"

Description
-----------

The definition of class CLASSNAME begins with this 'class/1' directive
and ends with the next 'class/1' directive, the next 'end_class/[0,1]'
directive, or the end of the file, whichever comes first.  All clauses
that look like method definitions within the scope of the class
definition (that is, which have one of '<-/2', '<</2' or '>>/2' as the
principal functors of their heads) are considered method definitions of
the class.

   You may provide as many slot definitions (SLOTDEF) and superclasses
(SUPER) as you like.  All superclasses must be previously defined
classes.

   A slot definition (SlotDef) has the form

     VISIBILITY SLOTNAME:TYPE = INITIALVALUE

where VISIBILITY and '= INITIALVALUE' are optional.

   VISIBILITY is either 'public', 'protected', or 'private'.  If it is
omitted, then the slot is private.

   SLOTNAME must be an atom.

   SLOTTYPE must be one of the following:

'integer'
     signed integer, large enough to hold a pointer

'integer_64   since release 4.3'
     64-bit signed integer

'integer_32'
     32-bit signed integer

'integer_16'
     16-bit signed integer

'integer_8'
     8-bit signed integer

'unsigned'
     unsigned integer, large enough to hold a pointer

'unsigned_64   since release 4.3'
     64-bit unsigned integer

'unsigned_32'
     32-bit unsigned integer

'unsigned_16'
     16-bit unsigned integer

'unsigned_8'
     8-bit unsigned integer

'float'
     64-bit floating point number

'float_32'
     32-bit floating point number

'atom'
     Prolog atom

'address'
     pointer

'term'
     Prolog term

'CLASS'
     pointer to an instance of CLASS, which must be a previously defined
     class

'pointer(TYPE)'
     like 'address', except that access to this slot yields, and update
     of this slot expects, a unary term whose functor is TYPE

   INITIALVALUE may be any constant appropriate for the slot's type.

   TERM, if specified, is any compound Prolog term.  Class declarations
of any of the last three forms introduce a "term class", which defines
any term that unifies with TERM as an instance of the class being
defined.

   GOAL, if specified, is any Prolog goal.  This goal may be used to
restrict which terms that unify with TERM will be considered to be
instance of the class being defined.  The default GOAL is 'true'.  Other
than when it is 'true', GOAL will usually share variables with TERM.

   ESSENCE, if specified, is a list of terms of the form
     VARIABLE:TYPE

where VARIABLE is a variable appearing somewhere in TERM and TYPE is one
of the possible SLOTTYPE types listed above.  There should be a
VARIABLE':'TYPE pair for every variable in TERM.  By specifying an
essence, you permit much more space- and time-efficient storage of and
access to term slots.

Caveat
------

Note that every class for which you want to be able to create instances
must define at least one create method.

Examples
--------

The following class definition is for a class named 'point', with two
public slots, named 'x' and 'y'.  Both slots are of type 'integer' and
have initial values of 1 and 2, respectively.

     :- class point =
             [public x:integer=1,
              public y:integer=2].

     Self <- create.
     :- end_class point.

   Because the slots are public, they have get and put methods generated
automatically.  Because the class has a create method defined, it is
possible to create an instance with the command

     | ?- create(point, PointObj).

which creates a 'point' object and binds the variable 'PointObj' to it.

   Using the 'point' class, we could create a class, 'named_point',
which has an extra public slot, 'name'.

     :- class named_point =
             [public name:atom] + point.

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y).

     :- end_class named_point.

   The only way to create a 'named_point' object requires specifying
values for all three slots.

See Also
--------

'end_class/[0,1]'

   *note obj-scl::, *note obj-tcl::.


File: sicstus.info,  Node: obj-exp-class_ancestor,  Next: obj-exp-class_method,  Prev: obj-exp-class,  Up: obj-exp

10.29.6.5 'class_ancestor/2'
............................

Synopsis
--------

'class_ancestor(?CLASS, ?ANC)'

Arguments
---------

CLASS
     "atom"

ANC
     "atom"

Description
-----------

ANC is CLASS or an ancestor class of CLASS.

See Also
--------

'class_superclass/2'


File: sicstus.info,  Node: obj-exp-class_method,  Next: obj-exp-class_superclass,  Prev: obj-exp-class_ancestor,  Up: obj-exp

10.29.6.6 'class_method/1'  declaration
.......................................

Synopsis
--------

':- class_method +NAME/+ARITY, ... .'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"

Description
-----------

Declares that a class's method for send message NAME/ARITY is an
ordinary method, not an instance method.

   Used when the class being defined inherits an instance method from a
superclass, to allow the class to define a non-instance method for the
message.  A descendant class may still declare this to be an instance
method, so the same message may be an instance method for some classes
and an ordinary class method for others.

   Must occur within the scope of the class definition.  Only applies to
send messages.

See Also
--------

'instance_method/1'


File: sicstus.info,  Node: obj-exp-class_superclass,  Next: obj-exp-class_of,  Prev: obj-exp-class_method,  Up: obj-exp

10.29.6.7 'class_superclass/2'
..............................

Synopsis
--------

'class_superclass(?CLASS, ?SUPER)'

Arguments
---------

CLASS
     "atom"

SUPER
     "atom"

Description
-----------

CLASS is an immediate subclass of SUPER.

See Also
--------

'class_ancestor/2'


File: sicstus.info,  Node: obj-exp-class_of,  Next: obj-exp-create,  Prev: obj-exp-class_superclass,  Up: obj-exp

10.29.6.8 'class_of/2'
......................

Synopsis
--------

'class_of(+OBJ, -CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"

Description
-----------

CLASS is the class of OBJ.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJ is not a valid object.

See Also
--------

'pointer_object/2'


File: sicstus.info,  Node: obj-exp-create,  Next: obj-exp-current_class,  Prev: obj-exp-class_of,  Up: obj-exp

10.29.6.9 'create/2'
....................

Synopsis
--------

'create(+DESCRIPTOR,-OBJ)'

Arguments
---------

DESCRIPTOR
     "term"

OBJ
     "object"

Description
-----------

OBJ is a newly created and initialized object.  Descriptor is a term
describing the object to create.  After memory is allocated and any slot
initializations are performed, a create message is sent to the object.

   The functor of DESCRIPTOR indicates the class to create.  The
arguments of the create message are the arguments of DESCRIPTOR.

Exceptions
----------

'instantiation_error'

     DESCRIPTOR is unbound.

'domain_error'

     DESCRIPTOR is not a valid 'create' descriptor.

'resource_error'

     unable to allocate enough memory for object.

Caveat
------

You must have a 'create/N' method for every arity N you want to be able
to use in creating instances of a class.  This includes arity 0.  If no
such method exists, then a domain error will be raised.

Examples
--------

Given the class definition

     :- class point =
                     [public x:integer=1,
                      public y:integer=2].

     Self <- create.
     Self <- create(X, Y) :-
                     Self << x(X),
                     Self << y(Y).
     :- end_class point.

the command

     | ?- create(point, Point1).

creates a 'point' object, with the default slot values for 'x' and 'y',
and binds variable 'Point1' to the new object.  The command

     | ?- create(point(10,15), Point2).

creates a 'point' object with values 10 and 15 for slots 'x' and 'y',
respectively, and binds variable 'Point2' to the new object.

See Also
--------

'destroy/1'


File: sicstus.info,  Node: obj-exp-current_class,  Next: obj-exp-debug_message,  Prev: obj-exp-create,  Up: obj-exp

10.29.6.10 'current_class/1'
............................

Synopsis
--------

'current_class(*CLASS)'

Arguments
---------

CLASS
     "atom"

Description
-----------

'Class' is the name of a currently defined class.


File: sicstus.info,  Node: obj-exp-debug_message,  Next: obj-exp-define_method,  Prev: obj-exp-current_class,  Up: obj-exp

10.29.6.11 'debug_message/0'  declaration
.........................................

Synopsis
--------

':- debug_message.'

Description
-----------

Prolog clauses following this directive will be compiled to send
messages "carefully."

   That is, a message sent to an object that does not understand the
message will raise an exception, which describes both the message and
the object receiving it.  This also catches attempts to send an unbound
message, to send a message to an unbound object, and similar errors.

See Also
--------

'nodebug_message/0'


File: sicstus.info,  Node: obj-exp-define_method,  Next: obj-exp-descendant_of,  Prev: obj-exp-debug_message,  Up: obj-exp

10.29.6.12 'define_method/3'
............................

Synopsis
--------

'define_method(+OBJ, +MESSAGE, +BODY)'

Arguments
---------

OBJ
     "object"

MESSAGE
     "term"

BODY
     "callable"

Description
-----------

Installs BODY as the method for MESSAGE in the instance OBJ.  Following
the execution of this goal, sending MESSAGE to OBJ will execute BODY,
rather than the default method or a method previously defined with
'define_method/3'.

   MESSAGE must have been declared to be an instance method for the
class of OBJ.

Exceptions
----------

'instantiation_error'

     any argument is unbound.

'type_error'

     OBJ is not a compound term, or MESSAGE or BODY is not "callable".

'domain_error'

     MESSAGE does not specify an instance method for the class of OBJ,
     or BODY include a goal to fetch or store a non-existent slot.

See Also
--------

'instance_method/1', 'undefine_method/3'


File: sicstus.info,  Node: obj-exp-descendant_of,  Next: obj-exp-destroy,  Prev: obj-exp-define_method,  Up: obj-exp

10.29.6.13 'descendant_of/2'
............................

Synopsis
--------

'descendant_of(+OBJ, ?CLASS)'

Arguments
---------

OBJ
     "object"

CLASS
     "atom"

Description
-----------

OBJ is an instance of CLASS or of a descendant of CLASS.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJECT is not a valid object.

See Also
--------

'class_ancestor/2', 'class_of/2', 'class_superclass/2'


File: sicstus.info,  Node: obj-exp-destroy,  Next: obj-exp-direct_message,  Prev: obj-exp-descendant_of,  Up: obj-exp

10.29.6.14 'destroy/1'
......................

Synopsis
--------

'destroy(+OBJ)'

Arguments
---------

OBJ
     "object"

Description
-----------

First, sends a 'destroy' message to OBJ, if such a message is defined
for its class.  A 'destroy' message takes no argument.  Unlike
'create/2', it is possible to destroy instances of a class even if it
defines no 'destroy' methods.  Finally, disposes of OBJ.

Exceptions
----------

'instantiation_error'

     OBJ is unbound.

'type_error'

     OBJECT is not a valid object.

See Also
--------

'create/2'


File: sicstus.info,  Node: obj-exp-direct_message,  Next: obj-exp-end_class,  Prev: obj-exp-destroy,  Up: obj-exp

10.29.6.15 'direct_message/4'
.............................

Synopsis
--------

'direct_message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

NAME/ARITY is an OP message directly understood (defined rather than
inherited) by instances of CLASS.  This predicate is used to test
whether a message is defined for a class.

   OP is one of '<-', '>>', or '<<', specifying the kind of message.

   This predicate violates the principle of information hiding by
telling whether the method for a message is defined within a class or
inherited.  Hence its use in ordinary programs is discouraged.  It may
be useful, however, during debugging or in developing programming
support tools.

See Also
--------

'<-/2', '<</2', '>>/2', 'message/4'


File: sicstus.info,  Node: obj-exp-end_class,  Next: obj-exp-fetch_slot,  Prev: obj-exp-direct_message,  Up: obj-exp

10.29.6.16 'end_class/[0,1]'  declaration
.........................................

Synopsis
--------

':- end_class.'

   ':- end_class +CLASSNAME.'

Arguments
---------

CLASSNAME
     "atom"

Description
-----------

A class definition continues until the next 'end_class/[0,1]' directive,
the next 'class/1' directive, or the end of the file, whichever comes
first.

   It is not possible to nest one class definition within another.

   All clauses that look like method definitions (that is, which have
one of '<-/2', '<</2' or '>>/2' as the principal functors of their
heads) are considered to be method definitions for the class.

Caveat
------

The argument to 'end_class/1', if specified, must match the class name
of the preceding 'class/1' directive.

See Also
--------

'class/1'


File: sicstus.info,  Node: obj-exp-fetch_slot,  Next: obj-exp-inherit,  Prev: obj-exp-end_class,  Up: obj-exp

10.29.6.17 'fetch_slot/2'
.........................

Synopsis
--------

'fetch_slot(+SLOTNAME, -VALUE)'

Arguments
---------

SLOTNAME
     "atom"

VALUE
     "term"

Description
-----------

Fetches VALUE from the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent.  It cannot
be used to directly access the slots of another object.

Exceptions
----------

'instantiation_error'

     SLOT is unbound.

'domain_error'

     SLOT is not the name of a slot of the current class.

'permission_error'

     SLOT is a private slot of a superclass.

See Also
--------

'>>/2', 'store_slot/2'


File: sicstus.info,  Node: obj-exp-inherit,  Next: obj-exp-instance_method,  Prev: obj-exp-fetch_slot,  Up: obj-exp

10.29.6.18 'inherit/1'  declaration
...................................

Synopsis
--------

':- inherit +CLASSNAME +OP +NAME/+ARITY, ....'

Arguments
---------

CLASSNAME
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

CLASSNAME names the class from which the message should be inherited, OP
indicates which kind of message it is, and NAME and ARITY indicate the
name and arity of the message to be inherited.  You may include several
inheritance specifications in one directive.

Caveat
------

Be careful of the precedences of the message operator and the '/'
operator.  You may need to use parentheses.

Examples
--------

Suppose classes 'toy' and 'truck' are defined as follows:

     :-class toy.
     Self <- create.
     Self >> size(small).
     Self >> rolls(false).
     :- end_class toy.

     :- class truck.
     Self <- create.
     Self >> size(small).
     Self >> rolls(true).
     :- end_class truck.

   Then 'toy_truck' inherits its size from 'toy' and the fact that it
rolls from 'truck':

     :- class toy_truck = toy + truck.
     :- inherit
             toy <- (create/O),
             toy <- (size/1),
             truck <- (rolls/1).
     :- end_class toy_truck.

   Note that this is just a toy example.

See Also
--------

'uninherit/1'


File: sicstus.info,  Node: obj-exp-instance_method,  Next: obj-exp-message,  Prev: obj-exp-inherit,  Up: obj-exp

10.29.6.19 'instance_method/1'  declaration
...........................................

Synopsis
--------

':- instance_method +NAME/+ARITY.'

Arguments
---------

NAME
     "atom"

ARITY
     "integer"

Description
-----------

The message NAME/ARITY is declared to support instance methods in a
class.  This means that instances of this class, and its descendants,
may each define their own methods for this message.

   A method defined for this message by the class is considered the
default method for the message.  An instance that does not define its
own method uses the default.  Defining a new method overrides this
default method; there is no need to explicitly remove it.

   An instance method is installed in an instance of the class with the
'define_method/3' predicate.  An instance method is removed from an
instance of the class, reverting to the default method, with the
'undefine_method/3' predicate.

   Must occur within the scope of the class definition.  Only applies to
send messages.

See Also
--------

'class_method/1', 'define_method/3', 'undefine_method/3'


File: sicstus.info,  Node: obj-exp-message,  Next: obj-exp-nodebug_message,  Prev: obj-exp-instance_method,  Up: obj-exp

10.29.6.20 'message/4'
......................

Synopsis
--------

'message(?CLASS, ?OP, ?NAME, ?ARITY)'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

NAME/ARITY is an OP message understood by instances of CLASS.  This
predicate is used to test whether a message is either defined for or
inherited by a class.

   OP is one of '<-', '>>', or '<<', specifying the kind of message.

See Also
--------

'<-/2', '<</2', '>>/2', 'direct_message/4'


File: sicstus.info,  Node: obj-exp-nodebug_message,  Next: obj-exp-pointer_object,  Prev: obj-exp-message,  Up: obj-exp

10.29.6.21 'nodebug_message/0'  declaration
...........................................

Synopsis
--------

':- nodebug_message.'

Description
-----------

Prolog clauses following this directive are no longer compiled to send
messages "carefully."

See Also
--------

'debug_message/0'


File: sicstus.info,  Node: obj-exp-pointer_object,  Next: obj-exp-store_slot,  Prev: obj-exp-nodebug_message,  Up: obj-exp

10.29.6.22 'pointer_object/2'
.............................

Synopsis
--------

'pointer_object(+ADDR,-OBJ)'

   'pointer_object(-ADDR,+OBJ)'

Arguments
---------

ADDR
     "integer"

OBJ
     "object"

Description
-----------

ADDR is the address of object OBJ.  This can be used to get the address
of an object or to get an object given its address.

   *Please note*: This is a low level operation, passing an invalid
address may crash the system.

Exceptions
----------

'instantiation_error'

     both OBJ and ADDR are unbound.

'type_error'

     ADDR is not an integer.


File: sicstus.info,  Node: obj-exp-store_slot,  Next: obj-exp-undefine_method,  Prev: obj-exp-pointer_object,  Up: obj-exp

10.29.6.23 'store_slot/2'
.........................

Synopsis
--------

'store_slot(+SLOTNAME, +NEWVALUE)'

Arguments
---------

SLOTNAME
     "atom"

NEWVALUE
     "term"

Description
-----------

Stores NEWVALUE in the slot specified by SLOTNAME.

   This predicate may only appear in the body of a method clause, and it
always operates on the object to which that message is sent.  It cannot
be used to directly modify the slots of another object.

Exceptions
----------

'instantiation_error'

     either argument is unbound.

'type_error'

     NEWVALUE is not of the appropriate type for SLOTNAME.

'domain_error'

     SLOTNAME is not the name of a slot of the current class.

'permission_error'

     SLOTNAME is a private slot of a superclass.

See Also
--------

'<</2', 'fetch_slot/2'


File: sicstus.info,  Node: obj-exp-undefine_method,  Next: obj-exp-uninherit,  Prev: obj-exp-store_slot,  Up: obj-exp

10.29.6.24 'undefine_method/3'
..............................

Synopsis
--------

'undefine_method(+OBJ, +NAME, +ARITY)'

Arguments
---------

OBJ
     "object"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

Removes OBJ's current instance method for the NAME/ARITY message.  After
executing this goal, sending this message to OBJ executes the class's
default method for the message.

   NAME/ARITY must have been declared to be an instance method for the
class of OBJ.

   If OBJ has no current instance method for the NAME/ARITY message,
then the predicate has no effect.

Exceptions
----------

'instantiation_error'

     any argument is unbound.

'type_error'

     OBJ is not a compound term, NAME is not an atom, or ARITY is not an
     integer.

'domain_error'

     MESSAGE does not specify an instance method for the class of OBJ.

See Also
--------

'define_method/3', 'instance_method/1'


File: sicstus.info,  Node: obj-exp-uninherit,  Prev: obj-exp-undefine_method,  Up: obj-exp

10.29.6.25 'uninherit/1'  declaration
.....................................

Synopsis
--------

':- uninherit +CLASS +OP +NAME/+ARITY, ... .'

Arguments
---------

CLASS
     "atom"

OP
     "message_operator"

NAME
     "atom"

ARITY
     "integer"

Description
-----------

This prevents the class within whose scope this directive appears from
inheriting the NAME/ARITY method of type OP from ancestor CLASS.

   If CLASS is unbound, then the specified message is uninherited from
all ancestors that define it.

Caveat
------

Note that if you define a message for your class, then you do not need
to uninherit that message from its superclasses: it will automatically
be shadowed.

   Be careful of the precedences of the message operator and the '/'
operator.  You may need to use parentheses.

Examples
--------

     :- uninherit someclass << (foo/1),
                  someclass >> (foo/1).

   This prevents the get and put methods for the slot 'foo' from being
inherited from any ancestors of class 'someclass'.  In effect, it makes
the 'foo' slot a protected slot for this class.

See Also
--------

'inherit/1'


File: sicstus.info,  Node: obj-glo,  Next: obj-bas,  Prev: obj-exp,  Up: lib-objects

10.29.7 Glossary
----------------

"abstract class"
     A class that cannot have instances.  Abstract classes are helpful
     in designing a class hierarchy, to contain the common parts of
     several concrete classes.

"ancestor"
     One of a class's superclasses, one of its superclasses's
     superclasses, etc.  Sometimes, for convenience, ancestor includes
     the class itself, along with its proper ancestors.

"child"
     A synonym for subclass.

"class"
     A class is defined by a description of the information its
     instances contain and the messages they respond to.  Every object
     is an instance of one and only one class.

"concrete class"
     A class that can have instances.  Most classes are concrete.

"create method"
     Specifies what actions should be taken when an instance of a class
     is created.  A create method frequently provides initial slot
     values or specifies an action to be performed by the new object.  A
     create message is sent to each new object by the 'create/2'
     predicate.  A create message is a kind of send message.

"descendant"
     One of a class's subclasses, one of its subclasses's subclasses,
     etc.  Sometimes the word descendant includes the class itself,
     along with its proper descendants.

"destroy method"
     Specifies what actions should be taken when an instance of a class
     is destroyed.  A destroy message is sent to an object by the
     'destroy/1' predicate.  A destroy message is a kind of send
     message.

"direct slot access"
     Fetching or storing a slot value without sending a message to the
     object.  This should be used with care!

     SICStus Objects allows direct access to a class's slots only within
     its method definitions, via the 'fetch_slot/2' and 'store_slot/2'
     predicates.

"get message"
     A message that inquires about some aspect of an object.  Typically
     used to fetch slot values.  Get methods are automatically generated
     for public slots.  Get messages are written with the '>>' operator.

"inheritance"
     The process by which a class's slots and methods are determined
     from an ancestor.

"initial value"
     The value a slot is initialized to when an object is created.
     Every slot has a default initial value, which depends upon its
     type.  You may specify different initial values in a class
     definition.

"instance"
     Another word for object.  The word instance draws attention to the
     class of which the object is an instance.

"instance method"
     A method that may be defined differently for each instance of a
     class.  The class may have a default method for this message, which
     is overridden by installing an instance method for a particular
     object.

"message"
     A command to an object to perform an operation or to modify itself,
     or an inquiry into some aspect of the object.  In SICStus Objects,
     a message is either a get message, a put message or a send message.
     The syntax for sending a message to an object is

          OBJECT OPERATOR MESSAGE

     where OPERATOR is one of the following:

     '>>'
          get message

     '<<'
          put message

     '<-'
          send message

"method"
     A class's implementation of a particular message.  You send
     messages to an object, but you define methods for a class.

"method clause"
     A Prolog clause used to define a method for a class.  A method
     clause has one of '<-/2', '<</2' or '>>/2' as the principal functor
     of its head, and it can only appear within the scope of its class's
     definition.  A method's definition may contain more than one
     message clause.

"mixin class"
     A class that is intended to be combined (mixed in) with other
     classes, via multiple inheritance, to define new subclasses.

"multiple inheritance"
     When a class names more than one superclass.  Typically, it
     inherits slots and methods from each.  In SICStus Objects, two
     different superclasses should not use the same slot name.  And, if
     a message is defined by more than one superclass, then the class
     definition must specify which method to inherit.

"object"
     A modifiable data item that holds information and responds to
     messages.  Another word for instance.

"parent class"
     A synonym for superclass.

"private slot"
     A private slot is, by default, only accessible within methods of
     the class itself.  Not even the descendants of the class may access
     its private slots, except through the class's methods.  Get and put
     methods are not automatically generated for a private slot, so it
     is only accessed via the methods you define.  If the visibility of
     a slot is not specified, then it is private, rather than public or
     protected.

"protected slot"
     A protected slot is, by default, only accessible within methods of
     the class itself and its descendants.  Get and put methods are not
     automatically generated for a protected slot, so it is only
     accessed via the methods you define.  If the visibility of a slot
     is not specified, then it is private, rather than public or
     protected.

     SICStus Objects 'protected' is similar to 'protected' in C++.

"public slot"
     A public slot is accessible via its own get and put methods, which
     are generated for it automatically.  If no visibility is specified,
     then a slot is private, rather than public or protected.

"put message"
     A message that modifies some aspect of an object.  Typically used
     to store slot values.  Put methods are automatically generated for
     public slots.  Put messages are written with the '<<' operator.

"send message"
     The most common sort of message.  Used for performing an operation
     on an object or for performing an action that depends upon an
     object.  Send messages are written with the '<-' operator.

"send super"
     When a method for a class executes a shadowed superclass's method.
     This allows a class to put a "wrapper" around its superclass's
     method, making it unnecessary to duplicate the method just to make
     a small extension to it.

"shadow"
     When a class defines its own method for a message defined by one of
     its ancestors, the new method hides or "shadows" the ancestor's
     method.  The new class's descendants will inherit its method for
     that message, rather than its ancestors.  That is, a class always
     inherits the "closer" of two methods for a message.

"slot"
     A part of an instance that holds an individual datum.  Like a
     member of a C struct or a field of a Pascal record.

"subclass"
     A class that is a more specific case of a particular class.  This
     is the opposite of superclass.  A class does not name its
     subclasses; they are inferred.

"superclass"
     A class that is a more general case of a particular class.  Each
     class lists its superclasses.

"term class"
     A class whose instances are represented as ordinary Prolog terms.
     The functor of these objects need not be the name of the class, and
     the arity need not be one.

"term slot"
     A slot that can hold any Prolog term.

"uninherit"
     Specify that a method from a superclass should not be inherited.
     This is similar to shadowing the superclass's method, but does not
     specify a replacement for it.

"visibility"
     A slot may be defined to be either 'public', 'protected', or
     'private'.  By default, if no visibility is specified, then a slot
     is private.


File: sicstus.info,  Node: lib-odbc,  Next: lib-ordsets,  Prev: lib-objects,  Up: The Prolog Library

10.30 The ODBC Interface Library-'library(odbc)'
================================================

This library is an interface to an ODBC database driver.  For an
introduction to ODBC, see
<http://msdn.microsoft.com/en-us/library/ms715408(VS.85).aspx>
("Introduction to ODBC"; Microsoft Web Page).  ODBC 3.x is supported.

* Menu:

* ODBC Overview:: Overview
* ODBC Examples:: Examples
* ODBC Datatypes:: Datatypes
* ODBC Exceptions:: Exceptions
* ODBC Predicates:: Predicates


File: sicstus.info,  Node: ODBC Overview,  Next: ODBC Examples,  Up: lib-odbc

10.30.1 Overview
----------------

ODBC (Open Database Connectivity) is a standard API for using a DBMS
(DataBase Management System).  By using ODBC you can access data from a
multitude of DBMSs without having to know the details of each DBMS.

   'library(odbc)' is a layer on top of ODBC. It has predicates for
opening the database, starting and executing a query, and retrieving the
results of a query.  The ODBC client application, i.e. this library,
accesses all ODBC functionality via a service provided by the operating
system, the ODBC Driver Manager (DM).

   Some operating systems (e.g.  Mac OS X and MS Windows) usually come
with an ODBC Driver Manager preinstalled.  For other, UNIX and
UNIX-like, operating systems, unixODBC (<http://www.unixodbc.org>) is
the most common but Mac OS X use iODBC (<http://www.iodbc.org>).

   The ODBC Driver Manager does not, in itself, provide any database
functionality.  Instead the DM loads a ODBC driver specific to the
particular Database Management System (DBMS) (when
'odbc_db_open/[3,4,5]' is called).

   How to install and configure an ODBC driver is beyond the scope of
this document.  Please consult the documentation for the particular DBMS
you intend to use.  Some popular DBMSs are MySQL and PostgreSQL which
both provide ODBC drivers for many platforms.


File: sicstus.info,  Node: ODBC Examples,  Next: ODBC Datatypes,  Prev: ODBC Overview,  Up: lib-odbc

10.30.2 Examples
----------------

A few examples will best illustrate how to use 'library(odbc)'.

* Menu:

* ODBC Example 1:: Example 1
* ODBC Example 2:: Example 2
* ODBC Example 3:: Example 3
* ODBC Example 4:: Example 4


File: sicstus.info,  Node: ODBC Example 1,  Next: ODBC Example 2,  Up: ODBC Examples

10.30.2.1 Example 1
...................

The first example just verifies that ODBC is working and that some ODBC
drivers have been configured in the ODBC Driver Manager.

     :- use_module(library(odbc)).

     example1 :-
         odbc_env_open(EnvHandle),
         odbc_list_DSN(EnvHandle, DSNs),
         odbc_env_close(EnvHandle),
         format('The known DSNs are: ~q~n', [DSNs]).

   You begin by opening an environment.  This is a handle which can be
used for various calls to the ODBC Driver Manager (DM). You then ask the
DM about the data sources, i.e.  databases, it knows about.  If this
list is empty you need to install and configure the ODBC drivers
appropriate for the database management system that you intend to use.


File: sicstus.info,  Node: ODBC Example 2,  Next: ODBC Example 3,  Prev: ODBC Example 1,  Up: ODBC Examples

10.30.2.2 Example 2
...................

This example is a simple SQL query using a fixed SQL string.

     :- use_module(library(odbc)).

     example_select :-
         odbc_env_open(EnvHandle),
         odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
         odbc_query_open(ConnectionHandle, StatementHandle),
         odbc_query_execute_sql(StatementHandle,
                            'SELECT cookie,soft FROM bakery order by soft',
                            ResultSet),
         show_result(ResultSet),
         odbc_query_close(ResultSet),
         odbc_db_close(ConnectionHandle),
         odbc_env_close(EnvHandle).

     show_result(ResultSet) :-
         odbc_sql_fetch(ResultSet, Row),
         show_result1(Row, ResultSet).

     show_result1([], _ResultSet) :- !.
     show_result1(Row, ResultSet) :-
         format('~w~n', [Row]),
         flush_output,
         odbc_sql_fetch(ResultSet, Row1),
         show_result1(Row1, ResultSet).

   As always, you begin by opening an environment.  You then connect to
the database with 'odbc_db_open/3'.  The first argument is the
identifier for the database in the DBMS. In this scenario, connecting to
the database does not require a username and a password.  The output
from 'odbc_db_open/3' is an opaque handle on the database.

   First, 'odbc_query_open/2' is used to create an SQL query, which is
straightforward.  Then, 'odbc_query_execute_sql/3' is used to execute
the SQL query.  By executing an SQL query a _result set_ is created.
Each consecutive call of 'odbc_sql_fetch/2' will retrieve one row from
the result set.


File: sicstus.info,  Node: ODBC Example 3,  Next: ODBC Example 4,  Prev: ODBC Example 2,  Up: ODBC Examples

10.30.2.3 Example 3
...................

This example shows the use of parameter binding.  The positional markers
(?) in the SQL string are bound to the elements in the list in the third
argument of odbc_query_execute_sql/5.  The fourth argument is a list of
datatypes corresponding to the parameters.

     :- use_module(library(odbc)).

     example2 :-
        odbc_env_open('SQL_OV_ODBC3', EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            ['SQL_VARCHAR', 'SQL_INTEGER'],
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Example 4,  Prev: ODBC Example 3,  Up: ODBC Examples

10.30.2.4 Example 4
...................

This example is similar to the second, but this time we ask the database
what the datatypes of the columns of the table are with
odbc_list_data_types/3.

     :- use_module(library(odbc)).

     example3 :-
        odbc_env_open(EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_list_data_types(StatementHandle,
                             scratch(vehicle, wheels),
                             DataTypes),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            DataTypes,
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).



File: sicstus.info,  Node: ODBC Datatypes,  Next: ODBC Exceptions,  Prev: ODBC Examples,  Up: lib-odbc

10.30.3 Datatypes
-----------------

* Menu:

* ODBC Reading:: Reading from the database
* ODBC Writing:: Writing to the database


File: sicstus.info,  Node: ODBC Reading,  Next: ODBC Writing,  Up: ODBC Datatypes

10.30.3.1 Reading from the database
...................................

When reading data from the database the following datatypes are
supported, with conversion to the corresponding prolog datatypes.
'SQL_CHAR', 'SQL_VARCHAR' etc.
     A list of character codes.
'SQL_BIT'
     The integer '0' for false, or '1' for true.
'SQL_INTEGER', 'SQL_TINYINT', 'SQL_SMALLINT', etc.
     An integer.
'SQL_REAL', 'SQL_DOUBLE', 'SQL_FLOAT'
     A floating point number.
'SQL_DATE'
     A term 'date(Year, Month, DayOfMonth)', with one-based integer
     arguments.  E.g. 'date(2012,10,22)' means October 22, 2012.
'SQL_TIME'
     A term 'time(Hour, Minute, Second)' with one-based integer
     arguments.  E.g. 'time(22,11,5)' means eleven minutes and five
     seconds past ten pm.
'SQL_TIMESTAMP'
     A term 'timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)' where the arguments have the same meaning as for
     'SQL_TIME' and 'SQL_TIMESTAMP' and FRACTION means fractional
     nanoseconds past, as an integer.
the SQL null value
     The atom 'null'.
'SQL_BINARY' and other binary types
'SQL_INTERVAL_HOUR' and other interval types
'SQL_UTCTIME' and 'SQL_UTCDATETIME'
     Currently not supported.
Note that atoms with names that start with an upper case letter, like
'SQL_CHAR' must be quoted in Prolog, e.g. ''SQL_CHAR''.


File: sicstus.info,  Node: ODBC Writing,  Prev: ODBC Reading,  Up: ODBC Datatypes

10.30.3.2 Writing to the database
.................................

When writing data to the database the following SQL datatypes are
supported.

'SQL_CHAR', 'SQL_VARCHAR' etc.
     A list of character codes, or a list of atoms.

     For backwards compatibility only, an atom is also accepted, but
     note that the atoms 'null' and '[]' have special meaning (as SQL
     null value and empty code list, respectively) and more atoms with
     special meaning may be introduced in the future.  For compatibility
     with some ODBC drivers, the integer 0 and 1 are allowed, meaning
     "0" and "1".
'SQL_BIT'
     The integer '0' for false, or '1' for true.
'SQL_INTEGER', 'SQL_TINYINT', 'SQL_SMALLINT', etc.
     An integer.
'SQL_REAL', 'SQL_DOUBLE', 'SQL_FLOAT'
     A floating point number or a small integer.
'SQL_DATE'
     A term 'date(Year, Month, DayOfMonth)', as above.
'SQL_TIME'
     A term 'time(Hour, Minute, Second)', as above.
'SQL_TIMESTAMP'
     A term 'timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)', as above.
the SQL null value
     The atom 'null'.
'SQL_BINARY' and other binary types
'SQL_INTERVAL_HOUR' and other interval types
'SQL_UTCTIME' and 'SQL_UTCDATETIME'
     Currently not supported.
if a value is out of range for the corresponding SQL type, e.g. a too
large integer for 'SQL_SMALLINT', the result is undefined.  Note that
atoms with names that start with an upper case letter, like 'SQL_CHAR'
must be quoted in Prolog, e.g. ''SQL_CHAR''.


File: sicstus.info,  Node: ODBC Exceptions,  Next: ODBC Predicates,  Prev: ODBC Datatypes,  Up: lib-odbc

10.30.4 Exceptions
------------------

When an error in the ODBC layer occurs, predicates in 'library(odbc)'
throw 'error/2' exceptions.  Both arguments of the 'error/2' exception
are the same and has the following form 'odbc_error(DETAIL, GOAL)',
where 'Goal' is some goal where the error occurred, and DETAIL gives
more information about the error.  The DETAIL term can have the
following form:

'data_conversion'
     Thrown in case of a error when converting to or from a SICStus data
     type from or to an ODBC data type.

'unsupported_datatype'
     Thrown when an SQL data type is unsupported when converting to or
     from a SICStus data type from or to an ODBC data type.

'unknown_datatype'
     Thrown when an unknown SQL data type is found when converting to or
     from a SICStus data type from or to an ODBC data type.

'type_error'
     Thrown when the Prolog data is of a type incompatible with the SQL
     data type when converting from a SICStus data type to an ODBC data
     type.

'native_code'
     Thrown in case of a error in the native code of 'library(odbc)'.

'invalid_handle(handle_type, INVALIDHANDLE, RETURNCODE)'
     Thrown when an invalid handle type is specified.

'invalid_handle('HandleType'-HANDLETYPE, 'Handle'-HANDLE)'
     Thrown when an invalid handle is specified.

'invalid_handle(result_set, RESULTSET)'

     Thrown when a Result Set handle is invalid.

'unknown_connection_option(OPTIONS)'

     Thrown when an unknown option was given when calling
     'odbc_db_open/[3,4,5]'.

'internal_error'
     Thrown when an internal error occurs in 'library(odbc)'.  Please
     report this to SICStus Support.

'diag(RETURNCODE, RECS)'
     Thrown when an error occurs in the ODBC layer, e.g.  a SQL syntax
     error.  RECS is bound to the diagnostic records reported from ODBC.

'out_of_memory'
     Thrown when some operation runs out of memory.
there may be other DETAILS and new DETAILS may be added in the future.


File: sicstus.info,  Node: ODBC Predicates,  Prev: ODBC Exceptions,  Up: lib-odbc

10.30.5 Predicates
------------------

'odbc_env_open(-ENVHANDLE)'

     Opens an ODBC environment.  Throws an exception if the environment
     could not be opened.
'odbc_db_open(+DBNAME,+ENVHANDLE,-CONNECTIONHANDLE)'

     Opens a database with the name DBNAME.  The database cannot require
     a username and a password.  CONNECTIONHANDLE is an opaque handle
     for accessing the database.
'odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE)'

     Opens a database with the name DBNAME.  OPTIONS should be a list of
     zero or more of:
     'username(+USERNAME)'
          The username for connecting to the database.  The default is
          ''''.

     'password(+PASSWORD)'
          The password for connection to the database.  The default is
          ''''.

     'login_timeout(+TIMEOUT)'
          The number of seconds to wait for a login request to complete.
          If 0 is used, the login attempt will wait indefinitely.  The
          default is driver-dependent.

     'connection_timeout(+TIMEOUT)'
          The number of seconds to wait for any request on the
          connection to complete.  If the Timeout value is 0 (the
          default), there is no timeout.

     'raw(+CONNECTIONOPTIONS)'
          CONNECTIONOPTIONS should be a list of atoms.  They are passed,
          terminated by ';', as extra options when opening the database.
     CONNECTIONHANDLE is an opaque handle for accessing the database.
'odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE,-CONNECTIONSTRING)'

     Like 'odbc_db_open/4' but also returns the completed connection
     string returned by the ODBC driver.
'odbc_query_open(+CONNECTIONHANDLE, -STATEMENTHANDLE)'
     Creates a new database query.  CONNECTIONHANDLE is a handle
     previously allocated with 'odbc_db_open/[3,4,5]'.
'odbc_list_DSN(+ENVHANDLE,-DSNS)'

     ENVHANDLE is an opaque database handle.  DSNS is unified with a
     list of all DSNs (Data Source Names).  The list elements are X-Y
     where X is the DSN and Y its description.
'odbc_list_data_types(+STATEMENTHANDLE, +TABLEDESC, -DATATYPES)'
     Makes a list of the datatypes in a table.  STATEMENTHANDLE is a
     handle previously allocated with 'odbc_query_open/2'.  TABLEDESC is
     a description of the table and its columns of the form
     'tablename(columnname1, columnname2, ..., columnnameN)', or of the
     form '[tablename, columnname1, columnname2, ..., columnnameN]' (the
     latter form is useful if the table has more than 255 columns).
     DATATYPES is unified with a list of the corresponding datatypes,
     i.e.  on the form '[datatype1, datatype2, ... datatypeN]'.
'odbc_current_table(+ConnectionHandle, ?TableName)   since release 4.2'
     Enumerate the _proper_ tables in the database, i.e. tables with
     attribute ''TABLE_TYPE'("TABLE")'.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.

     Note that 'odbc_current_table/2' may exit nondeterminately even if
     all arguments are instantiated when it is called.
'odbc_current_table(+ConnectionHandle, ?TableName, ?Attribute)   since release 4.2'
     Enumerate database tables and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,

     'arity(VALUE)'
          The number of columns in the table, as an integer.

          This attribute is always present.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond directly to the (non-null) values
     returned from the ODBC function 'SQLTables()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     ''TABLE_CAT'("foo")' would be returned for a table in the catalog
     "foo".  Note that the names of the raw attributes are in all
     uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable.  Some of the
     raw attributes are,

     ''TABLE_CAT'(VALUE)'
          Catalog name, as a code list.  This attribute corresponds to
          the 'TABLE_CAT' column, called 'TABLE_QUALIFIER' in ODBC 2.0,
          as returned from the ODBC function 'SQLTables()'.
     ''TABLE_TYPE'(VALUE)'
          Table type, as a code list.  This attribute corresponds to the
          'TABLE_TYPE' column, as returned from the ODBC function
          'SQLTables()'.  The standard table types are '"TABLE"',
          '"VIEW"', '"SYSTEM TABLE"', '"GLOBAL TEMPORARY"', '"LOCAL
          TEMPORARY"', '"ALIAS"', and '"SYNONYM"', but there can be
          data-source-specific types as well.

          This attribute is always present.
     ''REMARKS'(VALUE)'
          Table descriptive text, as a code list.  This attribute
          corresponds to the 'REMARKS' column, as returned from the ODBC
          function 'SQLTables()'.

     see the ODBC documentation for 'SQLTables()' for the full list of
     raw attributes and their meaning.

     Note that 'odbc_current_table/3' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.
'odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName)   since release 4.2'
     Enumerate database table columns.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.

'odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName, ?Attribute)   since release 4.2'
     Enumerate database table columns and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     'odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.
     ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,

     'nullable(VALUE)'
          'true' if the column is definitely nullable, or 'false' if the
          column is definitely not nullable.  The value is derived from
          the raw attributes 'NULLABLE' and 'IS_NULLABLE', see the
          documentation for 'SQLColumns()' for details.

          This attribute is not present if it can not be determined
          whether the column is nullable.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond directly to the (non-null) values
     returned from the ODBC function 'SQLColumns()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     ''TABLE_CAT'("foo")' would be returned for a column in a table in
     the catalog "foo".  Note that the names of the raw attributes are
     in all uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable.  Some of the
     raw attributes are,

     ''REMARKS'(VALUE)'
          Column descriptive text, as a code list.  This attribute
          corresponds to the 'REMARKS' column, as returned from the ODBC
          function 'SQLColumns()'.

     ''ORDINAL_POSITION'(VALUE)'
          The ordinal position of the column in the table, starting at
          1.  This attribute corresponds to the 'ORDINAL_POSITION'
          column, as returned from the ODBC function 'SQLColumns()'.

          This attribute is always present.

     See the ODBC documentation for 'SQLColumns()' for the full list of
     raw attributes and their meaning.

     Note that 'odbc_table_column/4' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.
'odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, +PARAMDATA, +PARAMDATATYPES, -RESULTSET)'
     Executes an SQL query.  STATEMENTHANDLE is a handle previously
     allocated with 'odbc_query_open/2'.  SQLSTRING is the SQL statement
     to be executed.  The statement string may contain parameter
     markers.  PARAMDATA is a list of data to be bound to the parameter
     markers.  PARAMDATATYPES is a list of data types corresponding to
     the PARAMDATA list.  RESULTSET is bound to an opaque data structure
     describing the result of the query.
'odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, -RESULTSET)'
     STATEMENTHANDLE is a handle previously allocated with
     'odbc_query_open/2'.  SQLSTRING is the SQL statement to be
     executed.  RESULTSET is bound to an opaque data structure
     describing the result of the query.
'odbc_sql_fetch(+RESULTSET, -ROW)'
     Fetch the next row from the result set.  RESULTSET is the result
     set from 'odbc_query_execute_sql/[3,5]'.  ROW is unified with a
     non-empty list of data constituting a row in the result set, or
     with '[]' when there are no more rows.  The elements in the ROW are
     in the same order as in the corresponding query.
'odbc_query_close(+QUERY)'
     Closes the query represented by QUERY, which can be either a result
     set, e.g.  as returned from 'odbc_query_execute_sql/[3,5]', or it
     can be a statement handle, as returned from 'odbc_query_open/2'.

'odbc_db_close(+CONNECTIONHANDLE)'
     Closes the connection to the database.
'odbc_env_close(+ENVHANDLE)'
     Frees the environment handle.


File: sicstus.info,  Node: lib-ordsets,  Next: lib-pillow,  Prev: lib-odbc,  Up: The Prolog Library

10.31 Ordered Set Operations--'library(ordsets)'
================================================

This library module provides operations on sets represented as ordered
lists with no duplicates.  Thus '{c,r,a,f,t}' would be '[a,c,f,r,t]'.
The ordering is defined by the '@<' family of term comparison
predicates, which is the ordering used by 'sort/2' and 'setof/3'.

   The benefit of the ordered representation is that the elementary set
operations can be done in time proportional to the sum of the argument
sizes rather than their product.  You should use the operations defined
here in preference to those in 'library(sets)' unless there is a
compelling reason why you can't.  Some of the unordered set routines,
such as 'member/2', 'length/2' and 'select/3' can be used unchanged on
ordered sets; feel free so to use them.

   There is no 'ordset_to_list/2', as an ordered set is a list already.
Exported predicates:

'is_ordset(+LIST)'

     is true when LIST is a list of terms [T1,T2,...,TN] and the terms
     are strictly increasing: T1 @< T2 @< ... @< TN.  The output of
     'sort/2' always satisfies this test.  Anything which satisfies this
     test can be given to the predicates in this file, regardless of
     where you got it.
'list_to_ord_set(+LIST, -SET)'

     is true when SET is the ordered representation of the set
     represented by the unordered representation List.  The only reason
     for giving it a name at all is that you may not have realized that
     'sort/2' could be used this way.
'ord_add_element(+SET1, +ELEMENT, -SET2)'

     Equivalent to 'ord_union(SET1, [ELEMENT], SET2)', but a bit faster.
'ord_del_element(+SET1, +ELEMENT, -SET2)'

     Equivalent to 'ord_subtract(SET1, [ELEMENT], SET2)', but a bit
     faster.
'ord_disjoint(+SET1, +SET2)'

     is true when the two ordered sets have no element in common.
'ord_intersect(+SET1, +SET2)'

     is true when the two ordered sets have at least one element in
     common.
'ord_intersection(+SET1, +SET2, -INTERSECTION)'

     is true when INTERSECTION is the ordered representation of SET1 and
     SET2, provided that SET1 and SET2 are ordered sets.
'ord_intersection(+SET1, +SET2, ?INTERSECTION, ?DIFFERENCE)'
     is true when INTERSECTION is the intersection of SET1 and SET2, and
     DIFFERENCE is SET2 \ SET1 (like in ord_union/4), provided that SET1
     and SET2 are ordered sets.
'ord_intersection(+LISTOFSETS, -INTERSECTION)'
     is true when LISTOFSETS is a nonempty proper list of ordered sets
     and INTERSECTION is their intersection.
'ord_member(+ELT, +SET)'

     is true when ELT is a member of SET.  Suggested by Mark Johnson.
'ord_nonmember(+ITEM, +SET)'

     is true when the given ITEM is _not_ an element of the given SET.
'ord_seteq(+SET1, +SET2)'

     is true when the two arguments represent the same set.  Since they
     are assumed to be ordered representations, they must be identical.
'ord_setproduct(+SET1, +SET2, -PRODUCT)'

     If SET1 and SET2 are ordered sets, PRODUCT will be an ordered set
     of X1-X2 pairs.  Note that we cannot solve for SET1 and SET2,
     because there are infinitely many solutions when PRODUCT is empty,
     and may be a large number in other cases.  Could be defined as:

          ord_setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).
'ord_subset(+SET1, +SET2)'

     is true when every element of the ordered set SET1 appears in the
     ordered set SET2.
'ord_subtract(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE contains all and only the elements of SET1
     which are not also in SET2.
'ord_symdiff(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2.
'ord_disjoint_union(+SET1, +SET2, -UNION)'

     is true when SET1 and SET2 (given to be ordered sets) have no
     element in common, and UNION is their union.  The meaning is the
     same as
              ord_disjoint(Set1, Set2),
              ord_union(Set1, Set2, Union)
     but it is more efficient.
'ord_union(+SET1, +SET2, -UNION)'

     is true when UNION is the union of SET1 and SET2.  Note that when
     something occurs in both sets, we want to retain only one copy.
'ord_union(+OLDSET, +NEWSET, -UNION, -REALLYNEW)'
     is true when UNION is NEWSET U OLDSET and REALLYNEW is NEWSET \
     OLDSET.  This is useful when you have an iterative problem, and
     you're adding some possibly new elements (NEWSET) to a set
     (OLDSET), and as well as getting the updated set (UNION) you would
     like to know which if any of the "new" elements didn't already
     occur in the set (REALLYNEW).
'ord_union(+LISTOFSETS, -UNION)'
     is true when LISTOFSETS is given as a proper list of ordered sets
     and UNION is their union.  Letting K be the length of LISTOFSETS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).
'ordset_order(+XS, +YS, -R)'

     is true when R is '<', '=', or '>' according as XS is a subset of
     YS, equal to YS, or a superset of YS.  XS and YS are ordered sets.


File: sicstus.info,  Node: lib-pillow,  Next: lib-plunit,  Prev: lib-ordsets,  Up: The Prolog Library

10.32 The PiLLoW Web Programming Library--'library(pillow)'
===========================================================

The PiLLoW library ("Programming in Logic Languages on the Web") is a
free Internet/WWW programming library for Logic Programming Systems that
simplifies the process of writing applications for such environment.
The library provides facilities for generating HTML or XML structured
documents by handling them as Prolog terms, producing HTML forms,
writing form handlers, processing HTML templates, accessing and parsing
WWW documents (either HTML or XML), accessing code posted at HTTP
addresses, etc.

   PiLLoW is documented in its own reference manual, located in
<http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc_html/pillow_doc_toc.html>
(HTML) or <http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc.ps>
(Postscript).  The following points are worth noting wrt. the PiLLoW
reference manual:

   * PiLLoW is automatically installed with the SICStus Prolog
     distribution.  No extra action needs to be taken.

   * PilloW comes as a single library module, 'library(pillow)'.

     This subsumes the various 'load_package/1' and 'use_module/1'
     queries mentioned in the PiLLoW reference manual.

   Further information can be found at the PiLLoW home page,
<http://clip.dia.fi.upm.es/Software/pillow/pillow.html>.


File: sicstus.info,  Node: lib-plunit,  Next: lib-process,  Prev: lib-pillow,  Up: The Prolog Library

10.33 Plunit Interface--'library(plunit)'
=========================================

* Menu:

* PlUnit Introduction:: Introduction
* PlUnit A Unit Test Box:: A Unit Test Box
* PlUnit Running the Test-Suite:: Running the Test-Suite
* PlUnit Tests and Production Systems:: Tests and Production Systems


File: sicstus.info,  Node: PlUnit Introduction,  Next: PlUnit A Unit Test Box,  Up: lib-plunit

10.33.1 Introduction
--------------------

This library module provides a Prolog unit-test framework, initially
developed by Jan Wielemaker for SWI-Prolog.  The code and documentation
was subsequently adapted for SICStus Prolog by SICS. The module is a
third-party product, and not part of SICStus Prolog proper.

   Automatic testing of software during development is probably the most
important Quality Assurance measure.  Tests can validate the final
system, which is nice for your users.  However, most (Prolog) developers
forget that it is not just a burden during development.

   * Tests document how the code is supposed to be used.
   * Tests can validate claims you make on the Prolog implementation.
     Writing a test makes the claim explicit.
   * Tests avoid big applications saying "no" after modifications.  This
     saves time during development, and it saves _a lot_ of time if you
     must return to the application a few years later or you must modify
     and debug someone else's application.


File: sicstus.info,  Node: PlUnit A Unit Test Box,  Next: PlUnit Running the Test-Suite,  Prev: PlUnit Introduction,  Up: lib-plunit

10.33.2 A Unit Test Box
-----------------------

Tests are written in normal Prolog.  A unit test is a named collection
of individual tests, enclosed within the directives:
     ':- begin_tests(UNIT[,OPTIONS]).'

and:
     ':- end_tests(UNIT).'

   They can be embedded inside a normal source module, or be placed in a
separate test-file that loads the files to be tested.  The individual
tests are defined by rules of the form:
     'test(NAME[,OPTIONS]) :- TEST-BODY.'

where NAME is a ground term and OPTIONS is a list describing additional
properties of the test.  Here is a very simple example:

     :- use_module(library(lists)).

     :- begin_tests(lists).

     test(reverse) :-
             reverse([a,b], [b,a]).

     :- end_tests(lists).

   The optional second argument of the unit test declaration as well as
of the individual test-heads defines additional processing options.  The
following options are available:

'blocked(REASON)'

     The test is currently disabled.  Tests are flagged as blocked if
     they cannot be run for some reason.  E.g. they crash Prolog, they
     rely on some service that is not available, they take too much
     resources, etc.  Tests that fail but do not crash, etc.  should be
     flagged using 'fixme(FIXME)'.  REASON should be an atom.

     If this option appears more than once in a list of options, all but
     one of the occurrences are silently ignored.

'fixme(REASON)'

     Similar to 'blocked(FIXME)', but the test is executed anyway.  A
     summary is printed at the end of the test run.  REASON should be an
     atom.

     If this option appears more than once in a list of options, all but
     one of the occurrences are silently ignored.

'condition(GOAL)'

     Precondition for running the test.  If the condition fails, then
     the test is skipped.  The condition can be used as an alternative
     to the 'setup' option.  The only difference is that failure of a
     condition skips the test and is considered an error when using the
     'setup' option.  GOAL should be a callable.

     If this option appears more than once in a list of options, the
     occurrences are combined into a conjunction, in the order they
     appear.

'nondet'

     Available for individual test rules only.  Unless this keyword
     appears in the option list, nondeterminate success of the test-body
     is considered an error.

     It is an error to specify this more than once in a list of options.

'forall(GENERATOR)'

     Available for individual test rules only.  Runs the same test for
     each solution of GENERATOR.  Each run invokes the 'setup' and
     'cleanup' handlers.  This can be used to run the same test with
     different inputs.  If an error occurs, then the test is reported as
     'name (forall bindings = VARS)', where VARS indicates the bindings
     of variables in GENERATOR, which should be a callable.

     It is an error to specify this more than once in a list of options.

'setup(GOAL)'

     GOAL is run before the test-body.  Typically used together with the
     'cleanup' option to create and destroy the required execution
     environment.  GOAL should be a callable.

     If this option appears more than once in a list of options, the
     occurrences are combined into a conjunction, in the order they
     appear.

'cleanup(GOAL)'

     GOAL is always called after completion of the test-body, regardless
     of whether it fails, succeeds or raises an exception.  This option
     or 'call_cleanup/2' must be used by tests that require side effects
     that must be reverted after the test completes.  GOAL may share
     variables with a setup option and should be a callable.

     If this option appears more than once in a list of options, the
     occurrences are combined into a conjunction, in the order they
     appear.

          :- use_module(library(file_systems)).

          :- begin_tests(hello).

          create_file(Tmp) :-
                  open(temp(plunit), write, Out, [if_exists(generate_unique_name)]),
                  current_stream(Tmp, write, Out),
                  portray_clause(Out, hello(_World)),
                  close(Out).

          test(read, [setup(create_file(Tmp)), cleanup(delete_file(Tmp))]) :-
                  see(Tmp),
                  read(Term),
                  seen,
                  Term = hello(_).

          :- end_tests(hello).


     *Please note*: Do not place directives that load source code
     between ':- begin_tests(UNIT[,OPTIONS])' and ':- end_tests(UNIT)'.
     Loading source files in this context can cause spurious error
     messages.

   The following options specify how to verify the result of the
test-body, and are only available for individual test rules.  Unless
stated otherwise, it is an error if more than one of them appears in a
list of options.  In some cases there are additional restrictions on
which options can appear together.

'true'
'true(TEST)'

     The test-body as well as the goal TEST must succeed.  TEST defaults
     to 'true' and should be a callable that typically shares variables
     with the test-body.  This is the same as inserting the test at the
     end of the conjunction, but makes the test harness print a "wrong
     answer" message as opposed to a general failure message.

     If this option appears more than once in a list of options, the
     occurrences are combined into a conjunction, in the order they
     appear.

          test(badadd, [true(A =:= 4)]) :-
                  A is 1 + 2.

     will yield the error message:

          ! /home/matsc/sicstus4/doc/foo.pl:11:
          !       test badadd: wrong answer (compared using =:=)
          !     Expected: 4
          !     Got:      3

'all(ANSWERTERM CMP INSTANCES)'

     Similar to 'true(ANSWERTERM CMP INSTANCES)', but used if you want
     to collect all solutions to a nondeterminate test.  ANSWERTERM
     should share variables with the test-body.  Let ALL be the list of
     instances of ANSWERTERM for each solution.  Then the goal
     'CMP(ALL,INSTANCES)' must succeed.  The tests in the example below
     are equivalent.

     It is an error to specify this together with 'nondet'.

          test(all1, all(X == [1,2])) :-
                  (X = 1 ; X = 2).

          test(all2, true(Xs == [1,2])) :-
                  findall(X, (X = 1 ; X = 2), Xs).

'set(ANSWERTERM CMP INSTANCES)'

     Similar to 'all(ANSWERTERM CMP INSTANCES)', but sorts the
     ANSWERTERM instances before the comparison.  The tests in the
     example below are equivalent.

     It is an error to specify this together with 'nondet'.

          test(set1, set(X == [1,2])) :-
                  (X = 2 ; X = 1 ; X = 1).

          test(set2, true(Ys == [1,2])) :-
                  findall(X, (X = 2 ; X = 1 ; X = 1), Xs),
                  sort(Xs, Ys).

'fail'

     The test-body must fail.

     It is an error to specify this together with 'nondet'.

'exception(EXPECTED)'
'throws(EXPECTED)'

     The test-body must raise an exception RAISED that is checked wrt.
     EXPECTED using 'subsumes_term(EXPECTED, RAISED)'.  I.e. the raised
     exception must be more specific than the specified EXPECTED.

     It is an error to specify this together with 'nondet'.

'error(ISO)'
'error(ISO,INFO)'

     A shorthand for 'exception(error(ISO,INFO))'.  INFO defaults to an
     anonymous variable.

     It is an error to specify this together with 'nondet'.

10.33.3 Writing the Test-Body
-----------------------------

* Menu:

* PlUnit Determinate Tests:: Determinate Tests
* PlUnit Nondeterminate Tests:: Nondeterminate Tests
* PlUnit Tests Expected to Fail:: Tests Expected to Fail
* PlUnit Tests Expected to Raise Exceptions:: Tests Expected to Raise Exceptions

The test-body is ordinary Prolog code.  Without any options, the
test-body must be designed to succeed _determinately_.  Any other result
is considered a failure.  One of the options 'fail', 'true',
'exception', 'throws' or 'error' can be used to specify a different
expected result.  In this subsection we illustrate typical
test-scenarios by testing built-in and library predicates.


File: sicstus.info,  Node: PlUnit Determinate Tests,  Next: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.33.3.1 Determinate Tests
...........................

Determinate tests are tests that must succeed exactly once, leaving no
choicepoints behind.  The test-body supplies proper values for the input
arguments and verifies the output arguments.  Verification can use
test-options or be explicit in the test-body.  The tests in the example
below are equivalent.

     test(add1) :-
             A is 1 + 2,
             A =:= 3.

     test(add2, [true(A =:= 3)]) :-
             A is 1 + 2.

   The test engine verifies that the test-body does not leave a
choicepoint.  We illustrate this using the test below:

     test(member1) :-
             member(b, [a,b,c]).

   Although this test succeeds, 'member/2' leaves a choicepoint behind,
which is reported by the test harness.  To make the test silent, use one
of the alternatives below.

     test(member2) :-
             memberchk(b, [a,b,c]).

     test(member3) :-
             member(b, [a,b,c]), !.

     test(member4, [nondet]) :-
             member(b, [a,b,c]).


File: sicstus.info,  Node: PlUnit Nondeterminate Tests,  Next: PlUnit Tests Expected to Fail,  Prev: PlUnit Determinate Tests,  Up: PlUnit A Unit Test Box

10.33.3.2 Nondeterminate Tests
..............................

Nondeterminate tests succeed zero or more times.  Their results can be
tested using 'findall/3' followed by a value-check.  The following are
equivalent tests:

     test(member5) :-
             findall(X, member(X, [a,b,c]), Xs),
             Xs == [a,b,c].

     test(member6, true(Xs == [a,b,c])) :-
             findall(X, member(X, [a,b,c]), Xs).


File: sicstus.info,  Node: PlUnit Tests Expected to Fail,  Next: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.33.3.3 Tests Expected to Fail
................................

Tests that are expected to fail may be specified using the option 'fail'
or by negating the test-body using '\+'.

     test(is_set) :-
             \+ is_set([a,a]).

     test(is_set, [fail]) :-
             is_set([a,a]).


File: sicstus.info,  Node: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Tests Expected to Fail,  Up: PlUnit A Unit Test Box

10.33.3.4 Tests Expected to Raise Exceptions
............................................

Tests that are expected to raise exceptions may be specified using the
option 'exception(EXPECTED)' or one of its equivalents, or by wrapping
the test in 'on_exception/3' or 'catch/3'.  The following tests are
equivalent:

     test(div01) :-
          on_exception(Excp, A is 1/0, true),
          subsumes_term(error(evaluation_error(zero_divisor),_), Excp).

     test(div02, [error(evaluation_error(zero_divisor))]) :-
          A is 1/0.

     test(div03, [error(evaluation_error(zero_divisor),_)]) :-
          A is 1/0.

     test(div04, [exception(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.

     test(div05, [throws(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.


File: sicstus.info,  Node: PlUnit Running the Test-Suite,  Next: PlUnit Tests and Production Systems,  Prev: PlUnit A Unit Test Box,  Up: lib-plunit

10.33.4 Running the Test-Suite
------------------------------

At any time, the tests can be executed by loading the program and
running 'run_tests/[0,1,2]':

'run_tests'

     Run all individual tests of all test-units.

'run_tests(SPEC)'
'run_tests(SPEC,OPTIONS)'
     Run only the specified tests.  The following options are available:

     'quiet'
          Suppresses informational messages.
     'verbose'
          Prints informational messages, e.g. messages for each
          successful test.  This is the default.
     'passed(Count)'
     'failed(Count)'
     'skipped(Count)'

          Binds COUNT to the number of non-blocked tests that were
          successful, failed or skipped, respectively.  A test is
          skipped if one of its conditions fails.

          The following will quietly run all tests, but print messages
          and fail if any of the tests were unsuccessful.
               | ?- run_tests(all, [failed(0), quiet]).

     SPEC should be one of:

        * The atom 'all', to run all tests.  This is the default i.e.
          what 'run_tests/0' does.
        * a term UNIT where UNIT is the name of a test-unit, denotes all
          individual tests of the test-unit UNIT, or
        * a term UNIT:TEST where UNIT is the name of a test-unit and
          TEST is one of its individual tests, denotes the given test
          only, or
        * a term UNIT:LIST where UNIT is the name of a test-unit and
          LIST is a list of its individual tests, denotes the given list
          of tests, or
        * finally, a list of terms of one of the above forms.

   Running single tests is particularly useful for tracing a test, e.g.:

     | ?- trace, run_tests(lists:reverse).

   'run_tests/[0,1,2]' prints a report during execution.  The 'quiet'
options suppresses informational messages; in its absence, messages are
printed in full as follows.

   First, each test-unit report begins with a header:

     '% PL-Unit: UNIT'

   Then comes a message (success or failure) for all specified tests not
marked as 'blocked' or 'fixme'.  Success messages are informational;
others are error or warning messages.  Any errors encountered while
executing options are also reported.  To close the test-unit, a footer
is printed:

     '% done'

   After all test-units, a summary report is printed, stating:

   * how many tests passed resp.  failed and how may test were skipped
   * which tests were blocked
   * details for each test marked as 'fixme'


File: sicstus.info,  Node: PlUnit Tests and Production Systems,  Prev: PlUnit Running the Test-Suite,  Up: lib-plunit

10.33.5 Tests and Production Systems
------------------------------------

Most applications do not want the test-suite to end up in the final
application.  There are several ways to achieve this.  One way is to
place all tests in separate files and not to load the tests when
creating the production environment.  Another way is to wrap each unit
test box in a pair of ':- if(...)', ':- endif' directives.  For example,
the test could be whether the 'plunit' module has been loaded:

     :- if(current_module(plunit)).
     :- begin_tests(UNIT[,OPTIONS]).
     ...
     :- end_tests(UNIT).
     :- endif.

   Alternatively, you can reserve a system property e.g.
'enable_unit_tests' to control whether unit tests should be enabled.
The property is enabled if you run SICStus Prolog as:

     % sicstus -Denable_unit_tests=true

   Then your Prolog source file could have the structure:

     :- use_module(library(system), [environ/2]).

     ...

     :- if(environ(enable_unit_tests, true)).
     :- use_module(library(plunit)).
     :- begin_tests(UNIT[,OPTIONS])
     ...
     :- end_tests(UNIT)
     :- endif.


File: sicstus.info,  Node: lib-process,  Next: lib-prologbeans,  Prev: lib-plunit,  Up: The Prolog Library

10.34 Process Utilities--'library(process)'
===========================================

This package contains utilities for process creation.

   A process is represented by a "process reference", a ground compound
term.  Both SICStus and the operating system maintain a state for each
such process reference and they must therefore be released, either
explicitly with 'process_release/1' or implicitly by
'process_wait/[2,3]'.  Process references are created with
'process_create/[2,3]' if explicitly requested with the 'process/1'
option.  Process references are required in order to obtain the exit
status of a process after 'process_create/[2,3]' has returned.

   Many of the predicates can accept a numeric operating system process
id ("PID") but since process ids are subject to re-use by the OS this is
less reliable and does not work if the process has already exited.

10.34.1 Examples
----------------

The following illustrates some common tasks.  The process library is
portable and works on all supported platforms, including UNIX, Linux and
Windows.  However, the examples are by necessity platform dependent.
Unless otherwise noted, the examples will work on UNIX and similar
systems only.

   (If you are looking for something like the old SICStus 3
'system:system/1' and 'system:popen/3', *Note unsafe_system::.)

  1. Run the 'date' command in the standard shell 'sh'.  The output of
     the command is sent to the terminal:
          | ?- process_create(path(sh),
               ['-c', date]).

  2. Run the 'date' command in the standard shell 'sh'.  Wait for the
     command to terminate before returning to Prolog.  Fail if the
     process gets an error.  The output of the command is sent to the
     terminal:
          | ?- process_create(path(sh),
               ['-c', date], [wait(exit(0))]).
     Using 'wait/1' option in this way is a convenient way to ensure
     that the command has finished before Prolog continues.

  3. Run the 'date' command in the standard shell 'sh'.  The output of
     the command is received by Prolog:
          | ?- process_create(path(sh),
               ['-c', date], [stdout(pipe(S))]),
               read_line(S,L), close(S), atom_codes(Date,L).
          ...,
          Date = 'Fri Jan 24 12:59:26 CET 2014' ?

  4. Pipe the output of the 'date' command to a file:
          | ?- process_create(path(sh),
               ['-c', [date, '>', file('/tmp/foo.txt')]]).

  5. Count the number of words in an atom, using the 'wc' command:
          | ?- process_create(path(wc), ['-w'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               write(In, 'a b c\n'), close(In),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 3
     It may be preferable to let the input or output go via a file.
     This avoids deadlock in case the stream buffers fill up.

  6. Count the number of unique words in a file, piping the output of
     the 'uniq' command to the 'wc' command:
          | ?- process_create(path(sh),
               ['-c', ['uniq ', file('/tmp/foo.txt'), ' | wc -w']],
               [stdout(pipe(Out))]),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 6
     Note that quoting is a problem (and potential security issue), so
     *never* pass untrusted data, like file names, to the shell using
     '-c' (*note Quoting and Security::).

  7. Run the 'make' command with the '-n' (dry run) option, discarding
     output, fail if it does not succeed:
          | ?- process_create(path(make), ['-n'],
               [stdout(null), wait(Exit)]),
               Exit = exit(0).
     By using the 'wait/1' option, 'process_create/3' will not return
     until the subprocess has exited and its exit status is available.

  8. Run 'ls' on a home directory in a subshell using the user's
     preferred shell:
          | ?- process_create('$SHELL', ['-c', [ls, ' ', file('~/') ]]).

  9. Run a command with output piped from a file and input provided by
     Prolog.  This is similar to 'popen('cat > ./myscript.sh',write,S)'
     in SICStus 3.  This example also shows one way to create a shell
     script which is useful when more advanced shell interaction is
     needed.  (The created script outputs the most common line in its
     input.  It is used in the next example.)
          | ?- process_create(path(sh),
               ['-c',
               'cat > ./myscript.sh && chmod a+x ./myscript.sh'],
               [stdin(pipe(S))]),
               write(S, '#! /bin/sh\n'),
               write(S, 'sort | uniq -c | sort -nr | head -n 1\n'),
               close(S).
     Please read *note Quoting and Security:: for problems with this
     approach.

  10. Run a shell script with input piped from a file and output read by
     Prolog.  This is similar to 'popen('./myscript.sh <
     ./somefile.txt',read,S)' in SICStus 3.
          | ?- open('somefile.txt',write,OF),
               write(OF,'hello\nworld\nhello\nhello\n'),close(OF),
               process_create(path(sh),
               ['-c', './myscript.sh < ./somefile.txt'],
               read_line(S, L), atom_codes(Line, L), close(S).
          ...,
          Line = '   3 hello' ?
     Please read *note Quoting and Security:: for problems with this
     approach.

  11. Run a goal in a SICStus subprocess (UNIX and Windows):
          | ?- process_create(application(sicstus),
               ['-f', '--noinfo', '--nologo',
               '--goal', 'read(X), call(X), halt.'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               format(In,'~q .~n', [(length([h,e,l,l,o], Len),
                                     format('~q .~n', [Len]))]),
               close(In), read(Out,Answer), close(Out).
          ...,
          Answer = 5

  12. Run 'notepad.exe' on a file 'C:/foo.txt' under Windows:
          | ?- process_create('$SYSTEMROOT/notepad.exe',
               [file('C:/foo.txt')]).
  13. Open a command shell in a separate window under Windows:
          | ?- process_create('$COMSPEC',[],[window(true)]).

10.34.1.1 Microsoft Windows Shell
.................................

On Windows, it is not possible to pass multiple parameters to a
subprocess.  When a subprocess is started, it receives exactly one
argument and a quoting convention must be used to encode the parameters
as the single argument actually passed to the process.

   Unfortunately, there is no such universal quoting convention, every
program can interpret its (single) argument in any way it sees fit.

   Most programs use a convention established by the Microsoft C
library.  This is the convention used by 'process_create/[2,3]' and it
usually works well.

   However, the command processor on Windows ('cmd.exe') does not use
the common convention and, except for very simple cases, passing
arguments to 'cmd.exe' will not work reliably.

   *Please note*: Passing arguments to 'cmd.exe' suffers from the same
security vulnerabilities as those described in *note Quoting and
Security::, below.

   If you want to run commands using 'cmd.exe', it is best to create a
batch ('.bat') file with your commands and then tell 'cmd.exe' to run
the batch file.

   The following example illustrates how to create a Windows batch file
that pipes some output to a file ('COMSPEC' is an environment variable
containing the path to 'cmd.exe'):
     | ?- BatFileName='test.bat',
          open(BatFileName, write, S),
          write(S, 'date /T > "result.txt"\n'), close(S),
          process_create('$COMSPEC', ['/Q', '/C', file(BatFileName)],
          [wait(exit(0))]),
          open('result.txt', read, R),
          read_line(R,L),close(R),atom_codes(Date,L).
     ...,
     Date = '2014-01-27 ',
     ... ?

   More recent versions of Windows come with a redesigned command line
processor, 'PowerShell', which solves the problems associated with the
traditional 'cmd.exe' command line processor.  In particular, it has a
very general way to encode command line arguments, using 'base-64'
encoding.  Currently, there is no direct support for PowerShell in this
library, but the following example shows how to get the current week day
both using a plain text command and with a base-64-encoded command

     | ?- Command = '(get-date).DayOfWeek',
          process_create(path(powershell),
          ['-Command', Command],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?

     | ?- EncodedCommand =
            'KABnAGUAdAAtAGQAYQB0AGUAKQAuAEQAYQB5AE8AZgBXAGUAZQBrAA==',
          process_create(path(powershell),
          ['-encodedCommand', EncodedCommand],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?
where the ENCODEDCOMMAND value was created by encoding the string
''(get-date).DayOfWeek'' using Base 64.  See the PowerShell
documentation for details.

10.34.2 Quoting and Security
----------------------------

It easy to get undesired, and possibly harmful, effects if arbitrary
data is passed without proper quoting to a shell.  For instance,
accepting arbitrary file names and passing them as part of a command
line to a subshell can cause the shell to execute arbitrary, possibly
malicious, code.

   The following, vulnerable, predicates suffer from this problem.  They
are similar to predicates that existed in SICStus 3, and their fragility
is one of the reasons process interaction was redesigned in SICStus 4.
     % DO NOT USE. This code is vulnerable.
     % Similar to system:system/1 in SICStus 3.
     unsafe_system(Cmd) :-
        % pass Cmd to shell, wait for exit, fail on error.
        process_create(path(sh), ['-c', Cmd], [wait(exit(0))]).

     % DO NOT USE. This code is vulnerable.
     % Similar to system:popen/3 in SICStus 3.
     unsafe_popen(Cmd, Direction, Pipe) :-
        % pass Cmd to shell, do not wait for exit,
        % connect to stdin or stdout of subprocess.
        ( Direction == read ->
          process_create(path(sh), ['-c', Cmd], [stdout(pipe(Pipe))])
        ; Direction == write ->
          process_create(path(sh), ['-c', Cmd], [stdin(pipe(Pipe))])
        ).

   Now consider the task of passing the contents of some file FILE to a
command 'mycommand'.  You may think the following is a good idea (it is
not!):

     % DO NOT USE. This code is vulnerable.
     unsafe_command(File, S) :-
        atom_concat('./mycommand < ', File, Cmd),
        unsafe_popen(Cmd, read, S).

   That works as expected if the the 'File' argument is a plain file
with no characters that has special meaning to the shell, e.g.
     File = './somefile.txt',
     unsafe_command(File, S), read_line(S,L),close(S).

   However, assume that the file name was obtained from some untrusted
source and consider the following example:
     File = '$(say bohoo)',
     unsafe_command(File, S), read_line(S,L),close(S).
depending on the system this can have a quite scary effect, and
illustrates how shell meta characters in the constructed command line
can lead to potentially dangerous results.

   The safest way to interact with the shell is to create shell scripts
and pass arguments to the scripts as separate arguments to the shell.
E.g.
     % A safer version
     safer_command(File, S) :-
        % pass the file as the first argument to mycommand.
        process_create(path(sh),
                       ['-c', file('./mycommand'), file(File)],
                       [stdout(pipe(S))]).
   Exported predicates:

'process_create(+FILE, +ARGS)'
'process_create(+FILE, +ARGS, :OPTIONS)'

     Start a new process running the program identified by FILE and the
     arguments specified in ARGS.  The standard streams of the new
     process can be redirected to prolog streams.  The exit status of
     the process can be obtained with 'process_wait/[2,3]'.

     FILE, is expanded as if by 'absolute_file_name/2' (with arguments
     'access(execute)' and 'file_type(executable)') and is used to
     locate the file to execute.

     The predefined file search path 'path/1' (*note ref-fdi::) is
     especially useful here since it makes it easy to look up the names
     of an executable in the directories mentioned by the 'PATH'
     environment variable.  To run the Windows command shell 'cmd' you
     would simply specify 'path('cmd.exe')' (or 'path(cmd)'), to start
     the UNIX Bash shell you would specify 'path(bash)'.

     ARGS is a list of argument specifications.  Each argument
     specification is either a simple argument specification, see below,
     or a non-empty list of simple argument specifications.  The
     expanded value of each element of ARGS is concatenated to produce a
     single argument to the new process.  A "simple argument
     specification" can be one of:

     an atom
          The atom name is used as the expanded value.  Some operating
          systems only support 7-bit ASCII characters here.  Even when
          some larger subset of Unicode is used it may not work
          correctly with all programs.

     'file(FILE)'
          FILE, an atom, is treated as a file name and subject to an
          operating system specific transformation to ensure file name
          syntax and character set is appropriate for the new process.
          This is especially important under Windows where it ensures
          that the full Windows Unicode character set can be used.

          *Please note*: The FILE part of 'file(FILE)' is not subject to
          syntactic rewriting, the argument specification 'file/1' only
          adjusts for differences in file name syntax and character
          encoding between SICStus and the operating system.  You must
          explicitly call 'absolute_file_name/[2,3]' if you want to
          expand file search paths etc.

     OPTIONS is a list of options:

     'stdin(SPEC)'
     'stdout(SPEC)'
     'stderr(SPEC)'
          Each SPEC specifies how the corresponding standard stream of
          the new process should be created.  SPEC can be one of:
          'std'
               The new process shares the (OS level) standard stream
               with the Prolog process.  This is the default.  Note
               that, especially under Windows, the Prolog process may
               not have any OS level standard streams, or the OS streams
               may not be connected to a console or terminal.  In such a
               case you need to use 'pipe/[1,2]' spec, see below, and
               explicitly read (write) data from (to) the process.
          'null'
               The stream is redirected to a null stream, i.e. a stream
               that discards written data and that is always at end of
               file when read.
          'pipe(STREAM)   since release 4.0'
          'pipe(STREAM, STREAMOPTIONS)   since release 4.3.2'

               A new Prolog stream is created and connected to the
               corresponding stream of the new process.  STREAMOPTIONS
               is a list of options affecting the created stream.  The
               supported stream options are: 'type/1', 'eol/1', and
               'encoding/1', with the same meaning as for 'open/4'
               (*note mpg-ref-open::).

               The default, if no stream options are specified, is to
               use a text stream with the OS default character encoding.

               This stream must be closed using 'close/[1,2]', it is not
               closed automatically when the new process exits.

     'wait(-EXITSTATUS)   since release 4.3'
          The call will not return until the sub-process has terminated.
          EXITSTATUS will be bound to the exit status of the process, as
          described for 'process_wait/2'.
     'process(PROC)'
          PROC will be bound to a process reference that can be used in
          calls to 'process_wait/[2,3]' etc..  This process reference
          must be released, either explicitly with 'process_release/1'
          or implicitly by 'process_wait/[2,3]'.  It is often easier to
          use the 'wait/1' option if you just want to wait for the
          process to terminate.

     'detached(BOOL)'
          BOOL is either 'true' or 'false'.  Specifies whether the new
          process should be "detached", i.e. whether it should be
          notified of terminal events such as '^C' interrupts.  By
          default a new process is created detached if none of the
          standard streams are specified, explicitly or implicitly, as
          'std'.

     'cwd(CWD)'

          CWD is expanded as if by 'absolute_file_name/2' and is used as
          the working directory for the new process.

          By default, the working directory is the same as the Prolog
          working directory.

     'window(BOOL)'
          BOOL is either 'true' or 'false' (the default).  Specifies
          whether the process should open in its own window.

          Specifying 'window(true)' may give unexpected results if the
          standard stream options 'stdin/1', 'stdout/1' and 'stderr/1'
          are specified with anything but their default value 'std'.

          Currently only implemented on Windows.

     'environment(ENV)   since release 4.1'

          ENV is a list of 'VAR=VALUE' for extra environment variables
          to pass to the sub-process in addition to the default process
          environment.  VAR should be an atom.  VALUE should be an
          argument specification, as described above.  The VALUE is
          typically an atom but, especially on the Windows platform, it
          may be necessary to wrap file names in 'file/1' to ensure file
          paths are converted to the native format.  *Note System
          Properties and Environment Variables: (sicstus)System
          Properties and Environment Variables, for more information.

'process_wait(+PROCESS, -EXITSTATUS)'
'process_wait(+PROCESS, -EXITSTATUS, +OPTIONS)'

     Wait for a process to exit and obtain the exit status.

     PROCESS is either a process reference obtained from
     'process_create/3' or an OS process identifier.  Specifying a
     process identifier is not reliable.  The process identifier may
     have been re-used by the operating system.  Under Windows, it is
     not possible to obtain the exit status using a process identifier
     if the process has already exited.

     EXITSTATUS is one of:
     'exit(EXITCODE)'
          The process has exited with exit code EXITCODE.  By convention
          processes use exit code zero to signify success and a
          (positive) non-zero value to specify failure.
     'killed(SIGNALNUMBER)'
          UNIX only, the process was killed by signal 'SignalNumber' (a
          positive integer).

     'timeout'
          The 'timeout/1' option was specified and the process did not
          exit within the specified interval.  In this case the process
          reference is not released, even if the 'release/1' option is
          specified.
     OPTIONS is a list of options:
     'timeout(SECONDS)'
          Specify a maximum time, in seconds, to wait for the process to
          terminate.  SECONDS should be an integer or floating point
          number or the atom 'infinite' (the default) to specify
          infinite wait.  If the specified timeout interval passes
          before the process exits, 'process_wait/3' exits with
          EXITSTATUS set to 'timeout' and the process reference is not
          released.

          Currently the UNIX implementation supports only timeout values
          0 (zero) and 'infinite'.

     'release(BOOL)'
          BOOL is either 'true' (the default) or 'false'.  Specifies
          whether the process reference should be released when
          'process_wait/3' exits successfully.
'process_id(-PID)'

     Obtain the process identifier of the current (i.e. Prolog) process.
'process_id(+PROCESS, -PID)'

     Obtain the process identifier of the process reference PROCESS.
'is_process(+THING)'

     Returns true if THING is a process reference that has not been
     released.
'process_release(+PROCESS)'

     Release a process reference PROCESS that has previously been
     obtained from 'process_create/3'.  This ensures that Prolog and the
     operating system can reclaim any resources associated with the
     process reference.

     Usually you would not call this.  Either do not request the process
     reference when calling 'process_create/3' or let
     'process_wait/[2,3]' reclaim the process reference when the process
     terminates.
'process_kill(+PROCESS)'
'process_kill(+PROCESS, +SIGNALSPEC)'

     Send a signal to the process designated by PROCESS.  The signal can
     either be a non-negative integer or a signal name as an (all
     uppercase) atom.

     The following signal names are accepted under UNIX if the platform
     defines them: 'SIGABRT', 'SIGALRM', 'SIGBUS', 'SIGCHLD', 'SIGCONT',
     'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGKILL' (the default),
     'SIGPIPE', 'SIGPOLL', 'SIGPROF', 'SIGQUIT', 'SIGSEGV', 'SIGSTOP',
     'SIGSYS', 'SIGTERM', 'SIGTRAP', 'SIGTSTP', 'SIGTTIN', 'SIGTTOU',
     'SIGURG', 'SIGUSR1', 'SIGUSR2', 'SIGVTALRM', 'SIGXCPU' and
     'SIGXFSZ'.  However, many of these do not make sense to send as
     signals.

     Under Windows, which does not have the signal concept, the signal
     name 'SIGKILL' (the default) is treated specially and terminates
     the process with 'TerminateProcess(Process, -1)'.  *Please note*:
     Using 'process_kill/[2,3]' on Windows is not recommended.  Also, on
     Windows, the call may throw an error if the process has already
     exited.


File: sicstus.info,  Node: lib-prologbeans,  Next: lib-queues,  Prev: lib-process,  Up: The Prolog Library

10.35 PrologBeans Interface--'library(prologbeans)'
===================================================

* Menu:

* PB Intro:: Introduction
* PB Features:: Features
* PB First Example:: A First Example
* PB Prolog Server Interface:: Prolog Server Interface
* PB Java Client Interface:: Java Client Interface
* PB Java Examples:: Java Examples
* PB .NET Client Interface:: .NET Client Interface
* PB .NET Examples:: .NET Examples


File: sicstus.info,  Node: PB Intro,  Next: PB Features,  Up: lib-prologbeans

10.35.1 Introduction
--------------------

PrologBeans is a package for integrating Prolog with applications
written in other languages.  Currently Java and .NET are supported.
PrologBeans is based on running Prolog as a separate server process, and
the other part of the application as a client process.  This makes
PrologBeans automatically distributable since the server and the client
can run on different computers anywhere on the Internet.

   PrologBeans is designed to be used when client applications need to
send queries to a Prolog server (and less intended for showing a GUI
from a Prolog program).  One typical application would be to connect a
Java or .NET based web application to a Prolog server (see examples
later).

 [image src="images/prologbeansarch.png" text="" ]
   _PrologBeans setup where the Prolog application serves several users
accessing both via a web application server and a .NET GUI._

   The PrologBeans package consists of two parts.  The Prolog server is
a library module, 'library(prologbeans)'.  The client is a class
library, 'prologbeans.jar' for Java (installed on all platforms), and
'prologbeans.dll' for .NET (only installed on Microsoft Windows
platforms).


File: sicstus.info,  Node: PB Features,  Next: PB First Example,  Prev: PB Intro,  Up: lib-prologbeans

10.35.2 Features
----------------

The current version of PrologBeans is designed to be used mainly as a
connection from the client (Java or .NET) to Prolog.  Current features
are:

   * Socket based communication [Java and .NET]
   * Allows the client application and Prolog server to run on different
     machines [Java and .NET]
   * Multiple client applications can connect to same Prolog server
     [Java and .NET]
   * Client applications can make use of several Prolog servers [Java
     and .NET]
   * Allows Java Applets to access Prolog server [Java]
   * Platform independent (e.g. any platform where Prolog and Java or
     .NET exist) [Java and .NET]
   * Simplifies the use of Prolog in Java application servers (Tomcat,
     etc) [Java]
   * Prohibits unwanted use of Prolog server by host control (only
     specified hosts can access the Prolog server) [Java and .NET]
   * Supports Java servlet sessions [Java]
   * Supports JNDI lookup (Java Naming and Directory Interface) [Java]
   * Supports .NET server pages (ASPX). [.NET]


File: sicstus.info,  Node: PB First Example,  Next: PB Prolog Server Interface,  Prev: PB Features,  Up: lib-prologbeans

10.35.3 A First Example
-----------------------

This section provides an example to illustrate how PrologBeans can be
used.  This application has a simple Java GUI where the user can enter
expressions that will be evaluated by an expression evaluation server.

     import java.awt.*;
     import java.awt.event.*;
     import javax.swing.*;
     import se.sics.prologbeans.*;

     public class EvaluateGUI implements ActionListener {

       private JTextArea text = new JTextArea(20, 40);
       private JTextField input = new JTextField(36);
       private JButton evaluate = new JButton("Evaluate");
       private PrologSession session = new PrologSession();

       public EvaluateGUI() throws java.io.IOException
         {
         if ((Integer.getInteger("se.sics.prologbeans.debug", 0)).intValue() != 0) {
     	  session.setTimeout(0);
           }
         JFrame frame = new JFrame("Prolog Evaluator");
         Container panel = frame.getContentPane();
         panel.add(new JScrollPane(text), BorderLayout.CENTER);
         JPanel inputPanel = new JPanel(new BorderLayout());
         inputPanel.add(input, BorderLayout.CENTER);
         inputPanel.add(evaluate, BorderLayout.EAST);
         panel.add(inputPanel, BorderLayout. SOUTH);
         text.setEditable(false);
         evaluate.addActionListener(this);
         input.addActionListener(this);

         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.pack();
         frame.setVisible(true);

         session.connect();
       }

       public void actionPerformed(ActionEvent event) {
         try {
           Bindings bindings = new Bindings().bind("E",
                               input.getText() + '.');
           QueryAnswer answer =
             session.executeQuery("evaluate(E,R)", bindings);
           PBTerm result = answer.getValue("R");
           if (result != null) {
             text.append(input.getText() + " = " + result + '\n');
             input.setText("");
           } else {
             text.append("Error: " + answer.getError() + '\n');
           }
         } catch (Exception e) {
           text.append("Error when querying Prolog Server: " +
                       e.getMessage() + '\n');
           e.printStackTrace();
         }
       }

       public static void main(String[] args) throws java.io.IOException
       {
         new EvaluateGUI();
       }
     }

   The Java code above first sets up the GUI with a text area for
showing results, a text field for entering expressions, and a button for
requesting an evaluation (the constructor 'EvaluateGUI()').  It will
also add itself as 'ActionListener' on both the text field and the
button.  The method 'actionPerformed(ActionEvent event)' will be called
whenever the user has pressed <RET> or clicked on the button.
'actionPerformed' first binds the variable E to the value of the text
field, and then sends the query to the Prolog server with
'session.executeQuery("evaluate(E,R)", bindings);'.  If everything goes
well, then the Prolog server will return an answer (bound to R), which
will be appended to the text area.

     :- module(evaluate,[main/0,my_predicate/2]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register acceptable queries and start the server (using default port)
     main:-
         register_query(evaluate(C,P), my_predicate(C,P)),
         start.

     %% We have received a code list
     %% which needs to be converted into an expression
     my_predicate(Chars, P) :-
         read_from_codes(Chars, X),
         P is X.

   The Prolog code above first defines the module and imports the needed
modules.  Then, in the 'main/0' predicate, it configures the server to
answer queries on the form 'evaluate(C,P)' and starts the server.  The
last few lines defines the predicate 'my_predicate(Chars, P)', which is
the predicate that performs the evaluation.  Note that, here, the
expression to evaluate is represented as a code list and must be
converted into a term before evaluation.

   In general, arbitrary Prolog terms can be passed to the client via
this mechanism, including terms containing unbound variables.  However,
any unbound variables with attributes or blocked goals attached to them
will be replaced by plain, brand new variables.  This is analogous to
the way attributed variables are handled in terms that are written,
copied, asserted, gathered as solutions to 'findall/3' and friends, or
raised as exceptions.  If the attributes must be passed to the client,
then the Prolog code can obtain them by using 'copy_term/3' (*note
ref-lte-cpt::).

   *Please note*: the environment variable 'SP_PATH' as used here is
meant to be a shorthand (*note CPL Notes::), and does not need to be set
explicitly.

   To start the example, first start the Prolog server by going to the
'%SP_PATH%\library\prologbeans\examples\evaluate' (Windows), or
'$SP_PATH/library/prologbeans/examples/evaluate' (UNIX/Linux) directory
and type:

     % sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." EvaluateGUI (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." EvaluateGUI (UNIX)


File: sicstus.info,  Node: PB Prolog Server Interface,  Next: PB Java Client Interface,  Prev: PB First Example,  Up: lib-prologbeans

10.35.4 Prolog Server Interface
-------------------------------

The Prolog interface is based on the idea of a Prolog server that
provides its service by answering queries from external applications
(typically Java applications).  The Prolog interface in PrologBeans is
defined in 'library(prologbeans)', which implements the Prolog server
and exports the following predicates:

'start'
'start(+OPTIONS)'

     starts the Prolog server using the options specified.  *Please
     note*: 'start/[0,1]' will not return until a server shutdown
     occurs.  OPTIONS should be a list of zero or more of:

     'port(?VAL)'
          an integer denoting the port number of the Prolog server.  The
          default port, if no port option is present, is 8066.  In the
          case of the default port being used, the Socket Reuse Address
          bit will be set in the underlying sockets layer.  If 'VAL' is
          a variable, then some unused port will be selected by the OS,
          the actual port number can be obtained with
          'get_server_property/1', typically from a 'server_started'
          event listener.

     'accepted_hosts(+VAL)'
          a list of atoms denoting the hosts (in form of IP-addresses)
          that are accepted by the Prolog server (default:
          '['127.0.0.1']').

     'session_timeout(+VAL)'
          an integer denoting the duration of a session in seconds.  The
          session will be removed if it has been inactive more than this
          timeout when the session garbage collect starts.  If the
          session timeout is set to zero, then there will be no garbage
          collection of sessions (default: '0').

     'session_gc_timeout(+VAL)'
          an integer denoting the minimum time in seconds between two
          consecutive session garbage collections.  If the timeout is
          set to zero, then there will be no garbage collection of
          sessions (default: '0').

     For example:

          :- start([port(7500),
                    accepted_hosts(['127.0.0.1','99.8.7.6'])]).

'shutdown'
'shutdown(+Mode)'

     shuts down the server and closes the sockets and the streams after
     processing all available input.  There are three modes:
     'now'
          as soon as possible (default).
     'no_sessions'
          after all sessions have ended (all sessions have either been
          explicitly removed by request of the client application, or
          they have been garbage collected).  *Please note*: there can
          still be connections to the Prolog server even when all
          sessions have ended.
     'no_connections'
          after all connections to the Prolog server are closed.
          *Please note*: there can still be user sessions left when all
          connections have been closed.

'register_query(+QUERY, :PREDICATETOCALL)'
'register_query(+QUERY, :PREDICATETOCALL, +SESSIONVAR)'

     registers a query and the corresponding goal.  Before the
     registration, any previously registered query matching QUERY will
     be removed (as if by 'unregister_query(QUERY)').  The goal
     PREDICATETOCALL will be called when a query matching QUERY is
     received.

     Typically, QUERY and PREDICATETOCALL share variables that are
     instantiated by the call, and the instantiated QUERY is passed back
     to the client.  In general, variable bindings can be arbitrary
     Prolog terms, including terms containing unbound variables.
     However, any unbound variables with attributes or blocked goals
     attached to them will be replaced by plain, brand new variables.
     This is analogous to the way attributed variables are handled in
     terms that are written, copied, asserted, gathered as solutions to
     'findall/3' and friends, or raised as exceptions.  If the
     attributes must be passed to the client, then the Prolog code can
     obtain them by using 'copy_term/3' (*note ref-lte-cpt::).

     The goal is called determinately, i.e. it is never backtracked
     into.  If it fails, then the term 'no' is passed to the client
     instead of the instantiated QUERY.  If it raises an exception E,
     then the term 'error(E)' is passed to the client instead of the
     instantiated QUERY.

     Before calling the query, the variable SESSIONVAR, if given, is
     bound to the id of the current session.  Session ids are typically
     generated in web applications that track users and mark all
     consecutive web-accesses with the same session id.

'unregister_query(+QUERY)'
     unregisters all queries matching QUERY.

'session_get(+SESSIONID, +PARAMETERNAME, +DEFAULTVALUE, -VALUE)'

     returns the value of a given parameter in a given session.  If no
     value exists, then it will return the default value.  Arguments:
     SESSIONID
          is the id of the session for which values have been stored
     PARAMETERNAME
          an atom, is the name of the parameter to retrieve
     DEFAULTVALUE
          is the value that will be used if no value is stored
     VALUE
          is the stored value or the default value if nothing was stored

'session_put(+SESSIONID, +PARAMETERNAME, +VALUE)'

     stores the value of the given parameter.  *Please note*: any
     pre-existing value for this parameter will be overwritten.  Note
     that 'session_put/3' will not be undone when backtracking (the
     current implementation is based on 'assert').  Arguments:

     SESSIONID
          is the id of the session for the values to store
     PARAMETERNAME
          an atom, is the name of the parameter to store
     VALUE
          the value to be stored

'register_event_listener(+EVENT, :PREDICATETOCALL)'
'register_event_listener(+EVENT, :PREDICATETOCALL, -ID)'

     Registers 'PREDICATETOCALL' to be called (as if by
     'once(PREDICATETOCALL)') when the event matching 'EVENT' occurs
     (event matching is on principal functor only).  If the goal fails
     or raises an exception, then a warning is written to 'user_error'
     but the failure or exception is otherwise ignored.  Arguments:

     EVENT
          is the event template; see below.
     PREDICATETOCALL
          an arbitrary goal.
     ID
          becomes bound to a (ground) term that can be used with
          'unregister_event_listener/1' to remove this event listener.

     The predefined events are as follows:

     'session_started(+SESSIONID)'
          called before the first call to a query for this session
     'session_ended(+SESSIONID)'
          called before the session is about to be garbage collected
          (removed)
     'server_started'
          called when the server is about to start (enter its main loop)
     'server_shutdown'
          called when the server is about to shut down

     Attempt to register an event listener for other events than the
     predefined events will throw an exception.

     More than one listeners can be defined for the same event.  They
     will be called in some unspecified order when the event occurs.

'unregister_event_listener(+ID)'

     Unregister a previously registered event listener.  The ID is the
     value returned by the corresponding call to
     'register_event_listener/3'.  It is an error to attempt to
     unregister an event listener more than once.


File: sicstus.info,  Node: PB Java Client Interface,  Next: PB Java Examples,  Prev: PB Prolog Server Interface,  Up: lib-prologbeans

10.35.5 Java Client Interface
-----------------------------

The Java interface is centered around the class 'PrologSession', which
represents a connection (or session) to a Prolog server.
'PrologSession' contains static methods for looking up named
'PrologSession' instances using JNDI (Java Naming and Directory
Interface) as well as methods for querying the Prolog server.  Other
important classes are: 'QueryAnswer', which contains the answer for a
query sent to the Prolog server; 'PBTerm', which represents a Prolog
term; and 'Bindings', which supports stuffing of variable values used in
queries.

   General information about Java, Servlets and JNDI is available at the
Java Technology site: <http://java.sun.com/>

   A brief description of the provided Java classes are presented below.
More information about the Java APIs is available in the JavaDoc files
on the page <https://sicstus.sics.se/documentation.html>.

'PrologSession'
     The 'PrologSession' object is the connection to the Prolog server.
     The constructor 'PrologSession()' creates a 'PrologSession' with
     the default settings ('host = localhost, port = 8066'.

'QueryAnswer'
     The 'QueryAnswer' contains the answer (new bindings) for a query
     (or the error that occurred during the query process).

'PBTerm'
     The 'PBTerm' object is for representing parsed Prolog terms.

'Bindings'
     'Bindings' is used for binding variables to values in a query sent
     to the Prolog.  The values will be automatically stuffed before
     they are sent to the Prolog server.


File: sicstus.info,  Node: PB Java Examples,  Next: PB .NET Client Interface,  Prev: PB Java Client Interface,  Up: lib-prologbeans

10.35.6 Java Examples
---------------------

* Menu:

* PB Ex Embedding:: Embedding Prolog in Java Applications
* PB Ex Servers:: Application Servers
* PB Ex Tomcat:: Configuring Tomcat for PrologBeans

The PrologBeans examples for Java can be found in the directory
corresponding to the file search path 'pbexamples', defined as if by a
clause:

     user:file_search_path(pbexamples, library('prologbeans/examples')).


File: sicstus.info,  Node: PB Ex Embedding,  Next: PB Ex Servers,  Up: PB Java Examples

10.35.6.1 Embedding Prolog in Java Applications
...............................................

If you have an advanced Prolog application that needs a GUI, then you
can write a stand-alone Java application that handles the GUI and set up
the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
'pbexamples(evaluate)' directory (see the example code in *note PB First
Example::).

   Another example of this is 'pbexamples(pbtest)', which illustrates
several advanced features like:
   * registering several queries
   * listening to server events ('server_started')
   * shutting down the Prolog server from Java
   * starting up the Prolog server from Java
   * using dynamic (OS assigned) ports for the Java/Prolog communication

   The example is run by executing the Java program 'PBTest':
     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." PBTest (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." PBTest (UNIX)


File: sicstus.info,  Node: PB Ex Servers,  Next: PB Ex Tomcat,  Prev: PB Ex Embedding,  Up: PB Java Examples

10.35.6.2 Application Servers
.............................

If you want to get your Prolog application to be accessible from an
intranet or the Internet, then you can use this package to embed the
Prolog programs into a Java application server such as Tomcat,
WebSphere, etc.

   An example of how to do this is provided in 'pbexamples(sessionsum)'.
This example uses sessions to keep track of users so that the
application can hold a state for a user session (as in the example
below, remember the sum of all expressions evaluated in the session).

     <%@ page import = "se.sics.prologbeans.*" %>
     <html>
     <head><title>Sum Calculator</title></head>
     <body bgcolor="white">
     <font size=4>Prolog Sum Calculator, enter expression to evaluate:
     <form><input type=text name=query></form>
     <%
        PrologSession pSession =
        PrologSession.getPrologSession("prolog/PrologSession", session);
        pSession.connect();

        String evQuery = request.getParameter("query");
        String output = "";
        if (evQuery != null) {
          Bindings bindings = new Bindings().bind("E",evQuery + '.');
          QueryAnswer answer =
             pSession.executeQuery("sum(E,Sum,Average,Count)", bindings);
          PBTerm average = answer.getValue("Average");
          if (average != null) {
             PBTerm sum = answer.getValue("Sum");
             PBTerm count = answer.getValue("Count");

             output = "<h4>Average =" + average + ", Sum = "
             + sum + " Count = " + count + "</h4>";
          } else {
             output = "<h4>Error: " + answer.getError() + "</h4>";
          }
       }
     %>
     <%= output  %><br></font>
     <p><hr>Powered by SICStus Prolog
     </body></html>

   The example shows the code of a JSP (Java Server Page).  It makes use
of the method 'PrologSession.getPrologSession(String jndiName,
HTTPSession session)', which uses JNDI to look up a registered
'PrologSession', which is connected to the Prolog server.  The variable
SESSION is in a JSP bound to the current 'HTTPSession', and the variable
REQUEST is bound to the current 'HTTPRequest'.  Since the 'HTTPSession'
object 'session' is specified all queries to the Prolog server will
contain a session id.  The rest of the example shows how to send a query
and output the answer.

   Example usage of sessions (from the 'sessionsum' example) is shown
below, and is from 'pbexamples('sessionsum/sessionsum.pl')':

     :- module(sessionsum,[main/0,sum/5]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register the acceptable queries (session based)
     main:-
         register_query(sum(C,Sum,Average,Count),
                        sum(C,Session,Sum,Average,Count),
                        Session),
         start.

     %% The sum predicate which gets the information from a session database,
     %% makes some updates and then stores it back in to the session store
     %% (and returns the information back to the application server)
     sum(ExprChars, Session, Sum, Average, Count) :-
         session_get(Session, sum, 0, OldSum),
         session_get(Session, count, 0, OldCount),
         read_from_codes(ExprChars, Expr),
         Val is Expr,
         Sum is OldSum + Val,
         Count is OldCount + 1,
         Average is Sum / Count,
         session_put(Session, sum, Sum),
         session_put(Session, count, Count).

   In this example a query 'sum/4' is registered to call 'sum/5' where
one of the variables, SESSION will be bound to the session id associated
to the query.  The 'sum/5' predicate uses the 'session_get/4' predicate
to access stored information about the particular session, and then it
performs the evaluation of the expression.  Finally, it updates and
stores the values for this session.


File: sicstus.info,  Node: PB Ex Tomcat,  Prev: PB Ex Servers,  Up: PB Java Examples

10.35.6.3 Configuring Tomcat for PrologBeans
............................................

This section will briefly describe how to set up a Tomcat server so that
is it possible to test the example JSPs.  Some knowledge about how to
run Tomcat and how to set up your own web application is required.
Detailed information about Tomcat is available at
<http://jakarta.apache.org/tomcat/>.

   Assuming that the environment variable CATALINA_HOME is set to the
installation directory of Tomcat, do the following:

  1. Create the directory '$CATALINA_HOME/webapps/PB_example'

  2. Copy the file 'pbexamples('sessionsum/sessionsum.jsp')' to
     '$CATALINA_HOME/webapps/PB_example/sessionsum.jsp'
  3. Create the directory
     '$CATALINA_HOME/webapps/PB_example/WEB-INF/lib'

  4. Copy the file '$SP_PATH/bin/prologbeans.jar' to
     '$CATALINA_HOME/webapps/PB_example/WEB-INF/lib/prologbeans.jar'

  5. Create the directory '$CATALINA_HOME/webapps/PB_example/META-INF'

  6. Create the file
     '$CATALINA_HOME/webapps/PB_example/META-INF/context.xml' with the
     following content:
          <Context docBase="PB_example">
             <Resource name="prolog/PrologSession" auth="Container"
                       type="se.sics.prologbeans.PrologSession"
          	     factory="org.apache.naming.factory.BeanFactory" />

          </Context>

  7. Create the file '$CATALINA_HOME/webapps/PB_example/WEB-INF/web.xml'
     with the following content:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <!DOCTYPE web-app
               PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
              "http://java.sun.com/dtd/web-app_2_3.dtd">
          <web-app>

              <resource-env-ref>
                <description>
                  Object factory for PrologSession instances.
                </description>
                <resource-env-ref-name>
                  prolog/PrologSession
                </resource-env-ref-name>
                <resource-env-ref-type>
                  se.sics.prologbeans.PrologSession
                </resource-env-ref-type>
              </resource-env-ref>

          </web-app>

  8. Start SICStus, load 'sessionsum.pl' and run main.

  9. Start the Tomcat server.

  10. In a web browser, enter
     <http://localhost:8080/PB_example/sessionsum.jsp>


File: sicstus.info,  Node: PB .NET Client Interface,  Next: PB .NET Examples,  Prev: PB Java Examples,  Up: lib-prologbeans

10.35.7 .NET Client Interface
-----------------------------

The class 'PrologSession' in the .NET interface represents a connection
to a Prolog server.  'PrologSession' contains methods for establishing a
connection and querying the Prolog server.  Other important classes are:
'QueryAnswer', which contains the answer for a query sent to the Prolog
server; 'PBTerm', which represents a Prolog term; and 'Bindings', which
supports stuffing of variable values used in queries.

   The 'PrologSession' object is the connection to the Prolog server.
The constructor 'PrologSession()' creates a 'PrologSession' with the
default settings ('host = localhost, port = 8066'.

   The interface is almost exactly as the Java version.  See the C#
source code ('library/prologbeans.NET/*.cs') or the JavaDoc, for
details.


File: sicstus.info,  Node: PB .NET Examples,  Prev: PB .NET Client Interface,  Up: lib-prologbeans

10.35.8 .NET Examples
---------------------

* Menu:

* PB C# Examples:: C# Examples
* PB VB Example:: Visual Basic Example

The PrologBeans examples for .NET can be found in the directory
corresponding to the file search path 'pbnetexamples', defined as if by
a clause:

     user:file_search_path(pbnetexamples, library('prologbeans.NET/examples')).


File: sicstus.info,  Node: PB C# Examples,  Next: PB VB Example,  Up: PB .NET Examples

10.35.8.1 C# Examples
.....................

_.NET Embedding._  If you have an advanced Prolog application that needs
a GUI, then you can write a stand-alone .NET application that handles
the GUI and set up the Prolog server to call the right predicates in the
Prolog application.

   An example of how to do this can be found under the
'pbnetexamples('evaluate.NET')' directory.  This example is the C#
version of the example shown in *note PB First Example::).

   To start the example, first start the Prolog server by going to the
'pbnetexamples('evaluate.NET')' directory and type:

     > sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > run.bat

   Another example of this is 'pbnetexamples('pbtest.NET')', which
illustrates several advanced features like:

   * registering several queries
   * listening to server events ('server_started')
   * shutting down the Prolog server from .NET
   * starting up the Prolog server from .NET
   * using dynamic (OS assigned) ports for the .NET/Prolog communication

   The example is run by executing the C# program 'PBTest':

     > PBTest

   _ASPX Servers Pages._  If you want to get your Prolog application to
be accessible from an intranet or the Internet, then you can use this
package to embed the Prolog programs into a .NET ASP page which can be
served by e.g. Internet Information Services.

   An example of how to do this is provided in
'pbnetexamples('prologasp.NET/eval.aspx')'.  Consult your IIS
documentation for how to configure it for an ASPX page.  *The ASPX
example has a number of security vulnerabilities and is for illustrative
purposes only.  Consult with an expert.  *


File: sicstus.info,  Node: PB VB Example,  Prev: PB C# Examples,  Up: PB .NET Examples

10.35.8.2 Visual Basic Example
..............................

A Visual Basic .NET example can be found in
'pbnetexamples('vb_examples.NET/calculator')'.  It is a simple
calculator similar to the first C# 'EvaluateGUI' example in *note PB
First Example::.  This example is in the form of a Visual Studio
project.

   To run the example:

  1. Open the project files in Visual Studio .NET
  2. Add a reference in Visual Studio .NET to the installed
     'prologbeans.dll'
  3. Start sicstus with the following command:
          sicstus -l %SP_PATH%/library/prologbeans/examples/evaluate/evaluate --goal "main."
  4. Build and run the example in Visual Studio .NET


File: sicstus.info,  Node: lib-queues,  Next: lib-random,  Prev: lib-prologbeans,  Up: The Prolog Library

10.36 Queue Operations --'library(queues)'
==========================================

This module provides an implementation of queues, where you can
   * create an empty queue
   * add an element at either end of a queue
   * add a list of elements at either end of a queue
   * remove an element from the front of a queue
   * remove a list of elements from the front of a queue
   * determine the length of a queue
   * enumerate the elements of a queue
   * recognize a queue
   * print a queue nicely
   The representation was invented by Mark Johnson of the Center for the
Study of Language and Information.  All operations are fast.

   Exported predicates:

'empty_queue(?QUEUE)'

     is true when QUEUE represents an empty queue.  It can be used to
     test whether an existing queue is empty or to make a new empty
     queue.
'singleton_queue(?X, ?QUEUE)'

     is true when QUEUE is a queue with just one element X.
'portray_queue(+QUEUE)'

     writes a queue out in a pretty form, as QUEUE[ELEMENTS].  This form
     cannot be read back in, it is just supposed to be readable.  While
     it is meant to be called only when 'is_queue(QUEUE)' has been
     established, as by 'user:portray(Q) :- is_queue(Q), !,
     portray_queue(Q)'.  it is also meant to work however it is called.
'is_queue(+QUEUE)'

     is true when QUEUE is a queue.  The elements of QUEUE do not have
     to be instantiated, and the BACK of the QUEUE may or may not be.
     It can only be used to recognize queues, not to generate them.  To
     generate queues, use 'queue_length(QUEUE, _)'.
'queue_head(+QUEUE, -HEAD)'

     is true when HEAD is the first element of the given QUEUE.  It does
     not remove HEAD from QUEUE; HEAD is still there afterwards.  It can
     only be used to find HEAD, it cannot be used to make a QUEUE.
'queue_tail(?QUEUE, ?TAIL)'

     is true when QUEUE and TAIL are both queues and TAIL contains all
     the elements of QUEUE except the first.  Note that QUEUE and TAIL
     share structure, so that you can add elements at the back of only
     one of them.  It can solve for either argument given the other.
'queue_cons(?HEAD, ?TAIL, ?QUEUE)'

     is true when HEAD is the head of QUEUE and TAIL is the tail of
     QUEUE, that is, when TAIL and QUEUE are both queues, and the
     elements of the QUEUE are HEAD followed by the elements of TAIL in
     order.  It can be used in either direction, so
              queue_cons(+Head, +Q0, -Q)      adds Head to Q0 giving Q
              queue_cons(-Head, -Q, +Q0)      removes Head from Q0 giving Q
'queue_last(?LAST, ?QUEUE)'

     is true when LAST is the last element currently in QUEUE.  It does
     not remove LAST from QUEUE; it is still there.  This can be used to
     generate a non-empty QUEUE.  The cost is O(|QUEUE|).
'queue_last(+FORE, +LAST, -QUEUE)'
     is true when FORE and QUEUE are both lists and the elements of
     QUEUE are the elements of FORE in order followed by LAST.  This is
     the operation which adds an element at the end of FORE giving
     QUEUE; it is not reversible, unlike 'queue_cons/3', and it
     side-effects FORE, again unlike 'queue_cons/3'.
'append_queue(?LIST, ?QUEUE0, ?QUEUE)'

     is true when QUEUE is obtained by appending the elements of LIST in
     order at the front of QUEUE0, e.g.  'append_queue([a,b,c],
     Queue[d,e], Queue[a,b,c,d,e])'.  Use
              append_queue([+X1,...,+Xn], +Q0, -Q) to add X1,...,Xn to Q0 giving Q
              append_queue([-X1,...,-Xn], -Q, +Q0) to take X1...Xn from Q0 giving Q
     The cost is O(N) and the operation is pure.
'queue_append(+QUEUE0, +LIST, -QUEUE)'

     is true when QUEUE is obtained by appending the elements of LIST in
     order at the rear end of QUEUE0, e.g.  'append_queue(Queue[a,b,c],
     [d,e], Queue[a,b,c,d,e])'.  This is like 'queue_last/3'; it
     side-effects QUEUE0.
'list_queue(?LIST, ?QUEUE)'

     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  'list_queue/2' and 'queue_list/2'
     are the same except for argument order.
'queue_list(?QUEUE, ?LIST)'

     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  'queue_list/2' and 'list_queue/2'
     are the same except for argument order.
'queue_length(?QUEUE, ?LENGTH)'

     is true when QUEUE is a queue having LENGTH elements.  It may be
     used to determine the LENGTH of a QUEUE or to make a QUEUE of given
     LENGTH.
'queue_member(?ELEMENT, +QUEUE)'

     is true when ELEMENT is an element of QUEUE.  It could be made to
     generate queues, but that would be rather inefficient.  It bears
     the name 'queue_member/2' because it is prepared to enumerate
     ELEMENTS.
'queue_memberchk(+ELEMENT, +QUEUE)'

     is true when the given ELEMENT is an element of QUEUE.  Once it
     finds a member of QUEUE which unifies with ELEMENT, it commits to
     it.  Use it to check a ground ELEMENT.
'map_queue(:PRED, +QUEUE[X1,...,XN])'

     succeeds when PRED(XI) succeeds for each element XI of the QUEUE.
'map_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI,YI) succeeds for each corresponding pair of
     elements XI, YI of the two queues.
'map_queue_list(:PRED, ?QUEUE[X1,...,XN], ?[Y1,...,YN])'

     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the QUEUE and the LIST.  It may be used to
     generate either of the sequences from the other.
'map_list_queue(:PRED, ?[X1,...,XN], ?QUEUE[Y1,...,YN])'

     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the LIST and the QUEUE.  It may be used to
     generate either of the sequences from the other.
'some_queue(:PRED, +QUEUE[X1,...,XN])'

     succeeds when PRED(XI) succeeds for some XI in the QUEUE.  It will
     try all ways of proving PRED(XI) for each XI, and will try each XI
     in the QUEUE.  'somechk_queue/2' is to 'some_queue/2' as
     'memberchk/2' is to 'member/2'; you are more likely to want
     'somechk_queue/2'.  This acts on backtracking like 'member/2';
     QUEUE should be proper.
'some_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.
'somechk_queue(:PRED, +QUEUE[X1,...,XN])'

     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').


File: sicstus.info,  Node: lib-random,  Next: lib-rem,  Prev: lib-queues,  Up: The Prolog Library

10.37 Random Number Generator--'library(random)'
================================================

This library module provides a random number generator using algorithm
AS 183 from the Journal of Applied Statistics as the basic algorithm.
This algorithm is not cryptographically secure.

   The state of the random number generator corresponds to a term
'random(X,Y,Z,B)' where X is an integer in the range [1,30268], Y is an
integer in the range [1,30306], Z is an integer in the range [1,30322],
and B is a nonzero integer.

   The random generator starts with the same default initial state on
each run.  See 'setrand/1' for a way to initialize the random number
generator with a new state when a more unpredictable initial state is
desired.

   Exported predicates:

'getrand(-RANDOMSTATE)'

     returns the random number generator's current state
'setrand(+RANDOMSTATE)'

     sets the random number generator's state to RANDOMSTATE.
     RANDOMSTATE can either be a random state previously obtained with
     'getrand/1', or an arbitrary integer.  The latter is useful when
     you want to initialize the random state to a fresh value.  If
     RANDOMSTATE is not an integer or a valid random state, it raises an
     error.

     The initial state of the random number generator is always the
     same.  This means that subsequent runs will generate the same
     sequence of random numbers.  This gives reproducible results which
     is good for testing but not always desirable.  One way to get a new
     initial state is to set it based on the current time, e.g. by
     calling something like the following predicate early in your
     program:

              :- use_module(library(system), [now/1]).
              init_random_state :-
                      now(X),
                      setrand(X).
'maybe'

     succeeds determinately with probability 1/2, fails with probability
     1/2.  We use a separate "random bit" generator for this test to
     avoid doing much arithmetic.
'maybe(+PROBABILITY)'
     succeeds determinately with probability Probability, fails with
     probability 1-PROBABILITY.  Arguments =< 0 always fail, >= 1 always
     succeed.
'maybe(+P, +N)'
     succeeds determinately with probability P/N, where 0 =< P =< N and
     P and N are integers.  If this condition is not met, it fails.  It
     is equivalent to 'random(0, N, X), X < P', but is somewhat faster.
'random(-UNIFORM)'

     unifies UNIFORM with a new random number in [0.0,1.0)
'random(+L, +U, -R)'
     unifies R with a random integer in [L,U) when L and U are integers
     (note that U will _never_ be generated), or to a random floating
     number in [L,U) otherwise.
'random_member(-ELEM, +LIST)'

     unifies ELEM with a random element of LIST, which must be proper.
     Takes O(N) time (average and best case).
'random_select(?ELEM, ?LIST, ?REST)'

     unifies ELEM with a random element of LIST and REST with all the
     other elements of LIST (in order).  Either LIST or REST should be
     proper, and LIST should/will have one more element than REST.
     Takes O(N) time (average and best case).
'random_subseq(+LIST, -SBSQ, -CMPL)'

     unifies SBSQ with a random sub-sequence of LIST, and CMPL with its
     complement.  After this, 'subseq(List, Sbsq, Cmpl)' will be true.
     Each of the 2**|LIST| solutions is equally likely.  Like its
     name-sake 'subseq/3', if you supply SBSQ and CMPL it will
     interleave them to find LIST.  Takes O(N) time.  LIST should be
     proper.
'random_permutation(?LIST, ?PERM)'

     unifies PERM with a random permutation of LIST.  Either LIST or
     PERM should be proper, and they should/will have the same length.
     Each of the N! permutations is equally likely, where 'length(List,
     N)'.  This takes O(N LG N) time and is bidirectional.
'random_perm2(A,B, X,Y)'

     unifies X,Y = A,B or X,Y = B,A, making the choice at random, each
     choice being equally likely.  It is equivalent to
     'random_permutation([A,B], [X,Y])'.
'random_numlist(+P, +L, +U, -LIST)'

     where P is a probability (0..1) and L=<U are integers unifies LIST
     with a random subsequence of the integers L..U, each integer being
     included with probability P.


File: sicstus.info,  Node: lib-rem,  Next: lib-samsort,  Prev: lib-random,  Up: The Prolog Library

10.38 Rem's Algorithm--'library(rem)'
=====================================

This library module maintains equivalence classes using Rem's algorithm.
Exported predicates:

'rem_create(+SIZE, -REM)'

     creates an equivalence representation function REM which maps each
     of the nodes 1..SIZE to itself.
'rem_head(?NODE, +REM, -HEAD)'

     is true when HEAD is the representative of the equivalence class
     that NODE belongs to in the given REM.
'rem_equivalent(?NODE1, ?NODE2, +REM)'

     is true when NODE1 and NODE2 belong to the same equivalence class
     in the given REM.
'rem_add_link(?NODE1, ?NODE2, +OLDREM, -NEWREM)'

     is true when adding the equivalence NODE1===NODE2 to the partition
     represented by OLDREM yields a partition which is represented by
     NEWREM.  If NODE1 or NODE2 is uninstantiated, it will backtrack
     over all the nodes.  It's not clear how useful this is.


File: sicstus.info,  Node: lib-samsort,  Next: lib-sets,  Prev: lib-rem,  Up: The Prolog Library

10.39 Generic Sorting--'library(samsort)'
=========================================

This library module provides generic sorting.  Exported predicates:

'samsort(+RAWLIST, -SORTED)'

     takes a proper list RAWLIST and unifies SORTED with a list having
     exactly the same elements as RAWLIST but in ascending order
     according to the standard order on terms.
'merge(+LIST1, +LIST2, -MERGED)'

     is true when MERGED is the stable merge of the two given lists.  If
     the two lists are not ordered, the merge doesn't mean a great deal.
     Merging is perfectly well defined when the inputs contain
     duplicates, and all copies of an element are preserved in the
     output, e.g.  merge("122357", "34568", "12233455678").
'samsort(:ORDER, +RAWLIST, -SORTEDLIST)'
     takes a proper list RAWLIST and a binary predicate ORDER and
     unifies SORTEDLIST with a list having exactly the same elements as
     RAWLIST but in ascending order according to ORDER.  This is only
     supposed to work when Order is transitive.
'merge(:ORDER, +LIST1, +LIST2, -MERGED)'
     is like 'merge/3' except that it takes an ORDER predicate as its
     first arguments, like all the generalized ordering routines.
'samkeysort(+RAWLIST, -SORTED)'

     takes a proper list RAWLIST of KEY-VALUE pairs, and unifies SORTED
     with a list having exactly the same elements as RAWLIST but in
     ascending order according to the standard order on the keys.
     'samkeysort/2' is stable in the sense that the relative position of
     elements with the same key is maintained.
'keymerge(+LIST1, +LIST2, -MERGED)'

     is like 'merge/3' except that it compares only the keys of its
     input lists.


File: sicstus.info,  Node: lib-sets,  Next: lib-sockets,  Prev: lib-samsort,  Up: The Prolog Library

10.40 Unordered Set Operations--'library(sets)'
===============================================

This library module provides operations on sets represented as unordered
lists with no repeated elements.

   *Please note*: You should probably not use this module.  The ordered
representation used in 'library(ordsets)' is *much more efficient*, but
these routines were designed before sort/2 entered the language.
Exported predicates:

'add_element(+ELEMENT, +SET1, -SET2)'

     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 U {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.
'del_element(+ELEMENT, +SET1, -SET2)'

     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 \ {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.  If SET1 does not contain ELEMENT, SET2
     will be identical to SET1 (the old version made a new copy of
     SET1).  If SET1 is not an unordered set, but contains more than one
     copy of ELEMENT, only the first will be removed.  If you want to
     delete all copies of a given element, use 'lists:delete/3'.  For a
     version which fails if ELEMENT is not in SET1, use 'selectchk/3'.
'disjoint(+SET1, +SET2)'

     is true when the two given sets have no elements in common.  It is
     the opposite of 'intersect/2'.  If either of the arguments is
     improper, 'disjoint/2' will fail.
'is_set(+LIST)'

     is true when LIST is a proper list that contains no repeated
     elements.
'pairfrom(?SET, ?ELEMENT1, ?ELEMENT2, ?RESIDUE)'

     is true when SET is a list, ELEMENT1 occurs in list, ELEMENT2
     occurs in list after ELEMENT1, and RESIDUE is everything in SET bar
     the two ELEMENTS.  The point of this thing is to select pairs of
     elements from a set without selecting the same pair twice in
     different orders.
'intersect(+SET1, +SET2)'

     is true when the two sets have a member in common.  It assumes that
     both sets are known, and that you don't care which element it is
     that they share.
'subset(+SET1, +SET2)'

     is true when each member of SET1 occurs in SET2.  It can only be
     used to test two given sets; it cannot be used to generate subsets.
     There is no predicate for generating subsets as such, but the
     predicates 'subseq/3', 'subseq0/2', 'subseq1/2' in 'library(lists)'
     may do what you want (they preserve the order of elements within a
     list).  Could be defined as:

          subset(Set1, Set2) :-
          	(   foreach(X,Set1),
          	    param(Set2)
          	do  memberchk(X,Set2)
          	).
'set_order(+XS, +YS, -R)'

     is true when R is '<', '=', or '>' according as XS is a subset of
     YS, equivalent to YS, or a superset of YS.
'seteq(+SET1, +SET2)'

     is true when each Set is a subset of the other.
'list_to_set(+LIST, -SET)'

     is true when LIST and SET are lists, and SET has the same elements
     as LIST in the same order, except that it contains no duplicates.
     The two are thus equal considered as sets.
'power_set(+SET, -POWERSET)'

     is true when SET is a list and POWERSET is a list of lists which
     represents the power set of the set that Set represents.
'intersection(+SET1, +SET2, -INTERSECTION)'

     is true when all three arguments are lists representing sets, and
     INTERSECTION contains every element of SET1 which is also an
     element of SET2, the order of elements in INTERSECTION being the
     same as in SET1.  That is, INTERSECTION represents the intersection
     of the sets represented by SET1 and SET2.  Could be defined as:

          intersection(Set1, Set2, Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = [X|S] ; S0 = S)
          	).
'intersection(+LISTOFSETS, -INTERSECTION)'
     is true when INTERSECTION is the intersection of all the sets in
     LISTOFSETS.  The order of elements in INTERSECTION is taken from
     the first set in LISTOFSETS.  This has been turned inside out to
     minimize the storage turnover.  Could be defined as:

          intersection([Set1|Sets], Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Sets)
          	do  (   (   foreach(Set,Sets),
          		    param(X)
          		do  memberchk(X, Set)
          		) -> S0 = [X|S]
          	    ;   S0 = S
          	    )
          	).
'subtract(+SET1, +SET2, -DIFFERENCE)'

     is like 'intersect/3', but this time it is the elements of SET1
     which _are_ in SET2 that are deleted.  Note that duplicated
     ELEMENTS of SET1 which are not in SET2 are retained in DIFFERENCE.
     Could be defined as:

          subtract(Set1, Set2, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Difference,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).
'symdiff(+SET1, +SET2, -DIFFERENCE)'

     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2, that is, if each element of DIFFERENCE occurs in one of SET1
     and SET2 but not both.  The construction method is such that the
     answer will have no duplicates even if the SETS do.
'setproduct(+SET1, +SET2, -CARTESIANPRODUCT)'

     is true when SET1 is a set (list) and SET2 is a set (list) and
     CARTESIANPRODUCT is a set of ELT1-ELT2 pairs, with a pair for for
     each element ELT1 of SET1 and ELT2 of SET2.  Could be defined as:

          setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).
'disjoint_union(+SET1, +SET2, -UNION)'

     is true when 'disjoint(Set1, Set2)' and 'union(Set1, Set2, Union)',
     that is, SET1 and SET2 have no element in command and UNION is
     their union.  Could be defined as:

          disjoint_union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,[X|S],S,Set2),
          	    param(Set2)
          	do  nonmember(X, Set2)
          	).
'union(+SET1, +SET2, -UNION)'

     is true when 'subtract(Set1,Set2,Diff)' and
     'append(Diff,Set2,Union)', that is, when UNION is the elements of
     SET1 that do not occur in SET2, followed by all the elements of
     SET2.  Could be defined as:

          union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).
'union(+SET1, +SET2, -UNION, -DIFFERENCE)'
     is true when 'union(Set1, Set2, Union)' and 'subtract(Set1, Set2,
     Difference)'.  Could be defined as:

          union(Set1, Set2, Union, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    fromto(Difference,T0,T,[]),
          	    param(Set2)
          	do  (   member(X, Set2) -> S0 = S, T0 = T
          	    ;   S0 = [X|S], T0 = [X|T]
          	    )
          	).
'union(+LISTOFSETS, -UNION)'
     is true when UNION is the union of all the sets in LISTOFSETS.  It
     has been arranged with storage turnover in mind.  Could be defined
     as:

          union(Sets, Union) :-
          	(   foreach(Set,Sets),
          	    param(Answer)
          	do  (   foreach(X,Set),
          		param(Answer)
          	    do  memberchk(X, Answer)
          	    )
          	),
          	append(Answer, [], Answer),	% cauterize it
          	!,
          	Union = Answer.


File: sicstus.info,  Node: lib-sockets,  Next: lib-statistics,  Prev: lib-sets,  Up: The Prolog Library

10.41 Socket I/O--'library(sockets)'
====================================

This library package defines a number of predicates for communicating
over sockets.

   To create a (bi-directional) stream connected to a remote server, use
'socket_client_open/3'.

   To open a port for remote clients to connect to, use
'socket_server_open/[2,3]' and to open a stream to a connecting client,
use 'socket_server_accept/4'.

   To be able to multiplex input and output from several streams (not
necessarily socket streams) and incoming connections, use
'socket_select/7'.

   When opening a client or server socket a "socket address" needs to be
specified.  The address specifies the address family and family-specific
information.  The following formats are supported for socket addresses:
'inet(NODENAME,SERVNAME)'
'NODENAME:SERVNAME'
'SERVNAME'
     This specifies the address for and ordinary internet socket
     ('AF_INET' or 'AF_INET6').  NODENAME is the internet address of the
     remote host, as an atom, something like ''sicstus.sics.se'' or
     ''193.10.64.51''.  The empty nodename '''' (the default), has
     special meaning, see the documentation for 'socket_client_open/3'
     and 'socket_server_open/[2,3]'.  SERVNAME is either a port number
     as an atom of decimal digits or as an integer, e.g. ''80'', or
     '80'; alternatively some "well known port names" can be used, e.g.
     ''http''.  The set of well known port names is OS specific,
     portable code should use integer port numbers.  SERVNAME can also
     be a variable when opening a server socket with
     'socket_server_open/[2,3]'.  In this case a available port is
     assigned automatically and Servname is bound to it.

'unix(PATH)   since release 4.0.3'
     A Unix domain ('AF_UNIX') socket is opened at the specified file
     system location.  This is only supported on Unix-like platforms.
     PATH is a file-name and is passed to 'absolute_file_name/2'.  There
     may be platform-specific restrictions on the length of the
     resulting pathname and the file system containing it.

   All streams below can be read from as well as written to.  All I/O
predicates operating on streams can be used, for example 'get_code/2',
'get_byte/2', 'read/2', 'write/2', 'format/3', 'current_stream/3', etc.
The predicates that create streams take options similar to 'open/4',
e.g. to specify whether the stream is binary (the default) or text.

'socket_client_open(+ADDR, -STREAM, +OPTIONS)'

     Creates a stream STREAM connected to address ADDR.  See above for
     the allowed address formats.  If the nodename is empty ('''') then
     a connection is made to the local machine.

     The stream is created using options from OPTIONS.  Supported
     options include:
     'type(binary)'
          Create a binary stream (the default).
     'type(text)'
          Create a text stream.  The default encoding is Latin 1.
     'eof_action(ACTION)'
          end of file action, as for 'open/4'.
     'encoding(ENCODING)   since release 4.1'
          As for open/4.  Implies 'type(text)'.
     'eol(EOL)   since release 4.1'
          As for open/4.  Implies 'type(text)'.

     To create a binary stream to some web server 'sicstus.sics.se', you
     would do e.g.
          | ?- socket_client_open('sicstus.sics.se':80, Stream, [type(binary)]).

     or, to make a text (Latin 1) stream to a 'daytime' service in Hong
     Kong you could do:

          | ?- socket_client_open('stdtime.gov.hk':daytime, S, [type(text)]),
               read_line(S, L),
               format('~s', [L]).

     See the source code for 'library('linda/client')' for a simple
     client.

'socket_server_open(?ADDR, -SERVERSOCKET, +OPTIONS)   since release 4.0.3'

     Create a server socket SERVERSOCKET that listens on address ADDR.
     See above for the allowed address formats.  If the nodename is
     empty ('''') then any remote client machine is allowed to connect
     unless the option 'loopback(true)' is also specified.  ADDR can
     specify an internet address where the port is a variable in which
     case a free port number is used and PORT is bound to it.  The
     common case is that Addr is a numeric port number or a variable
     that becomes bound to a free port number.

     The created server socket should be closed with
     'socket_server_close/1' eventually.  Incoming connection can be
     accepted with 'socket_server_accept/4' and waited for with
     'socket_select/7'.  See the source code for
     'library('linda/server')' for a simple server that uses this
     predicate.

     OPTIONS is a list of options, currently
     'reuseaddr(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then allow reuse of local addresses.  For internet sockets
          this corresponds to the 'SO_REUSEADDR' socket option.  For
          unix domain sockets this means that the file will be deleted,
          if present, before opening.
     'numeric_nodename(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the nodename of an internet address will be treated as a
          numerical address and no name lookup will be performed.
     'numeric_servname(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the servname of an internet address will be treated as a
          numerical port number and no lookup of well known port names
          will be performed.
     'loopback(Bool)   since release 4.0.3'
          BOOL is either 'true' or 'false' (the default).  If 'true'
          then the nodename will be ignored and the socket will only
          listen to connection from the loopback device, i.e. the local
          machine.
'socket_server_open(?PORT, -SERVERSOCKET)'
     The same as 'socket_server_open(PORT, SERVERSOCKET, [])'.
'socket_server_accept(+SERVERSOCKET, -CLIENT, -STREAM, +STREAMOPTIONS)'

     The first connection to socket SERVERSOCKET is extracted, blocking
     if necessary.  The stream STREAM is created on this connection
     using STREAMOPTIONS as for 'socket_client_open/3'.  CLIENT will be
     unified with an atom containing the numerical Internet host address
     of the connecting client.  Note that the stream will be
     'type(binary)' unless 'type(text)' is specified either explicitly
     or implicitly with 'encoding/1' or other text-only options.
'socket_server_close(+SERVERSOCKET)'

     Close the server socket SERVERSOCKET and stop listening on its
     port.
'socket_select(+SERVERSOCKETS,-SREADY, +READSTREAMS,-RREADY, +WRITESTREAMS,-WREADY, +TIMEOUT)'

     Check for server sockets with incoming connections (i.e. ready for
     'socket_server_accept/4'), streams on READSTREAMS ready for input,
     and streams on WRITESTREAMS ready for output.  The streams can be
     any kind of streams, they need not be socket streams.  The ready
     server sockets are returned (in the same order) in SREADY, the
     ready input streams in RREADY, and the ready output streams in
     WREADY.

     An input (output) stream is ready for input (output) when an "item"
     can be read (written) without blocking.  An item is a character for
     text streams and a byte for binary streams.  Note that a stream is
     considered ready for I/O if the corresponding I/O operation will
     raise an error (such as if the stream is past end of stream).

     Each entry in the input lists SERVERSOCKETS, READSTREAMS, and
     WRITESTREAMS can be either a server socket or stream respectively
     or a term 'TERM-ENTRY' where ENTRY is the server socket or stream
     and TERM is some arbitrary term used for book-keeping.  If an entry
     is associated with a term in this way then so will the
     corresponding ready entry.

     If TIMEOUT is instantiated to 'off', the predicate waits until
     something is available.  If TIMEOUT is a nonzero number (integer or
     floating point), then the predicate waits at most that number of
     seconds before returning.  For backward compatibility, if TIMEOUT
     is S:U the predicate waits at most S seconds and U microseconds.
     If there is a timeout, all ready lists are unified with '[]'.

     See the source code for 'library('linda/server')' for a simple
     server that uses this predicate.
'current_host(?HOSTNAME)'

     HOSTNAME is unified with the fully qualified name of the machine
     that the process is executing on.  The call will also succeed if
     HOSTNAME is instantiated to the unqualified name of the machine in
     lower case.  *Please note:* this predicate will fail if there are
     errors, e.g. if no domain has been configured.


File: sicstus.info,  Node: lib-statistics,  Next: lib-structs,  Prev: lib-sockets,  Up: The Prolog Library

10.42 Statistics Functions--'library(statistics)'
=================================================

This library module provides commonly used sample and population
statistics functions.  In this module, a SAMPLE is simply a proper list
of numbers, normally floating-point; WEIGHT is a proper list of numbers
and should be of the same length as SAMPLE.

   *Please note:* These functions are plain textbook algorithms and we
make no claims about numerical stability, avoiding loss of precision,
etc.

   Exported predicates:
'min(+SAMPLE, -VALUE)'

     is true when VALUE is the smallest element of SAMPLE.
'max(+SAMPLE, -VALUE)'

     is true when VALUE is the largest element of SAMPLE.
'min_max(+SAMPLE, -MIN, -MAX)'

     is true when MIN (MAX) is the smallest (largest) element of SAMPLE.
'range(+SAMPLE, -VALUE)'

     is true when VALUE is the difference between the largest and
     smallest elements of SAMPLE.
'mode(+SAMPLE, -VALUES)'

     is true when VALUES is the most frequently occurring value(s) in
     SAMPLE.  If there is a unique value with maximum frequency, this
     value is returned as the only element of VALUES.  Otherwise, VALUES
     contains the maximum frequency elements in increasing order.  This
     predicate does not make much sense if the sample is continuous.
'mean(+SAMPLE, -VALUE)'
'arithmetic_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the arithmetic mean of SAMPLE.
'weighted_mean(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the arithmetic mean of SAMPLE weighted by
     WEIGHT.
'geometric_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the geometric mean of SAMPLE.
'harmonic_mean(+SAMPLE, -VALUE)'

     is true when VALUE is the harmonic mean of SAMPLE.
'central_moment(K, +SAMPLE, -VALUE)'

     is true when VALUE is the K-th central moment of SAMPLE.  Also
     known as the K-th central moment about the mean.  K should be
     positive integer.
'skewness(+SAMPLE, -VALUE)'

     is true when VALUE is the skewness of SAMPLE.  This is a measure of
     the asymmetry of its distribution.  A sample with negative skew is
     said to be _left-skewed_.  Most of its mass is on the right of the
     distribution, with the tail on the left.  Vice versa for positive
     skew.  A sample's skewness is undefined if its variance is zero.
'kurtosis(+SAMPLE, -VALUE)'

     is true when VALUE is the excess kurtosis of SAMPLE.  This is a
     measure of the peakedness of its distribution.  A high kurtosis
     indicates that most of the sample's variance is due to infrequent
     severe deviations, rather than frequent modest deviations.  A
     sample's excess kurtosis is undefined if its variance is zero.  In
     this implementation, the kurtosis of the normal distribution is 0.
'ml_variance(+SAMPLE, -VALUE)'
'population_variance(+SAMPLE, -VALUE)'

     is true when VALUE is the maximum likelihood estimate of the
     variance of SAMPLE.  Also known as the population variance, where
     the denominator is the length of SAMPLE.
'sample_variance(+SAMPLE, -VALUE)'
'unbiased_variance(+SAMPLE, -VALUE)'

     is true when VALUE is the unbiased estimate of the variance of
     SAMPLE.  Also known as the sample variance, where the denominator
     is the length of SAMPLE minus one.
'weighted_variance(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the weighted (biased) estimate of the
     variance of SAMPLE.
'ml_standard_deviation(+SAMPLE, -VALUE)'
'population_standard_deviation(+SAMPLE, -VALUE)'

     is true when VALUE is the maximum likelihood estimate of the
     standard deviation of SAMPLE.  Also known as the population
     standard deviation, where the denominator is the length of SAMPLE.
     Equals the square root of the population variance.
'sample_standard_deviation(+SAMPLE, -VALUE)'
'unbiased_standard_deviation(+SAMPLE, -VALUE)'

     is true when VALUE is the unbiased estimate of the standard
     deviation of SAMPLE.  Also known as the sample standard deviation,
     where the denominator is the length of SAMPLE minus one.  Equals
     the square root of the sample variance.
'weighted_standard_deviation(+WEIGHT, +SAMPLE, -VALUE)'

     is true when VALUE is the weighted (biased) estimate of the
     standard deviation of SAMPLE.  Equals the square root of the
     weighted (biased) variance.
'covariance(+SAMPLE1, +SAMPLE2, -VALUE)'

     is true when VALUE is the covariance of SAMPLE1 and SAMPLE2.
'correlation(+SAMPLE1, +SAMPLE2, -VALUE)'

     is true when VALUE is the correlation of SAMPLE1 and SAMPLE2.
'median(+SAMPLE, -VALUE)'

     is true when VALUE is the median of SAMPLE, that is, the value
     separating the higher half of the sample from the lower half.  If
     there are an even number of observations, then the median is
     defined to be the smaller middle value.  Same as the 0.5-fractile
     of SAMPLE.
'fractile(P, +SAMPLE, -VALUE)'

     is true when VALUE is the P-fractile of SAMPLE, that is, the
     smallest value in the sample such that the fraction P of the sample
     is less than or equal to that value.  P should be a number in
     (0.0,1.0].
'normalize(+SAMPLE, -NORMALIZED)'

     is true when NORMALIZED is the normalized SAMPLE, so that
     NORMALIZED has a mean of 0 and a population standard deviation of
     1.


File: sicstus.info,  Node: lib-structs,  Next: lib-system,  Prev: lib-statistics,  Up: The Prolog Library

10.43 The Structs Package--'library(structs)'
=============================================

* Menu:

* str-fty::                             Foreign Types
* str-cft::                             Checking Foreign Term Types
* str-cdf::                             Creating and Destroying Foreign Terms
* str-afd::                             Accessing and Modifying Foreign Term Contents
* str-cas::                             Casting
* str-nul::                             Null Foreign Terms
* str-ifc::                             Interfacing with Foreign Code
* str-etr::                             Examining Type Definitions at Run Time
* str-tip::                             Tips
* str-exa::                             Example

The 'structs' package allows Prolog to hold pointers to C data
structures, and to access and store into fields in those data
structures.  Currently, the only representation for a pointer supported
by SICStus Prolog is an integer, so it is not possible to guarantee that
Prolog cannot confuse a pointer with an ordinary Prolog term.  What this
package does is to represent such a pointer as a term with the type of
the structure or array as its functor and the integer that is the
address of the actual data as its only argument.  We will refer such
terms as "foreign terms".

   The package consists of two modules, 'str_decl' and 'structs'.  The
'str_decl' module is used at compile time to translate the
structs-related constructs.  Any file that defines or accesses structs
should include the command:

     :- load_files(library(str_decl),
                   [when(compile_time), if(changed)]).

   The 'structs' module provides runtime support for structs.  A file
that accesses structs should include the command:

     :- use_module(library(structs)).

   You will probably include both in most files that define and access
structs.

   *Please note:* A file that loads 'library(str_decl)' currently cannot
recursively load another file that loads 'library(str_decl)', because
that would confuse the internal database being used by the package.

     *Important caveats:*

     You should not count on future versions of the structs package to
     continue to represent foreign terms as compound Prolog terms.  In
     particular, you should never explicitly take apart a foreign term
     using unification or 'functor/3' and 'arg/3'.  You may use the
     predicate 'foreign_type/2' to find the type of a foreign term, and
     'cast/3' (casting a foreign term to address) to get the address
     part of a foreign term.  You may also use 'cast/3' to cast an
     address back to a foreign term.  You should use
     'null_foreign_term/2' to check if a foreign term is null, or to
     create a null foreign term of some type.

     It should never be necessary to explicitly take apart foreign
     terms.


File: sicstus.info,  Node: str-fty,  Next: str-cft,  Up: lib-structs

10.43.1 Foreign Types
---------------------

* Menu:

* str-fty-dty::                         Declaring Types

There are two sorts of objects that Prolog may want to handle: "atomic"
and "compound".  "Atomic" objects include numbers and atoms, and
"compound" objects include data structures and arrays.  To be more
precise about it, an atomic type is defined by one of the following:

'integer'
     signed integer, large enough to hold a pointer.

'integer_64   since release 4.3'
     64 bit signed integer.

'integer_32'
     32 bit signed integer.

'integer_16'
     16 bit signed integer.

'integer_8'
     8 bit signed integer.

'unsigned'
     unsigned integer, large enough to hold a pointer.

'unsigned_64   since release 4.3'
     64 bit unsigned integer.

'unsigned_32'
     32 bit unsigned integer.

'unsigned_16'
     16 bit unsigned integer.

'unsigned_8'
     8 bit unsigned integer.

'float'
     64 bit floating-point number.

'float_32'
     32 bit floating-point number.

'atom'
     32 bit Prolog atom number.  Unique for different atoms, but not
     consistent across Prolog sessions.  The atom is made non garbage
     collectable.  *Note Atoms in C::.

'string'
     A pointer to an encoded string.  Represented as an atom in Prolog.
     *Please note*: This string must not be overwritten, as it
     constitutes the print name of an atom.  Also, the atom and string
     are made non garbage collectable.  *Note Atoms in C::.

'address'
     An untyped pointer.  Like 'pointer(_)', but 'library(structs)' does
     no type checking for you.  Represented as a Prolog integer.

'opaque'
     Unknown type.  Cannot be represented in Prolog.  A pointer to an
     opaque object may be manipulated.

   Compound types are defined by one of the following:

'pointer(TYPE)'
     a pointer to a thing of type TYPE.

'array(NUM,TYPE)'
     A chunk of memory holding NUM (an integer) things of type TYPE.

'array(TYPE)'
     A chunk of memory holding some number of things of type TYPE.  This
     type does not allow bounds checking, so it should be used with
     great care.  It is also not possible to use this sort of array as
     an element in an array, or in a struct or union.

'struct(FIELDS)'
     A compound structure.  FIELDS is a list of FIELD_name:TYPE pairs.
     Each FIELD_name is an atom, and each TYPE is any valid type.

'union(MEMBERS)'
     A union as in C. MEMBERS is a list of MEMBER_name:TYPE pairs.  Each
     MEMBER_name is an atom, and each TYPE is any valid type.  The space
     allocated for one of these is the maximum of the spaces needed for
     each member.  It is not permitted to store into a union (you must
     get a member of the union to store into, as in C).

   C programmers will recognize that the kinds of data supported by this
package were designed for the C language.  They should also work for
other languages, but programmers must determine the proper type
declarations in those languages.  The table above makes clear the
storage requirements and interpretation of each type.

   Note that there is one important difference between the 'structs'
package and C: the 'structs' package permits declarations of pointers to
arrays.  A pointer to an array is distinguished from a pointer to a
single element.  For example
     pointer(array(integer_8))

is probably a more appropriate declaration of a C string type than
     pointer(integer_8)

which is the orthodox way to declare a string in C.


File: sicstus.info,  Node: str-fty-dty,  Up: str-fty

10.43.1.1 Declaring Types
.........................

Programmers may declare new named data structures with the following
procedure:
     :- foreign_type
         Type_name = Type,
         ...,
         Type_name = Type.

where TYPE_NAME is an atom, and TYPE defines either an atomic or
compound type, or is a previously-defined type name.

   In Prolog, atomic types are represented by the natural atomic term
(integer, float, or atom).  Compound structures are represented by terms
whose functor is the name of the type, and whose only argument is the
address of the data.  So a term 'foo(123456)' represents the thing of
type 'foo' that exists at machine address 123456.  And a term
'integer(123456)' represents the integer that lives in memory at address
123456, _not_ the number 123456.

   For types that are not named, a type name is generated using the
names of associated types and the dollar sign character ('$'), and
possibly a number.  Therefore, users should not use '$' in their type
names.


File: sicstus.info,  Node: str-cft,  Next: str-cdf,  Prev: str-fty,  Up: lib-structs

10.43.2 Checking Foreign Term Types
-----------------------------------

The type of a foreign term may determined by the goal
     foreign_type(+FOREIGN_TERM, -TYPE_NAME)

   Note that 'foreign_type/2' will fail if FOREIGN_TERM is not a foreign
term.


File: sicstus.info,  Node: str-cdf,  Next: str-afd,  Prev: str-cft,  Up: lib-structs

10.43.3 Creating and Destroying Foreign Terms
---------------------------------------------

Prolog can create or destroy foreign terms using
     new(+TYPE, -DATUM),
     new(+TYPE, +SIZE, -DATUM) and
     dispose(+DATUM)

where TYPE is an atom specifying what type of foreign term is to be
allocated, and DATUM is the foreign term.  TYPE should be an atomic type
or a previously-defined type name.  The DATUM returned by 'new/[2,3]' is
initialized to all zeroes.  'dispose/1' is a dangerous operation, since
once the memory is disposed, it may be used for something else later.
If DATUM is later accessed, then the results will be unpredictable.
'new/3' is only used to allocate arrays whose size is not known
beforehand, as defined by 'array(TYPE)', rather than 'array(NUM,TYPE)'.


File: sicstus.info,  Node: str-afd,  Next: str-cas,  Prev: str-cdf,  Up: lib-structs

10.43.4 Accessing and Modifying Foreign Term Contents
-----------------------------------------------------

Prolog can get or modify the contents of a foreign term with the
procedures
     get_contents(+DATUM, ?PART, ?VALUE)
     put_contents(+DATUM, +PART, +VALUE).

   It can also get a pointer to a field or element of a foreign term
with the procedure
     get_address(+DATUM, ?PART, ?VALUE).

   For all three of these, DATUM must be a foreign term, and PART
specifies what part of DATUM VALUE is.  If DATUM is an array, then PART
should be an integer index into the array, where 0 is the first element.
For a pointer, PART should be the atom 'contents' and VALUE will be what
the pointer points to.  For a struct, PART should be a field name, and
VALUE will be the contents of that field.  In the case of
'get_contents/3' and 'get_address/3', if PART is unbound, then
'get_contents/3' will backtrack through all the valid parts of DATUM,
binding both PART and VALUE.  A C programmer might think of the
following pairs as corresponding to each other:
     Prolog: get_contents(Foo, Bar, Baz)
          C: Baz = Foo->Bar

     Prolog: put_contents(Foo, Bar, Baz)
          C: Foo->Bar = Baz

     Prolog: get_address(Foo, Bar, Baz)
          C: Baz = &Foo->Bar.

   The hitch is that only atomic and pointer types can be got and put by
'get_contents/3' and 'put_contents/3'.  This is because Prolog can only
hold pointers to C structures, not the structures themselves.  This is
not quite as bad as it might seem, though, since usually structures
contain pointers to other structures, anyway.  When a structure directly
contains another structure, Prolog can get a pointer to it with
'get_address/3'.


File: sicstus.info,  Node: str-cas,  Next: str-nul,  Prev: str-afd,  Up: lib-structs

10.43.5 Casting
---------------

Prolog can "cast" one type of foreign term to another.  This means that
the foreign term is treated just as if it where the other type.  This is
done with the following procedure:
     cast(+FOREIGN0, +NEW_TYPE, -FOREIGN)

where FOREIGN is the foreign term that is the same data as FOREIGN0,
only is of foreign type NEW_TYPE.  FOREIGN0 is not affected.  This is
much like casting in C.

   Casting a foreign term to 'address' will get you the raw address of a
foreign term.  This is not often necessary, but it is occasionally
useful in order to obtain an indexable value to use in the first
argument of a dynamic predicate you are maintaining.  An 'address' may
also be cast to a proper foreign type.

   This predicate should be used with great care, as it is quite easy to
get into trouble with this.


File: sicstus.info,  Node: str-nul,  Next: str-ifc,  Prev: str-cas,  Up: lib-structs

10.43.6 Null Foreign Terms
--------------------------

"NULL" foreign terms may be handled.  The predicate
     null_foreign_term(+TERM, -TYPE)
     null_foreign_term(-TERM, +TYPE)

holds when TERM is a foreign term of TYPE, but is NULL (the address is
0).  At least one of TERM and TYPE must be bound.  This can be used to
generate NULL foreign terms, or to check a foreign term to determine
whether or not it is NULL.


File: sicstus.info,  Node: str-ifc,  Next: str-etr,  Prev: str-nul,  Up: lib-structs

10.43.7 Interfacing with Foreign Code
-------------------------------------

Foreign terms may be passed between Prolog and other languages through
the foreign interface.

   To use this, all foreign types to be passed between Prolog and
another language must be declared with 'foreign_type/2' before the
'foreign/[2,3]' clauses specifying the foreign functions.

   The 'structs' package extends the foreign type specifications
recognized by the foreign interface.  In addition to the types already
recognized by the foreign interface, any atomic type recognized by the
'structs' package is understood, as well as a pointer to any named
'structs' type.

   For example, if you have a function

     char nth_char(char *string, int n)
     {
         return string[n];
     }

   then you might use it from Prolog as follows:
     :- foreign_type cstring = array(integer_8).

     foreign(nth_char, c, nth_char(+pointer(cstring), +integer, [-integer_8])).

   This allows the predicate 'nth_char/3' to be called from Prolog to
determine the nth character of a C string.

   Note that all existing foreign interface type specifications are
unaffected, in particular 'address/[0,1]' continue to pass addresses to
and from Prolog as plain integers.

   If you use the foreign resource linker, 'splfr', on a Prolog file
that uses the 'structs' package, then you must pass it the '--structs'
option.  This will make 'splfr' understand foreign type specifications
and translate them into C declarations in the generated header file
(*note The Foreign Resource Linker::).


File: sicstus.info,  Node: str-etr,  Next: str-tip,  Prev: str-ifc,  Up: lib-structs

10.43.8 Examining Type Definitions at Run Time
----------------------------------------------

The above described procedures should be sufficient for most needs.
This module does, however, provide a few procedures to allow programmers
to access type definitions.  These may be a convenience for debugging,
or in writing tools to manipulate type definitions.

   The following procedures allow programmers to find the definition of
a given type:
     type_definition(?TYPE, ?DEFINITION)
     type_definition(?TYPE, ?DEFINITION, ?SIZE)

where TYPE is an atom naming a type, DEFINITION is the definition of
that type, and SIZE is the number of bytes occupied by a foreign term of
this type.  SIZE will be the atom 'unknown' if the size of an object of
that type is not known.  Such types may not be used as fields in structs
or unions, or in arrays.  However, pointers to them may be created.  If
TYPE is not bound at call time, then these procedures will backtrack
through all current type definitions.

   A definition looks much like the definition given when the type was
defined with 'type/1', except that it has been simplified.  Firstly,
intermediate type names have been elided.  For example, if 'foo' is
defined as 'foo=integer', and 'bar' as 'bar=foo', then
'type_definition(bar, integer)' would hold.  Also, in the definition of
a compound type, types of parts are always defined by type names, rather
than complex specifications.  So if the type of a field in a struct was
defined as 'pointer(fred)', then it will show up in the definition as
''$fred''.  Of course, 'type_definition('$fred', pointer(fred))' would
hold, also.

   The following predicates allow the programmer to determine whether or
not a given type is atomic:
     atomic_type(?TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE, ?SIZE)

where TYPE is an atomic type.  See *note str-fty:: for the definition of
an atomic type.  PRIMITIVE_TYPE is the primitive type that TYPE is
defined in terms of.  SIZE is the number of bytes occupied by an object
of type TYPE, or the atom 'unknown', as above.  If TYPE is unbound at
call time, then these predicates will backtrack through all the
currently defined atomic types.


File: sicstus.info,  Node: str-tip,  Next: str-exa,  Prev: str-etr,  Up: lib-structs

10.43.9 Tips
------------

  1. Most important tip: do not subvert the 'structs' type system by
     looking inside foreign terms to get the address, or use 'functor/3'
     to get the type.  This has two negative effects: firstly, if the
     'structs' package should change its representation of foreign
     terms, then your code will not work.  But more importantly, you are
     more likely to get type mismatches, and likely to get unwrapped
     terms or even doubly wrapped terms where you expect wrapped ones.
  2. Remember that a foreign term 'fred(123456)' is not of type 'fred',
     but a pointer to 'fred'.  Looked at another way, what resides in
     memory at address 123456 is of type 'fred'.
  3. The wrapper put on a foreign term signifies the type of that
     foreign term.  If you declare a type to be 'pointer(opaque)'
     because you want to view that pointer to be opaque, when you get
     something of this type, then it will be printed as
     'opaque(456123)'.  This is not very informative.  It is better to
     declare
          fred = opaque,
          thing = struct([...,
                      part:pointer(fred),
                      ...
                  ]).

     so that when you get the contents of the 'part' member of a
     'thing', it is wrapped as 'fred(456123)'.


File: sicstus.info,  Node: str-exa,  Prev: str-tip,  Up: lib-structs

10.43.10 Example
----------------

The following example shows how to use 'library(structs)' in a simple
package for handling integer arrays.  We define a module 'minivec' with
exported predicates for creating and disposing arrays, accessing its
elements, and computing their sum.  The summing operation is implemented
in C and the rest in Prolog.  Arrays are created using the 'array(TYPE)'
foreign type.

   Note that the type declaration 'int32' does not have to be given in
the C source code, as it appears in the automatically generated header
file 'minivec_glue.h'.  Note also how the foreign type specification
'+pointer(int_array)' corresponds to the C type declaration 'int32 *'.

                                                         _% minivec.pl_
     :- module(minivec, [
             new_array/2,
             get_array/3,
             put_array/3,
             dispose_array/1,
             sum_array/2
             ]).

     :- load_files(library(str_decl), [when(compile_time)]).
     :- use_module(library(structs)).

     :- foreign_type
             int32           = integer_32,
             int_array       = array(int32).

     foreign(c_sum_array, c_sum_array(+integer,
                                      +pointer(int_array),
                                      [-integer])).

     foreign_resource(minivec, [c_sum_array]).

     :- load_foreign_resource(minivec).

     new_array(Size, array(Size,Mem)) :-
             new(int_array, Size, Mem).

     get_array(Index, array(_,Mem), Value) :-
             get_contents(Mem, Index, Value).

     put_array(Index, array(_,Mem), Value) :-
             put_contents(Mem, Index, Value).

     dispose_array(array(_,Mem)) :-
             dispose(Mem).

     sum_array(array(Size,Mem), Sum) :-
             c_sum_array(Size, Mem, Sum).

                                                      _/* minivec.c */_
     #include "minivec_glue.h"

     SP_integer c_sum_array(SP_integer cnt, int32 *mem)
     {
       int i;
       SP_integer sum = 0;

       for (i=0; i<cnt; i++)
         sum += mem[i];
       return sum;
     }

                                                            _# session_
     % splfr --struct minivec.pl minivec.c
     % sicstus -l minivec
     % compiling /home/matsc/sicstus4/Suite/minivec.pl...
     % [...]
     % compiled /home/matsc/sicstus4/Suite/minivec.pl in module minivec, 30 msec 68388 bytes
     SICStus 4.7.0 ...
     Licensed to SICS
     | ?- new_array(4, A),
          put_array(0,A,1),
          put_array(1,A,10),
          put_array(2,A,100),
          put_array(3,A,1000),
          sum_array(A,S),
          dispose_array(A).
     A = array(4,int_array(1264224)),
     S = 1111

   A fragment from the generated header file:

                                                 _/* minivec_glue.h */_
     #include <sicstus/sicstus.h>
     #include <stdlib.h>
     typedef int int32;
     typedef int32 *(int_array)/* really an unknown-size array */;
     extern SP_integer c_sum_array( SP_integer, int32 *);


File: sicstus.info,  Node: lib-system,  Next: lib-tcltk,  Prev: lib-structs,  Up: The Prolog Library

10.44 Operating System Utilities--'library(system)'
===================================================

This package contains utilities for invoking services from the operating
system that do not fit elsewhere.  This package contains utilities for
invoking services from the operating system that does not fit elsewhere.

   Exported predicates:

'now(-WHEN)'

     Unifies the current date and time as a UNIX timestamp with WHEN.
'datime(-DATIME)'

     Unifies DATIME with the current date and time as a 'datime/6'
     record of the form 'datime(YEAR,MONTH,DAY,HOUR,MIN,SEC)'.  All
     fields are integers.
'datime(+WHEN,-DATIME)'
'datime(-WHEN,+DATIME)'
     Convert a time stamp, as obtained by 'now/1', to a 'datime/6'
     record.  Can be used in both directions.
'sleep(+SECONDS)'

     Puts the SICStus Prolog process asleep for SECOND seconds, where
     SECONDS should be a non-negative number.
'environ(?VAR, ?VALUE)'

     VAR is the name of a system property or an environment variable,
     and VALUE is its value.  Both are atoms.  Can be used to enumerate
     all current system properties and environment variables.

     The same as 'environ(VAR, VALUE, merged)'.
'environ(?VAR, ?VALUE, +SOURCE)   since release 4.1'
     VAR is the name of an environment variable or system property, and
     VALUE is its value.  Both are atoms.  Can be used to enumerate all
     current environment variables and system properties.

     SOURCE is one of 'properties', in which case only system properties
     are enumerated; 'environment', in which case only environment
     variables are enumerated; and 'merged', in which case both
     environment variables and system properties are enumerated.  When
     SOURCE is 'merged' and an environment variable and a system
     property have equivalent names, the value of the system property is
     returned.

     On UNIX-like platforms, two names are equivalent if and only if
     they are identical.  On Windows-like platforms, a case insensitive
     comparison is used.

     *Note System Properties and Environment Variables::, for more
     information.


File: sicstus.info,  Node: lib-tcltk,  Next: lib-terms,  Prev: lib-system,  Up: The Prolog Library

10.45 Tcl/Tk Interface--'library(tcltk)'
========================================

* Menu:

* Introduction (Tcl):: Introduction
* Tcl:: Tcl
* Tk:: Tk
* The Tcl/Tk Prolog Library:: The Tcl/Tk Prolog Library
* Putting It All Together:: Putting It All Together
* Quick Reference:: Quick Reference
* Resources:: Resources


File: sicstus.info,  Node: Introduction (Tcl),  Next: Tcl,  Up: lib-tcltk

10.45.1 Introduction
--------------------

This is a basic tutorial for those SICStus Prolog users who would like
to add Tcl/Tk user interfaces to their Prolog applications.  The
tutorial assumes no prior knowledge of Tcl/Tk but, of course, does
assume the reader is proficient in Prolog.

   Aware that the reader may not have heard of Tcl/Tk, we will start by
answering three questions: what is Tcl/Tk?  what is it good for?  what
relationship does it have to Prolog?

* Menu:

* What Is Tcl/Tk?:: What Is Tcl/Tk?
* What Is Tcl/Tk Good For?:: What Is Tcl/Tk Good For?
* What Is Tcl/Tks Relationship to SICStus Prolog?:: What Is Tcl/Tks Relationship to SICStus Prolog?
* A Quick Example of Tcl/Tk in Action:: A Quick Example of Tcl/Tk in Action
* Outline of This Tutorial:: Outline of This Tutorial


File: sicstus.info,  Node: What Is Tcl/Tk?,  Next: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.45.1.1 What Is Tcl/Tk?
.........................

Tcl/Tk, as its title suggests, is actually two software packages: Tcl
and Tk.  Tcl, pronounced _tickle_, stands for _tool command language_
and is a scripting language that provides a programming environment and
programming facilities such as variables, loops, and procedures.  It is
designed to be easily extensible.

   Tk, pronounced _tee-kay_, is just such an extension to Tcl, which is
a "toolkit" for windowing systems.  In other words, Tk adds facilities
to Tcl for creating and manipulating user interfaces based on windows
and widgets within those windows.


File: sicstus.info,  Node: What Is Tcl/Tk Good For?,  Next: What Is Tcl/Tks Relationship to SICStus Prolog?,  Prev: What Is Tcl/Tk?,  Up: Introduction (Tcl)

10.45.1.2 What Is Tcl/Tk Good For?
..................................

In combination the Tcl and Tk packages (we will call the combination
simply Tcl/Tk) are useful for creating graphical user interfaces (GUIs)
to applications.  The GUI is described in terms of instances of Tk
widgets, created through calls in Tcl, and Tcl scripts that form the
glue that binds together the GUI and the application.  (If you are a
little lost at this point, then all will be clear in a moment with a
simple example.)

   There are lots of systems out there for adding GUIs to applications
so why choose Tcl/Tk?  Tcl/Tk has several advantages that make it
attractive for this kind of work.  Firstly, it is good for rapid
prototyping of GUIs.  Tcl is an interpreted scripting language.  The
scripts can be modified and executed quickly, with no compilation phase,
so speeding up the development loop.

   Secondly, it is easier to use a system based on a scripting language,
such as Tcl/Tk, than many of the conventional packages available.  For
example, getting to grips with the X windows suite of C libraries is not
an easy task.  Tcl/Tk can produce the same thing using simple scripting
with much less to learn.  The penalty for this is that programs written
in an interpreted scripting language will execute more slowly than those
written using compiled C library calls, but for many interfaces that do
not need great speed Tcl/Tk is fast enough and its ease of use more than
outweighs the loss of speed.  In any case, Tcl/Tk can easily handle
hundreds of events per mouse movement without the user noticing.

   Thirdly, Tcl/Tk is good for making cross-platform GUIs.  The Tk
toolkit has been ported to native look-and-feel widgets on Mac, PC
(Windows), and UNIX (X windows) platforms.  You can write your scripts
once and they will execute on any of these platforms.

   Lastly, the software is distributed under a free software license and
so is available in both binary and source formats free of charge.


File: sicstus.info,  Node: What Is Tcl/Tks Relationship to SICStus Prolog?,  Next: A Quick Example of Tcl/Tk in Action,  Prev: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.45.1.3 What Is Tcl/Tks Relationship to SICStus Prolog?
.........................................................

SICStus Prolog comes with a Prolog library for interfacing to Tcl/Tk.
The purpose of the library is to enable Prolog application developers to
add GUIs to their applications rapidly and easily.


File: sicstus.info,  Node: A Quick Example of Tcl/Tk in Action,  Next: Outline of This Tutorial,  Prev: What Is Tcl/Tks Relationship to SICStus Prolog?,  Up: Introduction (Tcl)

10.45.1.4 A Quick Example of Tcl/Tk in Action
.............................................

As a taster, we will show you two simple examples programs that use
SICStus Prolog with the Tcl/Tk extensions: the ubiquitous "hello world"
example; and a very simple telephone book look up example.

   You are not expected to understand how these examples work at this
stage.  They are something for you to quickly type in to see how easy it
is to add GUIs to Prolog programs through Tcl/Tk.  After reading through
the rest of this tutorial you will fully understand these examples and
be able to write your own GUIs.

   Here is the "Hello World" program; also in
'library('tcltk/examples/ex1.pl')':

     :- use_module(library(tcltk)).

     go :-
         tk_new([name('Example 1')], Interp),
         tcl_eval(Interp, 'button .fred -text "hello world"
                           -command { puts "hello world"}', _),
         tcl_eval(Interp, 'pack .fred', _),
         tk_main_loop.


 [image src="images/tcltkex1.png" text="" ]
                  SICStus+Tcl/Tk hello world program.

   To run it just start up SICStus (under Windows use 'sicstus', not
'spwin'), load the program, and evaluate the Prolog goal 'go'.  The
first line of the 'go' clause calls 'tk_new/2', which creates a Tcl/Tk
interpreter and returns a handle 'Interp' through which Prolog will
interact with the interpreter.  Next a call to 'tcl_eval/3' is made,
which creates a button displaying the 'hello world' text.  Next a call
is made to 'tcl_eval/3' that causes the button to be displayed in the
main application window.  Finally, a call is make to 'tk_main_loop/0'
that passes control to Tcl/Tk, making sure that window events are
serviced.

   See how simple it is with just a three line Prolog program to create
an application window and display a button in it.  Click on the button
and see what it does.

   The reason you should use 'sicstus' under Windows instead of 'spwin'
is that the latter does not have the C standard streams
('stdin','stdout','stderr') and the Tcl command 'puts' will give an
error if there is no 'stdout'.

   The previous example showed us how to create a button and display
some text in it.  It was basically pure Tcl/Tk generated from within
Prolog but did not have any interaction with Prolog.  The following
example demonstrates a simple callback mechanism.  A name is typed into
a text entry box, a button is pressed, which looks up the telephone
number corresponding to the name in a Prolog database, and the telephone
number is then displayed.

   Here is the code; also in 'library('tcltk/examples/ex2.pl')':

     :- use_module(library(tcltk)).

     telephone(fred, '123-456').
     telephone(wilbert, '222-2222').
     telephone(taxi, '200-0000').
     telephone(mary, '00-36-1-666-6666').

     go :-
          tk_new([name('Example 2')], T),
          tcl_eval(T, 'entry .name -textvariable name',_),
          tcl_eval(T, 'button .search -text search -command {
                           prolog telephone($name,X);
                           set result $prolog_variables(X) }', _),
          tcl_eval(T, 'label .result -relief raised -textvariable result', _),
          tcl_eval(T, 'pack .name .search .result -side top -fill x', _),
          tk_main_loop.


 [image src="images/tcltkex2.png" text="" ]
                SICStus+Tcl/Tk telephone number lookup

   Again, to run the example, start up SICStus Prolog, load the code,
and run the goal 'go'.

   You will notice that three widgets will appear in a window: one is
for entering the name of the person or thing that you want to find the
telephone number for, the button is for initiating the search, and the
text box at the bottom is for displaying the result.

   Type 'fred' into the entry box, hit the search button and you should
see the phone number displayed.  You can then try the same thing but
with 'wilbert', 'taxi' or 'mary' typed into the text entry box.

   What is happening is that when the button is pressed, the value in
the entry box is retrieved, then the 'telephone/2' predicate is called
in Prolog with the entry box value as first argument, then the second
argument of telephone is retrieved (by this time bound to the number)
and is displayed below the button.

   This is a very crude example of what can be done with the Tcl/Tk
module in Prolog.  For example, this program does not handle cases where
there is no corresponding phone number or where there is more than one
corresponding phone number.  The example is just supposed to wet your
appetite, but all these problems can be handled by Prolog + Tcl/Tk,
although with a more sophisticated program.  You will learn how to do
this in the subsequent chapters.


File: sicstus.info,  Node: Outline of This Tutorial,  Prev: A Quick Example of Tcl/Tk in Action,  Up: Introduction (Tcl)

10.45.1.5 Outline of This Tutorial
..................................

Now we have motivated using Tcl/Tk as a means of creating GUIs for
Prolog programs, this document goes into the details of using Tcl/Tk as
a means of building GUIs for SICStus Prolog applications.

   Firstly, Tcl is introduced and its syntax and core commands
described.  Then the Tk extensions to Tcl are introduced.  We show how
with Tcl and Tk together the user can build sophisticated GUIs easily
and quickly.  At the end of this Tcl/Tk part of the tutorial an example
of a pure Tcl/Tk program will be presented together with some tips on
how to design and code Tcl/Tk GUIs.

   The second phase of this document describes the SICStus Prolog
'tcltk' library.  It provides extensions to Prolog that allow Prolog
applications to interact with Tcl/Tk: Prolog can make calls to Tcl/Tk
code and vice versa.

   Having reached this point in the tutorial the user will know how to
write a Tcl/Tk GUI interface and how to get a Prolog program to interact
with it, but arranging which process (the Prolog process or the Tcl/Tk
process) is the dominant partner is non-trivial and so is described in a
separate chapter on event handling.  This will help the user choose the
most appropriate method of cooperation between Tcl/Tk and Prolog to suit
their particular application.

   This section, the Tcl/Tk+Prolog section, will be rounded off with the
presentation of some example applications that make use of Tcl/Tk and
Prolog.

   Then there is a short discussion section on how to use other Tcl
extension packages with Tcl/Tk and Prolog.  Many such extension packages
have been written and when added to Prolog enhanced with Tcl/Tk can
offer further functionality to a Prolog application.

   The appendices provide a full listing with description of the
predicates available in the 'tcltk' SICStus Prolog library, and the
extensions made to Tcl/Tk for interacting with Prolog.

   Lastly, a section on resources gives pointers to where the reader can
find more information on Tcl/Tk.


File: sicstus.info,  Node: Tcl,  Next: Tk,  Prev: Introduction (Tcl),  Up: lib-tcltk

10.45.2 Tcl
-----------

Tcl is an interpreted scripting language.  In this chapter, first the
syntax of Tcl is described and then the core commands are described.  It
is not intended to give a comprehensive description of the Tcl language
here but an overview of the core commands, enough to get the user
motivated to start writing their own scripts.

   For pointers to more information on Tcl; *note Resources::.

* Menu:

* Syntax (Tcl):: Syntax
* Variables (Tcl):: Variables
* Commands:: Commands
* What We Have Left Out (Tcl):: What We Have Left Out


File: sicstus.info,  Node: Syntax (Tcl),  Next: Variables (Tcl),  Up: Tcl

10.45.2.1 Syntax
................

A Tcl script consists of a series of strings separated from each other
by a newline character.  Each string contains a command or series of
semi-colon separated commands.  A command is a series of words separated
by spaces.  The first word in a command is the name of the command and
subsequent words are its arguments.

   An example is:

     set a 1
     set b 2

which is a Tcl script of two commands: the first command sets the value
of variable 'a' to '1', and the second command sets the value of
variable 'b' to '2'.

   An example of two commands on the same line separated by a semi-colon
is:

     set a 1; set b 2

which is equivalent to the previous example but written entirely on one
line.

   A command is executed in two phases.  In the first phase, the command
is broken down into its constituent words and various textual
substitutions are performed on those words.  In the second phase, the
procedure to call is identified from the first word in the command, and
the procedure is called with the remaining words as arguments.

   There are special syntactic characters that control how the first
phase, the substitution phase, is carried out.  The three major
substitution types are variable substitution, command substitution, and
backslash substitution.

   _Variable substitution_ happens when a '$' prefixed word is found in
a command.  There are three types of variable substitution:

   - '$NAME'
        - where NAME is a scalar variable.  NAME is simply substituted
          in the word for its value.  NAME can contain only letters,
          digits, or underscores.

   - '$NAME(INDEX)'
        - where NAME is the name of an array variable and INDEX is the
          index into it.  This is substituted by the value of the array
          element.  NAME must contain only letters, digits, or
          underscores.  INDEX has variable, command, and backslash
          substitution performed on it too.

   - '${NAME}'
        - where NAME can have any characters in it except closing curly
          bracket.  This is more or less the same as '$NAME'
          substitution except it is used to get around the restrictions
          in the characters that can form NAME.

   An example of variable substitution is:

     set a 1
     set b $a

which sets the value of variable 'a' to '1', and then sets the value of
variable 'b' to the value of variable 'a'.

   _Command substitution_ happens when a word contains an open square
bracket, '['.  The string between the open bracket and matching closing
bracket are treated as a Tcl script.  The script is evaluated and its
result is substituted in place of the original command substitution
word.

   A simple example of command substitution is:

     set a 1
     set b [set a]

which does the same as the previous example but using command
substitution.  The result of a 'set a' command is to return the value of
'a', which is then passed as an argument to 'set b' and so variable 'b'
acquires the value of variable 'a'.

   _Backslash substitution_ is performed whenever the interpreter comes
across a backslash.  The backslash is an escape character and when it is
encountered is causes the interpreter to handle the next characters
specially.  Commonly escaped characters are '\a' for audible bell, '\b'
for backspace, '\f' for form feed, '\n' for newline, '\r' for carriage
return, '\t' for horizontal tab, and '\v' for vertical tab.
Double-backslash, '\\', is substituted with a single backslash.  Other
special backslash substitutions have the following forms:

   * '\ooo'
        - the digits 'ooo' give the octal value of the escaped character

   * '\xHH'
        - the 'x' denotes that the following hexadecimal digits are the
          value of the escaped character

   Any other character that is backslash escaped is simply substituted
by the character itself.  For example, '\W' is replaced by 'W'.

   A further syntactic construction is used to _delay substitution_.
When the beginning of a word starts with a curly bracket, '{', it does
not do any of the above substitutions between the opening curly bracket
and its matching closing curly bracket.  The word ends with the matching
closing curly bracket.  This construct is used to make the bodies of
procedures in which substitutions happen when the procedure is called,
not when it is constructed.  Or it is used anywhere when the programmer
does not want the normal substitutions to happen.  For example:

     puts {I have $20}

will print the string 'I have $20' and will not try variable
substitution on the '$20' part.

   A word delineated by curly brackets is replaced with the characters
within the brackets without performing the usual substitutions.

   A word can begin with a _double-quote_ and end with the matching
closing double-quote.  Substitutions as detailed above are done on the
characters between the quotes, and the result is then substituted for
the original word.  Typically double-quotes are used to group sequences
of characters that contain spaces into a single command word.

   For example:

     set name "Fred the Great"
     puts "Hello my name is $name"

outputs 'Hello my name is Fred the Great'.  The first command sets the
value of variable 'name' to the following double-quoted string '"Fred
the Great"'.  The the next command prints its argument, a single
argument because it is a word delineated by double-quotes, that has had
variable substitution performed on it.

   Here is the same example but using curly brackets instead of
double-quotes:

     set name {Fred the Great}
     puts {Hello my name is $name}

gives the output 'Hello my name is $name' because substitutions are
suppressed by the curly bracket notation.

   And again the same example but without either curly brackets or
double-quotes:

     set name Fred the Great
     puts Hello my name is $name

simply fails because both 'set' and 'puts' expect a single argument but
without the word grouping effects of double-quotes or curly brackets
they find that they have more than one argument and throw an exception.

   Being a simple scripting language, Tcl does not have any real idea of
data types.  The interpreter simply manipulates strings.  The Tcl
interpreter is not concerned with whether those strings contain
representations of numbers or names or lists.  It is up to the commands
themselves to interpret the strings that are passed to them as arguments
in any manner those choose.


File: sicstus.info,  Node: Variables (Tcl),  Next: Commands,  Prev: Syntax (Tcl),  Up: Tcl

10.45.2.2 Variables
...................

This has been dealt with implicitly above.  A variable has a name and a
value.  A name can be any string whatsoever, as can its value.

   For example,

     set "Old King Cole" "merry soul"

sets the value of the variable named 'Old King Cole' to the value 'merry
soul'.  Variable names can also be numbers:

     set 123 "one two three"

sets the variable with name '123' to the value 'one two three'.  In
general, it is better to use the usual conventions -- start with a
letter then follow with a combination of letters, digits, and
underscores -- when giving variables names to avoid confusion.

   Array variables are also available in Tcl.  These are denoted by an
array name followed by an array index enclosed in round brackets.  As an
example:

     set fred(one) 1
     set fred(two) 2

will set the variable 'fred(one)' to the value '1' and 'fred(two)' to
the value '2'.

   Tcl arrays are associative arrays in that both the array name and the
array index can be arbitrary strings.  This also makes multidimensional
arrays possible if the index contains a comma:

     set fred(one,two) 12

   It is cheating in that the array is not stored as a multidimensional
array with a pair of indices, but as a linear array with a single index
that happens to contain a comma.


File: sicstus.info,  Node: Commands,  Next: What We Have Left Out (Tcl),  Prev: Variables (Tcl),  Up: Tcl

10.45.2.3 Commands
..................

Now that the Tcl syntax and variables have been been dealt with, we will
now look at some of the commands that are available.

   Each command when executed returns a value.  The return value will be
described along with the command.

   A quick word about the _notation_ used to describe Tcl commands.  In
general, a description of a command is the name of the command followed
by its arguments separated by spaces.  An example is:

     set VARNAME ?VALUE?

which is a description of the Tcl set command, which takes a variable
name VARNAME and an optional argument, a VALUE.

   Optional arguments are enclosed in question mark, ?, pairs, as in the
example.

   A series of three dots ... represents repeated arguments.  An example
is a description of the 'unset' command:

     unset VARNAME ?VARNAME VARNAME ...?

which shows that the 'unset' command has at least one compulsory
argument VARNAME but has any number of subsequent optional arguments.

   The most used _command over variables_ is the 'set' command.  It has
the form

     set VARNAME ?VALUE?

   The value of VALUE is determined, the variable VARNAME is set to it,
and the value is returned.  If there is no VALUE argument, then the
value of the variable is simply returned.  It is thus used to set and/or
get the value of a variable.

   The 'unset' command is used to remove variables completely from the
system:

     unset VARNAME ?VARNAME VARNAME ...?

which given a series of variable names deletes them.  The empty string
is always returned.

   There is a special command for incrementing the value of a variable:

     incr VARNAME ?INCREMENT?

which, given the name of a variable whose value is an integer string,
increments it by the amount INCREMENT.  If the INCREMENT part is left
out, then it defaults to '1'.  The return value is the new value of the
variable.

   _Expressions_ are constructed from operands and operators and can
then be evaluated.  The most general expression evaluator in Tcl is the
'expr' command:

     expr ARG ?ARG ARG ... ARG?

which evaluates its arguments as an expression and returns the value of
the evaluation.

   A simple example expression is

     expr 2 * 2

which when executed returns the value '4'.

   There are different classes of operators: arithmetic, relational,
logical, bitwise, and choice.  Here are some example expressions
involving various operators:

arithmetic    '$x * 2'
relational    '$x > 2'
logical       '($x == $y) || ($x == $z)'
bitwise       '8 & 2'
choice        '($a == 1) ? $x : $y'

   Basically the operators follow the syntax and meaning of their ANSI C
counterparts.

   Expressions to the 'expr' command can be contained in curly brackets
in which case the usual substitutions are not done before the 'expr'
command is evaluated, but the command does its own round of
substitutions.  So evaluating a script such as:

     set a 1
     expr { ($a==1) : "yes" ? "no" }

will evaluate to 'yes'.

   Tcl also has a whole host of math functions that can be used in
expressions.  Their evaluation is again the same as that for their ANSI
C counterparts.  For example:

     expr { 2*log($x) }

will return 2 times the natural log of the value of variable 'x'.

   Tcl has a notion of _lists_, but as with everything it is implemented
through strings.  A list is a string that contains words.

   A simple list is just a space separated series of strings:

     set a {one two three four five}

will set the variable 'a' to the list containing the five strings shown.
The empty list is denoted by an open and close curly bracket pair with
nothing in between: '{}'.

   For the Prolog programmer, there is much confusion between a Prolog
implementation of lists and the Tcl implementation of lists.  In Prolog
we have a definite notion of the printed representation of a list: a
list is a sequence of terms enclosed in square brackets (we ignore dot
notation for now); a nested list is just another term.

   In Tcl, however, a list is really just a string that conforms to a
certain syntax: a string of space separated words.  But in Tcl there is
more than one way of generating such a string.  For example,

     set fred {a b c d}

sets 'fred' to

     "a b c d"

as does

     set fred "a b c d"

because '{a b c d}' evaluates to the string 'a b c d', which has the
correct syntax for a list.  But what about nested lists?  Those are
represented in the final list-string as being contained in curly
brackets.  For example:

     set fred {a b c {1 2 3} e f}

results in 'fred' having the value

     "a b c {1 2 3} e f"

   The outer curly brackets from the 'set' command have disappeared,
which causes confusion.  The curly brackets within a list denote a
nested list, but there are no curly brackets at the top level of the
list.  (We cannot help thinking that life would have been easier if the
creators of Tcl would have chosen a consistent representation for lists,
as Prolog and LISP do.)

   So remember: a list is really a string with a certain syntax, space
separated items or words; a nested list is surrounded by curly brackets.

   There are a dozen commands that operate on lists.

     concat ?LIST LIST ...?

   This makes a list out of a series of lists by concatenating its
argument lists together.  The return result is the list resulting from
the concatenation.

     lindex LIST INDEX

returns the INDEX-th element of the LIST.  The first element of a list
has an index of 0.

     linsert LIST INDEX VALUE ?VALUE ...?

returns a new list in which the VALUE arguments have been inserted in
turn before the INDEX-th element of LIST.

     list ?VALUE VALUE ...?

returns a list where each element is one of the VALUE arguments.

     llength LIST

returns the number of elements in list LIST.

     lrange LIST FIRST LAST

returns a slice of a list consisting of the elements of the list LIST
from index FIRST until index LAST.

     lreplace LIST FIRST LAST ?VALUE ... VALUE?

returns a copy of list LIST but with the elements between indices FIRST
and LAST replaced with a list formed from the VALUE arguments.

     lsearch ?-exact? ?-glob? ?-regexp? LIST PATTERN

returns the index of the first element in the list that matches the
given pattern.  The type of matching done depends on which of the switch
is present '-exact', '-glob', '-regexp', is present.  Default is
'-glob'.

     lsort ?-ascii? ?-integer? ?-real? ?-command COMMAND? ?-increasing? ?-decreasing{? LIST

returns a list, which is the original list LIST sorted by the chosen
technique.  If none of the switches supplies the intended sorting
technique, then the user can provide one through the '-command COMMAND'
switch.

   There are also two useful commands for converting between lists and
strings:

     join LIST ?JOINSTRING?

which concatenates the elements of the list together, with the separator
JOINSTRING between them, and returns the resulting string.  This can be
used to construct filenames; for example:

     set a {{} usr local bin}
     set filename [join $a /]

results in the variable 'filename' having the value '/usr/local/bin'.

   The reverse of the 'join' command is the 'split' command:

     split STRING ?SPLITCHARS?

which takes the string STRING and splits it into string on SPLITCHARS
boundaries and returns a list with the strings as elements.  An example
is splitting a filename into its constituent parts:

     set a [split /usr/local/src /]

gives 'a' the value '{{} usr local src}', a list.

   Tcl has the four usual classes of _control flow_ found in most other
programming languages:

     if...elseif...else, while, for, foreach, switch, and eval.

   We go through each in turn.

   The general form of an 'if' command is the following:

     if TEST1 BODY1 ?ELSEIF TEST2 BODY2 ELSEIF ...? ?ELSE BODYN?

which when evaluated, evaluates expression TEST1, which if true causes
BODY1 to be evaluated, but if false, causes TEST2 to be evaluated, and
so on.  If there is a final 'else' clause, then its BODYN part is
evaluated if all of the preceding tests failed.  The return result of an
'if' statement is the result of the last BODY command evaluated, or the
empty list if none of the bodies are evaluated.

   Conditional looping is done through the 'while' command:

     while TEST BODY

which evaluates expression TEST, which if true then evaluates BODY.  It
continues to do that until TEST evaluates to 0, and returns the empty
string.

   A simple example is:

     set a 10
     while {$a > 0} { puts $a; incr a -1 }

which initializes variable 'a' with value ten and then loops printing
out the value of 'a' and decrementing it until its value is 0, when the
loop terminates.

   The 'for' loop has the following form:

     for INIT TEST REINIT BODY

which initializes the loop by executing INIT, then each time around the
loop the expression TEST is evaluated, which if true causes BODY to be
executed and then executes REINIT.  The loop spins around until TEST
evaluates to 0.  The return result of a 'for' loop is the empty string.

   An example of a 'for' loop:

     for {set a 10} ($a>0) {incr a -1} {puts $a}

which initializes the variable 'a' with value '10', then goes around the
loop printing the value of 'a' and decrementing it as long as its value
is greater than '0'.  Once it reaches '0' the loop terminates.

   The 'foreach' command has the following form:

     foreach VARNAME LIST BODY

where VARNAME is the name of a variable, LIST is an instance of a list,
and BODY is a series of commands to evaluate.  A 'foreach' then iterates
over the elements of a list, setting the variable VARNAME to the current
element, and executes BODY.  The result of a 'foreach' loop is always
the empty string.

   An example of a 'foreach' loop:

     foreach friend {joe mary john wilbert} {puts "I like $friend"}

will produce the output:

     I like joe
     I like mary
     I like john
     I like wilbert

   There are also a couple of commands for controlling the flow of
loops: 'continue' and 'break'.

   'continue' stops the current evaluation of the body of a loop and
goes on to the next one.

   'break' terminates the loop altogether.

   Tcl has a general switch statement, which has two forms:

     switch ?OPTIONS? STRING PATTERN BODY ?PATTERN BODY ... ?
     switch ?OPTIONS? STRING { PATTERN BODY ?PATTERN BODY ...? }

   When executed, the switch command matches its STRING argument against
each of the PATTERN arguments, and the BODY of the first matching
pattern is evaluated.  The matching algorithm depends on the options
chosen, which can be one of

'-exact'     use exact matching
'-glob'      use glob-style matching
'-regexp'    use regular expression matching

   An example is:

     set a rob
     switch -glob $a {
         a*z { puts "A to Z"}
         r*b { puts "rob or rab"}
     }

which will produce the output:

     rob or rab

   There are two forms of the 'switch' command.  The second form has the
command arguments surrounded in curly brackets.  This is primarily so
that multi-line switch commands can be formed, but it also means that
the arguments in brackets are not evaluated (curly brackets suppress
evaluation), whereas in the first type of switch statement the arguments
are first evaluated before the switch is evaluated.  These effects
should be borne in mind when choosing which kind of switch statement to
use.

   The final form of control statement is 'eval':

     eval ARG ?ARG ...?

which takes one or more arguments, concatenates them into a string, and
executes the string as a command.  The return result is the normal
return result of the execution of the string as a command.

   An example is

     set a b
     set b 0
     eval set $a 10

which results in the variable 'b' being set to '10'.  In this case, the
return result of the 'eval' is '10', the result of executing the string
'"set b 10"' as a command.

   Tcl has several _commands over strings_.  There are commands for
searching for patterns in strings, formatting and parsing strings (much
the same as 'printf' and 'scanf' in the C language), and general string
manipulation commands.

   Firstly we will deal with formatting and parsing of strings.  The
commands for this are 'format' and 'scan' respectively.

     format FORMATSTRING ?VALUE VALUE ...?

which works in a similar to C's 'printf'; given a format string with
placeholders for values and a series of values, return the appropriate
string.

   Here is an example of printing out a table for base 10 logarithms for
the numbers 1 to 10:

     for {set n 1} {$n <= 10} {incr n} {
         puts [format "log10(%d) = %.4f" $n [expr log10($n)]]
     }

which produces the output

     ln(1) = 0.0000
     ln(2) = 0.3010
     ln(3) = 0.4771
     ln(4) = 0.6021
     ln(5) = 0.6990
     ln(6) = 0.7782
     ln(7) = 0.8451
     ln(8) = 0.9031
     ln(9) = 0.9542
     ln(10) = 1.0000

   The reverse function of 'format' is 'scan':

     scan STRING FORMATSTRING VARNAME ?VARNAME ...?

which parses the string according to the format string and assigns the
appropriate values to the variables.  it returns the number of fields
successfully parsed.

   An example,

     scan "qty 10, unit cost 1.5, total 15.0" \
          "qty %d, unit cost %f, total %f"    \
          quantity cost_per_unit total

would assign the value 10 to the variable 'quantity', 1.5 to the
variable 'cost_per_unit' and the value 15.0 to the variable 'total'.

   There are commands for performing two kinds of pattern matching on
strings: one for matching using regular expressions, and one for
matching using UNIX-style wildcard pattern matching (globbing).

   The command for regular expressions matching is as follows:

     regexp ?-indices? ?-nocase? EXP STRING ?MATCHVAR? ?SUBVAR SUBVAR ...?

where EXP is the regular expression and STRING is the string on which
the matching is performed.  The regexp command returns 1 if the
expression matches the string, 0 otherwise.  The optional '-nocase'
switch does matching without regard to the case of letters in the
string.  The optional MATCHVAR and SUBVAR variables, if present, are set
to the values of string matches.  In the regular expression, a match
that is to be saved into a variable is enclosed in round braces.  An
example is

     regexp {([0-9]+)} "I have 3 oranges" a

will assign the value 3 to the variable 'a'.

   If the optional switch '-indices' is present, then instead of storing
the matching substrings in the variables, the indices of the substrings
are stored; that is a list with a pair of numbers denoting the start and
end position of the substring in the string.  Using the same example:

     regexp -indices {([0-9]+)} "I have 3 oranges" a

will assign the value '"7 7"', because the matched numeral '3' is in the
eighth position in the string, and indices count from 0.

   String matching using the UNIX-style wildcard pattern matching
technique is done through the 'string match' command:

     string match PATTERN STRING

where PATTERN is a wildcard pattern and STRING is the string to match.
If the match succeeds, then the command returns 1; otherwise, it returns
0.  An example is

     string match {[a-z]*[0-9]} {a_$%^_3}

which matches because the command says match any string that starts with
a lower case letter and ends with a number, regardless of anything in
between.

   There is a command for performing string substitutions using regular
expressions:

     regsub ?-all? ?-nocase? EXP STRING SUBSPEC VARNAME

where EXP is the regular expression and STRING is the input string on
which the substitution is made, SUBSPEC is the string that is
substituted for the part of the string matched by the regular
expression, and VARNAME is the variable on which the resulting string is
copied into.  With the '-nocase' switch, the matching is done without
regard to the case of letters in the input string.  The '-all' switch
causes repeated matching and substitution to happen on the input string.
The result of a 'regsub' command is the number of substitutions made.

   An example of string substitution is:

     regsub {#name#} {My name is #name#} Rob result

which sets the variable 'result' to the value "My name is Rob".  An
example of using the '-all' switch:

     regsub -all {#name#} {#name#'s name is #name#} Rob result

sets the variable 'result' to the value "Rob's name is Rob" and it
returns the value 2 because two substitutions were made.

   The are a host of other ways to manipulate strings through variants
of the 'string' command.  Here we will go through them.

   To select a character from a string given the character position, use
the 'string index' command.  An example is:

     string index "Hello world" 6

which returns 'w', the 7th character of the string.  (Strings are
indexed from 0).

   To select a substring of a string, given a range of indices use the
'string range' command.  An example is:

     string range "Hello world" 3 7

which returns the string "lo wo".  There is a special index marker named
'end', which is used to denote the the end of a string, so the code

     string range "Hello world" 6 end

will return the string "world".

   There are two ways to do simple search for a substring on a string,
using the 'string first' and 'string last' commands.  An example of
'string first' is:

     string first "dog" "My dog is a big dog"

find the first position in string "My dog is a big dog" that matches
"dog".  It will return the position in the string in which the substring
was found, in this case 3.  If the substring cannot be found, then the
value -1 is returned.

   Similarly,

     string last "dog" "My dog is a big dog"

will return the value 16 because it returns the index of the last place
in the string that the substring matches.  Again, if there is no match,
then -1 is returned.

   To find the length of a string use 'string length', which given a
string simply returns its length.

     string length "123456"

returns the value 6.

   To convert a string completely to upper case use 'string toupper':

     string toupper "this is in upper case"

returns the string "THIS IS IN UPPER CASE".

   Similarly,

     string tolower "THIS IS IN LOWER CASE"

returns the string "this is in lower case".

   There are commands for removing characters from strings: 'string
trim', 'string trimright', and 'string trimleft'.

     string trim STRING ?CHARS?

which removes the characters in the string CHARS from the string STRING
and returns the trimmed string.  If CHARS is not present, then
whitespace characters are removed.  An example is:

     string string "The dog ate the exercise book" "doe"

which would return the string "Th g at th xrcis bk".

   'string trimleft' is the same as 'string trim' except only leading
characters are removed.  Similarly 'string trimright' removes only
trailing characters.  For example:

     string trimright $my_input

would return a copy of the string contained in '$my_input' but with all
the trailing whitespace characters removed.

   There is a comprehensive set of commands for _file manipulation_.  We
will cover only the some of the more important ones here.

   To open a file the 'open' command is used:

     open NAME ?ACCESS?

where NAME is a string containing the filename, and the option ACCESS
parameter contains a string of access flags, in the UNIX style.  The
return result is a handle to the open file.

   If ACCESS is not present, then the access permissions default to
'"r"', which means open for reading only.  The command returns a file
handle that can be used with other commands.  An example of the use of
the 'open' command is

     set fid [open "myfile" "r+"]

which means open the file 'myfile' for both reading and writing and set
the variable 'fid' to the file handle returned.

   To close a file simply use

     close FILEID

   For example,

     close $fid

will close the file that has the file handle stored in the variable
'fid'.

   To read from a file, the 'read' command is used:

     read FILEID NUMBYTES

which reads NUMBYTES bytes from the file attached to file handle FILEID,
and returns the bytes actually read.

   To read a single line from a file use 'gets':

     gets FILEID ?VARNAME?

which reads a line from the file attached to file handle FILEID but
chops off the trailing newline.  If variable VARNAME is specified, then
the string read in is stored there and the number of bytes is returned
by the command.  If the variable is not specified, then the command
returns the string only.

   To write to a file, use 'puts':

     puts ?-nonewline? ?FILEID? STRING

which outputs the string STRING.  If the file handle FILEID is present,
then the string is output to that file; otherwise, it is printed on
'stdout'.  If the switch '-nonewline' is present, then a trailing
newline is not output.

   To check if the end of a file has been reached, use 'eof':

     eof FILEID

which, given a file handle FILEID returns 1 if the end has been reached,
and 0 otherwise.

   The are a host of other commands over files and processes, which we
will not go into here.

   (For extra information on file I/O commands, refer to the Tcl manual
pages.)

   Tcl provides a way of _creating new commands_, called procedures,
that can be executed in scripts.  The arguments of a procedure can be
call-by-value or call-by-reference, and there is also a facility for
creating new user defined control structures using procedures.

   A procedure is declared using the 'proc' command:

     proc NAME ARGLIST BODY

where the name of the procedure is NAME, the arguments are contained in
ARGLIST and the body of the procedure is the script BODY.  An example of
a procedure is:

     proc namePrint { first family } {
         puts "My first name is $first"
         puts "My family name is $family"
     }

which can be called with

     namePrint Tony Blair

to produce the output:

     My first name is Tony
     My family name is Blair

   A procedure with no arguments is specified with an empty argument
list.  An example is a procedure that just prints out a string:

     proc stringThing {} {
         puts "I just print this string"
     }

   Arguments can be given defaults by pairing them with a value in a
list.  An example here is a counter procedure:

     proc counter { value { inc 1 } } {
         eval $value + $inc
     }

which can be called with two arguments like this

     set v 10
     set v [counter $v 5]

which will set variable 'v' to the value 15; or it can be called with
one argument:

     set v 10
     set v [counter $v]

in which case 'v' will have the value 11, because the default of the
argument 'inc' inside the procedure is the value 1.

   There is a special argument for handling procedures with variable
number of arguments, the 'args' argument.  An example is a procedure
that sums a list of numbers:

     proc sum { args } {
         set result 0;

         foreach n $args {
          set result [expr $result + $n ]
         }

         return $result;
     }

which can be called like this:

     sum 1 2 3 4 5

which returns the value 15.

   The restriction on using defaulted arguments is that all the
arguments that come after the defaulted ones must also be defaulted.  If
'args' are used, then it must be the last argument in the argument list.

   A procedure can return a value through the 'return' command:

     return ?OPTIONS? ?VALUE?

which terminates the procedure returning value VALUE, if specified, or
just causes the procedure to return, if no value specified.  (The
?OPTIONS? part has to do with raising exceptions, which we will will not
cover here.)

   The return result of a user defined procedure is the return result of
the last command executed by it.

   So far we have seen the arguments of a procedure are passed using the
call-by-value mechanism.  They can be passed call by reference using the
'upvar' command:

     upvar ?LEVEL? OTHERVAR1 MYVAR1 ?OTHERVAR2 MYVAR2 ...?

which makes accessible variables somewhere in a calling context with the
current context.  The optional argument LEVEL describes how many calling
levels up to look for the variable.  This is best shown with an example:

     set a 10
     set b 20

     proc add { first second } {
         upvar $first f $second s
         expr $f+$s
     }

which when called with

     add a b

will produce the result 30.  If you use call-by-value instead:

     add $a $b

then the program will fail because when executing the procedure 'add' it
will take the first argument 10 as the level argument, a bad level.
(Also variable '20' does not exist at any level.)

   New control structures can be generated using the 'uplevel' command:

     uplevel ?LEVEL? ARG ?ARG ARG ...?

which is like 'eval', but it evaluates its arguments in a context higher
up the calling stack.  How far up the stack to go is given by the
optional LEVEL argument.

     proc do { loop condition } {
         set nostop 1

         while { $nostop } {
             uplevel $loop
             if {[uplevel "expr $condition"] == 0} {
                 set nostop 0
              }
         }
     }

which when called with this

     set x 5
     do { puts $x; incr x -1 } { $x > 0 }

will print

     5
     4
     3
     2
     1

   (*Please note*: this does not quite work for all kinds of calls
because of 'break', 'continue', and 'return'.  It is possible to get
around these problem, but that is outside the scope of this tutorial.)

   A word about the _scope of variables_.  Variables used within
procedures are normally created only for the duration of that procedure
and have local scope.

   It is possible to declare a variable as having global scope, through
the 'global' command:

     global NAME1 ? NAME2 ...?

where NAME1, NAME2, ..., are the names of global variables.  Any
references to those names will be taken to denote global variables for
the duration of the procedure call.

   Global variables are those variables declared at the topmost calling
context.  It is possible to run a 'global' command at anytime in a
procedure call.  After such a command, the variable name will refer to a
global variable until the procedure exits.

   An example:

     set x 10

     proc fred { } {
         set y 20
         global x
         puts [expr $x + $y]
     }

     fred

will print the result '30' where 20 comes from the local variable 'y'
and 10 comes from the global variable 'x'.

   Without the 'global x' line, the call to 'fred' will fail with an
error because there is no variable 'x' defined locally in the procedure
for the 'expr' to evaluate over.

   In common with other scripting languages, there is a command for
_evaluating the contents of a file_ in the Tcl interpreter:

     source FILENAME

where FILENAME is the filename of the file containing the Tcl source to
be evaluated.  Control returns to the Tcl interpreter once the file has
been evaluated.


File: sicstus.info,  Node: What We Have Left Out (Tcl),  Prev: Commands,  Up: Tcl

10.45.2.4 What We Have Left Out
...............................

We have left out a number of Tcl commands as they are outside of the
scope of this tutorial.  We list some of them here to show some of what
Tcl can do.  Please refer to the Tcl manual for more information.

"http"
     implements the HTTP protocol for retrieving web pages

"namespaces"
     a modules systems for Tcl

"trace"
     commands can be attached to variables that are triggered when the
     variable changes value (amongst other things)

"processes"
     start, stop, and manage processes

"sockets"
     UNIX and Internet style socket management

"exception handling"

"3rd party extension packages"
     load extension packages into Tcl and use their facilities as native
     Tcl commands


File: sicstus.info,  Node: Tk,  Next: The Tcl/Tk Prolog Library,  Prev: Tcl,  Up: lib-tcltk

10.45.3 Tk
----------

Tk is an extension to Tcl.  It provides Tcl with commands for easily
creating and managing graphical objects, or widgets, so providing a way
to add graphical user interfaces (GUIs) to Tcl applications.

   In this section we will describe the main Tk widgets, the Tcl
commands used to manipulate them, how to give them behaviors, and
generally how to arrange them into groups to create a GUI.

* Menu:

* Widgets:: Widgets
* Types of Widget:: Types of Widget
* Widgets Hierarchies:: Widgets Hierarchies
* Widget Creation:: Widget Creation
* Geometry Managers:: Geometry Managers
* Event Handling:: Event Handling
* Miscellaneous:: Miscellaneous
* What We Have Left Out (Tk):: What We Have Left Out
* Queens Display:: Example pure Tcl/Tk program


File: sicstus.info,  Node: Widgets,  Next: Types of Widget,  Up: Tk

10.45.3.1 Widgets
.................

A widget is a "window object".  It is something that is displayed that
has at least two parts: a state and a behavior.  An example of a widget
is a button.  Its state is things like what color is it, what text is
written it in, and how big it is.  Its behavior is things like what it
does when you click on it, or what happens when the cursor is moved over
or away from it.

   In Tcl/Tk there are three parts to creating a useful widget.  The
first is creating an instance of the widget with its initial state.  The
second is giving it a behavior by defining how the widget behaves when
certain events happen -- event handling.  The third is actually
displaying the widget possibly in a group of widgets or inside another
widget -- geometry management.  In fact, after creating all the widgets
for a GUI, they are not displayed until handled by a geometry manager,
which has rules about how to calculate the size of the widgets and how
they will appear in relation to each other.


File: sicstus.info,  Node: Types of Widget,  Next: Widgets Hierarchies,  Prev: Widgets,  Up: Tk

10.45.3.2 Types of Widget
.........................

In Tcl/Tk there are currently 15 types of widget.  In alphabetical order
they are (see also 'library('tcltk/examples/widgets.tcl')'):

'button'
     a simple press button

'canvas'
     is a container for displaying "drawn" objects such as lines,
     circles, and polygons.

'checkbutton'
     a button that hold a state of either on or off

'entry'
     a text entry field

'frame'
     a widget that is a container for other widgets

'label'
     a simple label

'listbox'
     a box containing a list of options

'menu'
     a widget for creating menu bars

'menubutton'
     a button, which when pressed offers a selection of choices

'message'
     a multi-line text display widget

'radiobutton'
     a button used to form groups of mutually interacting buttons (When
     one button is pressed down, the others pop up.)

'scale'
     is like a slider on a music console.  It consists of a trough scale
     and a slider.  Moving the slider to a position on the scale sets
     the overall value of the widget to that value.

'scollbar'
     used to add scrollbars to windows or canvases.  The scrollbar has a
     slider, which when moved changes the value of the slider widget.

'text'
     a sophisticated multi-line text widget that can also display other
     widgets such as buttons

'toplevel'
     for creating new standalone toplevel windows.  (These windows are
     containers for other widgets.  They are not terminal windows.)


 [image src="images/tcltkwidgets.png" text="" ]
                       Meet The Main Tk Widgets


File: sicstus.info,  Node: Widgets Hierarchies,  Next: Widget Creation,  Prev: Types of Widget,  Up: Tk

10.45.3.3 Widgets Hierarchies
.............................

Before going further it is necessary to understand how instances of
widgets are named.  Widgets are arranged in a hierarchy.  The names of
widget instances are formed from dot separated words.  The root window
is simply '.' on its own.  So for, example, a button widget that is
displayed in the root window might have the name '.b1'.  A button that
is displayed inside a frame that is displayed inside the root window may
have the name '.frame1.b1'.  The frame would have the name '.frame1'.

   Following this notation, it is clear that widgets are both formed in
hierarchies, with the dot notation giving the path to a widget, and in
groups, all widgets with the same leading path are notionally in the
same group.

   (It is a similar to the way file systems are organized.  A file has a
path that shows where to find it in the hierarchical file system.  But
also files with the same leading path are in the same directory/folder
and so are notionally grouped together.)

   An instance of a widget is created through the a Tcl command for that
widget.  The widget command my have optional arguments set for
specifying various attributes of the widget that it will have when it is
created.  The result of a successful widget command is the name of the
new widget.

   For example, a command to create a button widget named '.mybutton'
that displays the text "I am a button" would look like this:

     button .mybutton -text "I am a button"

and this will return the name '.mybutton'.

   A widget will only be created if all the windows/widgets in the
leading path of the new widget also exist, and also that the name of the
new widget does not already exist.

   For example, the following

     button .mybutton -text "I am a button"
     button .mybutton -text "and so am I"

will fail at the second command because there is also a widget named
'.mybutton' from the first command.

   The following will also fail

     button .frame.mybutton -text "I am a button"

if there is no existing widget with the name '.frame' to be the parent
of '.mybutton'.

   All this begs the question: why are widgets named and arranged in a
hierarchy?  Is not a GUI just a bunch of widgets displayed in a window?

   This is not generally how GUIs are arranged.  For example, they often
have a menubar over the top of each window.  The menubar contains
pulldown menus.  The pulldown menus may have cascading menu items that
may cascade down several levels.  Under the menu bar is the main part of
the window that may also be split into several "frames".  A left hand
frame my have a set of buttons in it, for example.  And so on.  From
this you can see that the widgets in GUIs are naturally arranged in a
hierarchy.  To achieve this in Tcl/Tk instances of widgets are placed in
a hierarchy, which is reflected in their names.

   Now we will go through each of the widget commands in turn.  Each
widget command has many options most of which will not be described
here.  Just enough will be touched on for the reader to understand the
basic operation of each widget.  For a complete description of each
widget and its many options refer to the Tk manual.


File: sicstus.info,  Node: Widget Creation,  Next: Geometry Managers,  Prev: Widgets Hierarchies,  Up: Tk

10.45.3.4 Widget Creation
.........................

As has already been said, a widget is a window object that has state and
behavior.  In terms of Tcl/Tk a widget is created by calling a widget
creation command.  There is a specific widget creation for each type of
widget.

   The widget creation command is supplied with arguments.  The first
argument is always the name you want to give to the resulting widget;
the other arguments set the initial state of the widget.

   The immediate result of calling a widget creation command is that it
returns the name of the new widget.  A side effect is that the instance
of the widget is created and its name is defined as in the Tcl
interpreter as a procedure through which the widget state can be
accessed and manipulated.

   This needs an example.  We will use the widget creator command
'button' to make a button widget:

     button .fred -text 'Fred' -background red

which creates an instance of a button widget named '.fred' that will
display the text 'Fred' on the button and will have a red background
color.  Evaluating this command returns the string '.fred', the name of
the newly created widget.

   As a side effect, a Tcl procedure named '.fred' is created.  A call
to a widget instance has the following form:

     WIDGETNAME METHOD METHODARGS

where WIDGETNAME is the name of the widget to be manipulated, METHOD is
the action to be performed on the widget, and METHODARGS are the
arguments passed to the method that is performed on the widget.

   The two standard methods for widgets are 'configure' and 'cget'.
'configure' - is used to change the state of a widget; for example:

     .fred configure -background green -text 'Sid'

will change the background color of the widget '.fred' to green and the
text displayed to 'Sid'.

   'cget' is used to get part of the state of a widget; for example:

     .fred cget -text

will return 'Sid' if the text on the button '.fred' is 'Sid'.

   In addition to these general methods, there are special methods for
each widget type.  For example, with button widgets you have the 'flash'
and 'invoke' methods.

   For example,

     .fred invoke

can be called somewhere in the Tcl code to invoke button '.fred' as
though it had been clicked on.

     .fred flash

can be called somewhere in the Tcl code to cause the button to flash.

   We will come across some of these special method when we discuss the
widgets in detail.  For a comprehensive list of widget methods, refer to
entry for the appropriate widget creation command in the Tcl/Tk manual.

   We now discuss the widget creation command for each widget type.

   A _label_ is a simple widget for displaying a single line of text.
An example of creating an instance of a label is

     label .l -text "Hello world!"

which simply creates the label named '.l' with the text 'Hello world!'
displayed in it.  Most widgets that display text can have a variable
associated with them through the option '-textvariable'.  When the value
of the variable is changed the text changes in the associated label.
For example,

     label .l -text "Hello world!" -textvariable mytext

creates a text label called '.l' displaying the initial text 'Hello
world!' and associated text variable 'mytext'; 'mytext' will start with
the value 'Hello world!'.  However, if the following script is executed:

     set mytext "Goodbye moon!"

then the text in the label will magically change to 'Goodbye moon!'.

   A _message widget_ is similar to a label widget but for multi-line
text.  As its name suggests it is mostly used for creating popup message
information boxes.

   An example of a message widget is

     message .msg -text "Your data is incorrect.\n\n \
                   Please correct it and try again." \
         -justify center

which will create a message widget displaying the text shown, center
justified.  The width of the message box can be given through the
'-width' switch.  Any lines that exceed the width of the box are wrapped
at word boundaries.

   Calling the 'button' command creates an instance of a _button
widget_.  An example is:

     button .mybutton -text "hello" -command {puts "howdie!"}

which creates a button with name '.mybutton' that will display the text
"hello" and will execute the Tcl script 'puts "howdie!"' (that is print
'howdie!' to the terminal) when clicked on.

   _Checkbuttons_ are buttons that have a fixed state that is either on
or off.  Clicking on the button toggles the state.  To store the state,
a checkbutton is associated with a variable.  When the state of the
checkbutton changes, so does that of the variable.  An example is:

     checkbutton .on_or_off -text "I like ice cream" -variable ice

which will create a checkbutton with name '.on_or_off' displaying the
text 'I like ice cream' and associated with the variable 'ice'.  If the
checkbutton is checked, then 'ice' will have the value 1; if not
checked, then it will have the value 0.  The state of the checkbutton
can also be changed by changing the state of the variable.  For example,
executing

     set ice 0

will set the state of '.on_or_off' to not checked.

   _Radiobuttons_ are buttons that are grouped together to select one
value among many.  Each button has a value, but only one in the button
group is active at any one time.  In Tcl/Tk this is achieved by creating
a series of radiobutton that share an associated variable.  Each button
has a value.  When a radiobutton is clicked on, the variable has that
value and all the other buttons in the group are put into the off state.
Similarly, setting the value of the variable is reflected in the state
of the button group.  An example is:

     radiobutton .first -value one -text one -variable count
     radiobutton .second -value two -text two -variable count
     radiobutton .third -value three -text three -variable count

which creates three radiobuttons that are linked through the variable
'count'.  If button '.second' is active, for example, then the other two
buttons are in the inactive state and 'count' has the value 'two'.  The
following code sets the button group to make the button '.third' active
and the rest inactive regardless of the current state:

     set count three

   If the value of 'count' does not match any of the values of the
radiobuttons, then they will all be off.  For example executing the
script

     set count four

will turn all the radiobuttons off.

   An _entry widget_ allows input of a one line string.  An example of
an entry widget:

     label .l -text "Enter your name"
     entry .e -width 40 -textvariable your_name

would display a label widget named '.l' showing the string 'Enter your
name' and an entry widget named '.e' of width 40 characters.  The value
of variable 'your_name' will reflect the string in the entry widget: as
the entry widget string is updated, so is the value of the variable.
Similarly, changing the value of 'your_name' in a Tcl script will change
the string displayed in the entry field.

   A _scale widget_ is for displaying an adjustable slider.  As the
slider is moved its value, which is displayed next to the slider,
changes.  To specify a scale, it must have '-from' and '-to' attributes,
which is the range of the scale.  It can have a '-command' option, which
is set to a script to evaluate when the value of the slider changes.

   An example of a scale widget is:

     scale .s -from 0 -to 100

which creates a scale widget with name '.s' that will slide over a range
of integers from 0 to 100.

   There are several other options that scales can have.  For example it
is possible to display tick marks along the length of the scale through
the '-tickinterval' attribute, and it is possible to specify both
vertically and horizontally displayed scales through the '-orient'
attribute.

   A _listbox_ is a widget that displays a list of single line strings.
One or more of the strings may be selected through using the mouse.
Initializing and manipulating the contents of a listbox is done through
invoking methods on the instance of the listbox.  As examples, the
'insert' method is used to insert a string into a listbox, 'delete' to
delete one, and 'get' to retrieve a particular entry.  Also the
currently selected list items can be retrieved through the 'selection'
command.

   Here is an example of a listbox that is filled with entries of the
form 'entry N':

     listbox .l
     for { set i 0 } { $i<10 } { incr i } {
         .l insert end "entry $i"
     }

   A listbox may be given a height and/or width attribute, in which case
it is likely that not all of the strings in the list are visible at the
same time.  There are a number of methods for affecting the display of
such a listbox.

   The 'see' method causes the listbox display to change so that a
particular list element is in view.  For example,

     .l see 5

will make sure that the sixth list item is visible.  (List elements are
counted from element 0.)

   A _scrollbar_ widget is intended to be used with any widget that is
likely to be able to display only part of its contents at one time.
Examples are listboxes, canvases, text widgets, and frames, amongst
others.

   A scrollbar widget is displayed as a movable slider between two
arrows.  Clicking on either arrow moves the slider in the direction of
the arrow.  The slider can be moved by dragging it with the cursor.

   The scollbar and the widget it scrolls are connected through Tcl
script calls.  A scrollable widgets will have a 'scrollcommand'
attribute that is set to a Tcl script to call when the widget changes
its view.  When the view changes the command is called, and the command
is usually set to change the state of its associated scrollbar.

   Similarly, the scrollbar will have a 'command' attribute that is
another script that is called when an action is performed on the
scrollbar, like moving the slider or clicking on one of its arrows.
That action will be to update the display of the associated scrollable
widget (which redraws itself and then invokes its 'scrollcommand', which
causes the scrollbar to be redrawn).

   How this is all done is best shown through an example:

     listbox .l -yscrollcommand ".s set" -height 10
     scrollbar .s -command ".l yview"
     for { set i 0 } { $i < 50 } { incr i } {
         .l insert end "entry $i"
     }

creates a listbox named '.l' and a scrollbar named '.s'.  Fifty strings
of the form 'entry N' are inserted into the listbox.  The clever part is
the way the scrollbar and listbox are linked.  The listbox has its
'-yscrollcommand' attribute set to the script '".s set"'.  What happens
is that if the view of '.l' is changed, this script is called with 4
arguments attached: the number of entries in the listbox, the size of
the listbox window, the index of the first entry currently visible, and
the index of the last entry currently visible.  This is exactly enough
information for the scrollbar to work out how to redisplay itself.  For
example, changing the display of the above listbox could result in the
following '-yscrollcommand' script being called:

     .s set 50 10 5 15

which says that the listbox contains 50 elements, it can display 10 at
one time, the first element displayed has index 5 and the last one on
display has index 15.  This call invokes the 'set' method of the
scrollbar widget '.s', which causes it to redraw itself appropriately.

   If, instead, the user interacts with the scrollbar, then the
scrollbar will invoke its '-command' script, which in this example is
'".l yview"'.  Before invoking the script, the scrollbar widget
calculates which element should the first displayed in its associated
widget and appends its index to the call.  For example, if element with
index 20 should be the first to be displayed, then the following call
will be made:

     .l yview 20

which invokes the 'yview' method of the listbox '.l'.  This causes '.l'
to be updated (which then causes its '-yscrollcommand' to be called,
which updates the scrollbar).

   A _frame_ widget does not do anything by itself except reserve an
area of the display.  Although this does not seem to have much purpose,
it is a very important widget.  It is a container widget; that is, it is
used to group together collections of other widgets into logical groups.
For example, a row of buttons may be grouped into a frame, then as the
frame is manipulated so will the widgets displayed inside it.  A frame
widget can also be used to create large areas of color inside another
container widget (such as another frame widget or a toplevel widget).

   An example of the use of a frame widget as a container:

     canvas .c -background red
     frame .f
     button .b1 -text button1
     button .b2 -text button2
     button .b3 -text button3
     button .b4 -text button4
     button .b5 -text button5
     pack .b1 .b2 .b3 .b4 .b5 -in .f -side left
     pack .c -side top -fill both -expand 1
     pack .f -side bottom

which specifies that there are two main widgets a canvas named '.c' and
a frame named '.f'.  There are also 5 buttons, '.b1' through '.b5'.  The
buttons are displayed inside the frame.  Then the canvas is displayed at
the top of the main window and the frame is displayed at the bottom.  As
the frame is displayed at the bottom, then so will the buttons because
they are displayed inside the frame.

   (The 'pack' command causes the widgets to be handled for display by
the packer geometry manager.  The '-fill' and '-expand 1' options to
pack for '.c' tell the display manager that if the window is resized,
then the canvas is to expand to fill most of the window.  You will learn
about geometry managers later in the Geometry Managers section.)

   A _toplevel_ widget is a new toplevel window.  It is a container
widget inside which other widgets are displayed.  The root toplevel
widget has path '.' -- i.e. dot on its own.  Subsequent toplevel widgets
must have a name that is lower down the path tree just like any other
widget.

   An example of creating a toplevel widget is:

     toplevel .t

   All the widgets displayed inside '.t' must also have '.t' as the root
of their path.  For example, to create a button widget for display
inside the '.t' toplevel the following would work:

     button .t.b -text "Inside 't'"

   (Attributes, such as size and title, of toplevel widgets can be
changed through the 'wm' command, which we will not cover in this
tutorial.  The reader is referred to the Tk manual.)

   Yet another kind of container is a _menu widget_.  It contains a list
of widgets to display inside itself, as a pulldown menu.  A simple entry
in a menu widget is a 'command' widget, displayed as an option in the
menu widget, which if chosen executes a Tcl command.  Other types of
widgets allowed inside a menu widget are radiobuttons and checkboxes.  A
special kind of menu item is a 'separator' that is used to group
together menu items within a menu.  (It should be noted that the widgets
inside a menu widget are special to that menu widget and do not have an
independent existence, and so do not have their own Tk name.)

   A menu widget is built by first creating an instance of a menu widget
(the container) and then invoking the 'add' method to make entries into
the menu.  An example of a menu widget is as follows:

     menu .m
     .m add command -label "Open file" -command "open_file"
     .m add command -label "Open directory" -command "open_directory"
     .m add command -label "Save buffer" -command "save_buffer"
     .m add command -label "Save buffer as..." -command "save_buffer_as"
     .m add separator
     .m add command -label "Make new frame" -command "new_frame"
     .m add command -label "Open new display" -command "new_display"
     .m add command -label "Delete frame" -command "delete_frame"

which creates a menu widget called '.m', which contains eight menu
items, the first four of which are commands, then comes a separator
widget, then the final three command entries.  (Some of you will notice
that this menu is a small part of the 'Files' menu from the menubar of
the Emacs text editor.)

   An example of a checkbox and some radiobutton widget entries:

     .m add checkbox -label "Inverse video" -variable inv_vid
     .m add radiobutton -label "black" -variable color
     .m add radiobutton -label "blue" -variable color
     .m add radiobutton -label "red" -variable color

which gives a checkbox displaying 'Inverse video', keeping its state in
the variable 'inv_vid', and three radiobuttons linked through the
variable 'color'.

   Another menu item variant is the 'cascade' variant, which is used to
make cascadable menus, i.e. menus that have submenus.  An example of a
cascade entry is the following:

     .m add cascade -label "I cascade" -menu .m.c

which adds a cascade entry to the menu '.m' that displays the text 'I
cascade'.  If the 'I cascade' option is chosen from the '.m' menu, then
the menu '.m.c' will be displayed.

   The cascade option is also used to make menubars at the top of an
application window.  A menu bar is simply a menu each element of which
is a cascade entry, (for example).  The menubar menu is attached to the
application window through a special configuration option for toplevel
widgets, the '-menu' option.  Then a menu is defined for each of the
cascade entry in the menubar menu.

   There are a large number of other variants to menu widgets: menu
items can display bitmaps instead of text; menus can be specified as
tear-off menus; accelerator keys can be defined for menu items; and so
on.

   A _menubutton widget_ displays like a button, but when activated a
menu pops up.  The menu of the menubutton is defined through the 'menu'
command and is attached to the menubutton.  An example of a menu button:

     menubutton .mb -menu .mb.m -text "mymenu"
     menu .mb.m
     .mb.m add command -label hello
     .mb.m add command -label goodbye

which crates a menubutton widget named '.mb' with attached menu '.mb.m'
and displays the text 'mymenu'.  Menu '.mb.m' is defined as two command
options, one labeled 'hello' and the other labeled 'goodbye'.  When the
menubutton '.mb' is clicked on, the menu '.mb.m' will popup and its
options can be chosen.

   A _canvas widget_ is a container widget that is used to manage the
drawing of complex shapes; for example, squares, circles, ovals, and
polygons.  (It can also handle bitmaps, text and most of the Tk widgets
too.)  The shapes may have borders, filled in, be clicked on, moved
around, and manipulated.

   We will not cover the working of the canvas widget here.  It is
enough to know that there is a powerful widget in the Tk toolkit that
can handle all manner of graphical objects.  The interested reader is
referred to the Tk manual.

   A _text widget_ is another powerful container widget that handles
multi-line texts.  The textwidget can display texts with varying font
styles, sizes, and colors in the same text, and can also handle other Tk
widgets embedded in the text.

   The text widget is a rich and complicated widget and will not be
covered here.  The interested reader is referred to the Tk manual.

