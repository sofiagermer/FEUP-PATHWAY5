This is sicstus.info, produced by makeinfo version 6.5 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY

Generated July 7, 2021.


File: sicstus.info,  Node: CLPQR Projection,  Next: CLPQR Why Disequations,  Prev: CLPQR Numerical Precision,  Up: lib-clpqr

10.11.5 Projection and Redundancy Elimination
---------------------------------------------

Once a derivation succeeds, the Prolog system presents the bindings for
the variables in the query.  In a CLP system, the set of answer
constraints is presented in analogy.  A complication in the CLP context
are variables and associated constraints that were not mentioned in the
query.  A motivating example is the familiar 'mortgage' relation:
                                       _% library('clpqr/examples/mg')_
     mg(P,T,I,B,MP):-
       {
          T = 1,
          B + MP = P * (1 + I)
       }.
     mg(P,T,I,B,MP):-
       {
          T > 1,
          P1 = P * (1 + I) - MP,
          T1 = T - 1
       },
       mg(P1, T1, I, B, MP).
   A sample query yields:
     clp(r) ?- [library('clpqr/examples/mg')].
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
   Without projection of the answer constraints onto the query variables
we would observe the following interaction:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=12.682503013196973*_A-11.682503013196971*P},
     {Mp= -(_A)+1.01*P},
     {_B=2.01*_A-1.01*P},
     {_C=3.0301*_A-2.0301*P},
     {_D=4.060401000000001*_A-3.0604009999999997*P},
     {_E=5.101005010000001*_A-4.10100501*P},
     {_F=6.152015060100001*_A-5.152015060099999*P},
     {_G=7.213535210701001*_A-6.213535210700999*P},
     {_H=8.285670562808011*_A-7.285670562808009*P},
     {_I=9.368527268436091*_A-8.36852726843609*P},
     {_J=10.462212541120453*_A-9.46221254112045*P},
     {_K=11.566834666531657*_A-10.566834666531655*P}
   The variables _A ... _K are not part of the query, they originate
from the mortgage program proper.  Although the latter answer is
equivalent to the former in terms of linear algebra, most users would
prefer the former.

* Menu:

* CLPQR Variable Ordering:: Variable Ordering
* CLPQR Turning Answers into Terms:: Turning Answers into Terms
* CLPQR Projecting Inequalities:: Projecting Inequalities


File: sicstus.info,  Node: CLPQR Variable Ordering,  Next: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.11.5.1 Variable Ordering
...........................

In general, there are many ways to express the same linear relationship
between variables.  clp(Q,R) does not care to distinguish between them,
but the user might.  The predicate 'ordering(+SPEC)' gives you some
control over the variable ordering.  Suppose that instead of B, you want
MP to be the defined variable:
     clp(r) ?- mg(P,12,0.01,B,Mp).

     {B=1.1268250301319698*P-12.682503013196973*Mp}
   This is achieved with:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp]).

     {Mp= -0.0788487886783417*B+0.08884878867834171*P}
   One could go one step further and require P to appear before (to the
left of) B in an addition:
     clp(r) ?- mg(P,12,0.01,B,Mp), ordering([Mp,P]).

     {Mp=0.08884878867834171*P-0.0788487886783417*B}

   SPEC in 'ordering(+SPEC)' is either a list of variables with the
intended ordering, or of the form 'A<B'.  The latter form means that A
goes to the left of B.  In fact, 'ordering([A,B,C,D])' is shorthand for:
     ordering(A < B), ordering(A < C), ordering(A < D),
     ordering(B < C), ordering(B < D),
     ordering(C < D)

   The ordering specification only affects the final presentation of the
constraints.  For all other operations of clp(Q,R), the ordering is
immaterial.  Note that 'ordering/1' acts like a constraint: you can put
it anywhere in the computation, and you can submit multiple
specifications.
     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp).

     {B= -12.682503013196973*Mp+1.1268250301319698*P}

     clp(r) ?- ordering(B < Mp), mg(P,12,0.01,B,Mp), ordering(P < Mp).

     {P=0.8874492252651537*B+11.255077473484631*Mp}


File: sicstus.info,  Node: CLPQR Turning Answers into Terms,  Next: CLPQR Projecting Inequalities,  Prev: CLPQR Variable Ordering,  Up: CLPQR Projection

10.11.5.2 Turning Answers into Terms
....................................

In meta-programming applications one needs to get a grip on the results
computed by the clp(Q,R) solver.  You can use the predicate 'dump/3' for
that purpose:
     clp(r) ?- {2*A+B+C=10,C-D=E,A<10}, dump([A,B,C,D,E],[a,b,c,d,e],Constraints).

     Constraints = [e<10.0,a=10.0-c-d-2.0*e,b=c+d],
     {C=10.0-2.0*A-B},
     {E=10.0-2.0*A-B-D},
     {A<10.0}


File: sicstus.info,  Node: CLPQR Projecting Inequalities,  Prev: CLPQR Turning Answers into Terms,  Up: CLPQR Projection

10.11.5.3 Projecting Inequalities
.................................

As soon as linear inequations are involved, projection gets more
demanding complexity wise.  The current clp(Q,R) version uses a
Fourier-Motzkin algorithm for the projection of linear inequalities.
The choice of a suitable algorithm is somewhat dependent on the number
of variables to be eliminated, the total number of variables, and other
factors.  It is quite easy to produce problems of moderate size where
the elimination step takes some time.  For example, when the dimension
of the projection is 1, you might be better off computing the supremum
and the infimum of the remaining variable instead of eliminating 'n-1'
variables via implicit projection.

   In order to make answers as concise as possible, redundant
constraints are removed by the system as well.  In the following set of
inequalities, half of them are redundant.
                                 _% library('clpqr/examples/eliminat')_
     example(2, [X0,X1,X2,X3,X4]) :-
       {
            +87*X0  +52*X1  +27*X2  -54*X3  +56*X4 =<  -93,
            +33*X0  -10*X1  +61*X2  -28*X3  -29*X4 =<   63,
            -68*X0   +8*X1  +35*X2  +68*X3  +35*X4 =<  -85,
            +90*X0  +60*X1  -76*X2  -53*X3  +24*X4 =<  -68,
            -95*X0  -10*X1  +64*X2  +76*X3  -24*X4 =<   33,
            +43*X0  -22*X1  +67*X2  -68*X3  -92*X4 =<  -97,
            +39*X0   +7*X1  +62*X2  +54*X3  -26*X4 =<  -27,
            +48*X0  -13*X1   +7*X2  -61*X3  -59*X4 =<   -2,
            +49*X0  -23*X1  -31*X2  -76*X3  +27*X4 =<    3,
            -50*X0  +58*X1   -1*X2  +57*X3  +20*X4 =<    6,
            -13*X0  -63*X1  +81*X2   -3*X3  +70*X4 =<   64,
            +20*X0  +67*X1  -23*X2  -41*X3  -66*X4 =<   52,
            -81*X0  -44*X1  +19*X2  -22*X3  -73*X4 =<  -17,
            -43*X0   -9*X1  +14*X2  +27*X3  +40*X4 =<   39,
            +16*X0  +83*X1  +89*X2  +25*X3  +55*X4 =<   36,
             +2*X0  +40*X1  +65*X2  +59*X3  -32*X4 =<   13,
            -65*X0  -11*X1  +10*X2  -13*X3  +91*X4 =<   49,
            +93*X0  -73*X1  +91*X2   -1*X3  +23*X4 =<  -87
       }.
   Consequently, the answer consists of the system of nine non-redundant
inequalities only:
     clp(q) ?- [library('clpqr/examples/eliminat')].
     clp(q) ?- example(2, [X0,X1,X2,X3,X4]).

     {X0-2/17*X1-35/68*X2-X3-35/68*X4>=5/4},
     {X0-73/93*X1+91/93*X2-1/93*X3+23/93*X4=<-29/31},
     {X0-29/25*X1+1/50*X2-57/50*X3-2/5*X4>=-3/25},
     {X0+7/39*X1+62/39*X2+18/13*X3-2/3*X4=<-9/13},
     {X0+2/19*X1-64/95*X2-4/5*X3+24/95*X4>=-33/95},
     {X0+2/3*X1-38/45*X2-53/90*X3+4/15*X4=<-34/45},
     {X0-23/49*X1-31/49*X2-76/49*X3+27/49*X4=<3/49},
     {X0+44/81*X1-19/81*X2+22/81*X3+73/81*X4>=17/81},
     {X0+9/43*X1-14/43*X2-27/43*X3-40/43*X4>=-39/43}

   The projection (the shadow) of this polyhedral set into the 'X0,X1'
space can be computed via the implicit elimination of non-query
variables:
     clp(q) ?- example(2, [X0,X1|_]).

     {X0+2619277/17854273*X1>=-851123/17854273},
     {X0+6429953/16575801*X1=<-12749681/16575801},
     {X0+19130/1213083*X1>=795400/404361},
     {X0-1251619/3956679*X1>=21101146/3956679},
     {X0+601502/4257189*X1>=220850/473021}

   Projection is quite a powerful concept that leads to surprisingly
terse executable specifications of nontrivial problems like the
computation of the convex hull from a set of points in an n-dimensional
space: Given the program
                              _% library('clpqr/examples/elimination')_
     conv_hull(Points, Xs) :-
       lin_comb(Points, Lambdas, Zero, Xs),
       zero(Zero),
       polytope(Lambdas).

     polytope(Xs) :-
       positive_sum(Xs, 1).

       positive_sum([], Z) :- {Z=0}.
       positive_sum([X|Xs], SumX) :-
         { X >= 0, SumX = X+Sum },
         positive_sum(Xs, Sum).

     zero([]).
     zero([Z|Zs]) :- {Z=0}, zero(Zs).

     lin_comb([],        [],     S1, S1).
     lin_comb([Ps|Rest], [K|Ks], S1, S3) :-
       lin_comb_r(Ps, K, S1, S2),
       lin_comb(Rest, Ks, S2, S3).

       lin_comb_r([],     _, [],     []).
       lin_comb_r([P|Ps], K, [S|Ss], [Kps|Ss1]) :-
         { Kps = K*P+S },
         lin_comb_r(Ps, K, Ss, Ss1).
   we can post the following query:
     clp(q) ?- conv_hull([ [1,1], [2,0], [3,0], [1,2], [2,2] ], [X,Y]).

     {Y=<2},
     {X+1/2*Y=<3},
     {X>=1},
     {Y>=0},
     {X+Y>=2}
   This answer is easily verified graphically:
            |
          2 -    *    *
            |
            |
          1 -    *
            |
            |
          0 -----|----*----*----
                 1    2    3
   The convex hull program directly corresponds to the mathematical
definition of the convex hull.  What does the trick in operational terms
is the implicit elimination of the LAMBDAS from the program formulation.
Please note that this program does not limit the number of points or the
dimension of the space they are from.  Please note further that
quantifier elimination is a computationally expensive operation and
therefore this program is only useful as a benchmark for the projector
and not so for the intended purpose.


File: sicstus.info,  Node: CLPQR Why Disequations,  Next: CLPQR Monash Examples,  Prev: CLPQR Projection,  Up: lib-clpqr

10.11.6 Why Disequations
------------------------

A beautiful example of disequations at work is due to [Colmerauer 90].
It addresses the task of tiling a rectangle with squares of
all-different, a priori unknown sizes.  Here is a translation of the
original 'Prolog-III' program to clp(Q,R):
                                  _% library('clpqr/examples/squares')_
     filled_rectangle(A, C) :-
       { A >= 1 },
       distinct_squares(C),
       filled_zone([-1,A,1], _, C, []).

     distinct_squares([]).
     distinct_squares([B|C]) :-
       { B > 0 },
       outof(C, B),
       distinct_squares(C).

     outof([],     _).
     outof([B1|C], B) :-
       { B =\= B1 },       % *** note disequation ***
       outof(C, B).

     filled_zone([V|L], [W|L], C0, C0) :-
       { V=W,V >= 0 }.
     filled_zone([V|L], L3, [B|C], C2) :-
       { V < 0 },
       placed_square(B, L, L1),
       filled_zone(L1, L2, C, C1),
       { Vb=V+B },
       filled_zone([Vb,B|L2], L3, C1, C2).

     placed_square(B, [H,H0,H1|L], L1) :-
       { B > H, H0=0, H2=H+H1 },
       placed_square(B, [H2|L], L1).
     placed_square(B, [B,V|L], [X|L]) :-
       { X=V-B }.
     placed_square(B, [H|L], [X,Y|L]) :-
       { B < H, X= -B, Y=H-B }.
   There are no tilings with less than nine squares except the trivial
one where the rectangle equals the only square.  There are eight
solutions for nine squares.  Six further solutions are rotations of the
first two.
     clp(q) ?- [library('clpqr/examples/squares')].
     clp(q) ?- filled_rectangle(A, Squares).

     A = 1,
     Squares = [1] ? ;

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>
Depending on your hardware, the above query may take a few minutes.
Supplying the knowledge about the minimal number of squares beforehand
cuts the computation time by a factor of roughly four:
     clp(q) ?- length(Squares, 9), filled_rectangle(A, Squares).

     A = 33/32,
     Squares = [15/32,9/16,1/4,7/32,1/8,7/16,1/32,5/16,9/32] ? ;

     A = 69/61,
     Squares = [33/61,36/61,28/61,5/61,2/61,9/61,25/61,7/61,16/61] ? <RET>


File: sicstus.info,  Node: CLPQR Monash Examples,  Next: CLPQR MIP,  Prev: CLPQR Why Disequations,  Up: lib-clpqr

10.11.7 Monash Examples
-----------------------

This collection of examples has been distributed with the Monash
University Version of clp(R) [Heintze et al.  87], and its inclusion
into this distribution was kindly permitted by Roland Yap.

   Assuming you are using clp(R):
     clp(r) ?- [library('clpqr/examples/monash/rkf45')].

     clp(r) ?- go.
     Point    0.00000 :    0.75000    0.00000
     Point    0.50000 :    0.61969    0.47793
     Point    1.00000 :    0.29417    0.81233
     Point    1.50000 :   -0.10556    0.95809
     Point    2.00000 :   -0.49076    0.93977
     Point    2.50000 :   -0.81440    0.79929
     Point    3.00000 :   -1.05440    0.57522

     Iteration finished
     ------------------
      439  derivative evaluations


File: sicstus.info,  Node: CLPQR MIP,  Next: CLPQR Implementation Architecture,  Prev: CLPQR Monash Examples,  Up: lib-clpqr

10.11.8 A Mixed Integer Linear Optimization Example
---------------------------------------------------

The predicates 'bb_inf/[3,5]' implement a simple Branch and Bound search
algorithm for Mixed Integer Linear (MIP) Optimization examples.  Serious
MIP is not trivial.  The implementation 'library('clpqr/bb.pl')' is to
be understood as a starting point for more ambitious users who need
control over branching, or who want to add cutting planes, for example.

   Anyway, here is a small problem from miplib, a collection of MIP
models, housed at Rice University:
     NAME:         flugpl
     ROWS:         18
     COLUMNS:      18
     INTEGER:      11
     NONZERO:      46
     BEST SOLN:    1201500 (opt)
     LP SOLN:      1167185.73
     SOURCE:       Harvey M. Wagner
                   John W. Gregory (Cray Research)
                   E. Andrew Boyd (Rice University)
     APPLICATION:  airline model
     COMMENTS:     no integer variables are binary

                                      _% library('clpqr/examples/mip')_
     example(flugpl, Obj, Vs, Ints, []) :-
       Vs = [ Anm1,Anm2,Anm3,Anm4,Anm5,Anm6,
              Stm1,Stm2,Stm3,Stm4,Stm5,Stm6,
              UE1,UE2,UE3,UE4,UE5,UE6],
       Ints = [Stm6, Stm5, Stm4, Stm3, Stm2,
               Anm6, Anm5, Anm4, Anm3, Anm2, Anm1],

       Obj =    2700*Stm1 + 1500*Anm1 + 30*UE1
              + 2700*Stm2 + 1500*Anm2 + 30*UE2
              + 2700*Stm3 + 1500*Anm3 + 30*UE3
              + 2700*Stm4 + 1500*Anm4 + 30*UE4
              + 2700*Stm5 + 1500*Anm5 + 30*UE5
              + 2700*Stm6 + 1500*Anm6 + 30*UE6,

       allpos(Vs),
       {  Stm1 = 60, 0.9*Stm1 +1*Anm1 -1*Stm2 = 0,
          0.9*Stm2 +1*Anm2 -1*Stm3 = 0, 0.9*Stm3 +1*Anm3 -1*Stm4 = 0,
          0.9*Stm4 +1*Anm4 -1*Stm5 = 0, 0.9*Stm5 +1*Anm5 -1*Stm6 = 0,
          150*Stm1 -100*Anm1 +1*UE1 >= 8000,
          150*Stm2 -100*Anm2 +1*UE2 >= 9000,
          150*Stm3 -100*Anm3 +1*UE3 >= 8000,
          150*Stm4 -100*Anm4 +1*UE4 >= 10000,
          150*Stm5 -100*Anm5 +1*UE5 >= 9000,
          150*Stm6 -100*Anm6 +1*UE6 >= 12000,
          -20*Stm1 +1*UE1 =< 0, -20*Stm2 +1*UE2 =< 0, -20*Stm3 +1*UE3 =< 0,
          -20*Stm4 +1*UE4 =< 0, -20*Stm5 +1*UE5 =< 0, -20*Stm6 +1*UE6 =< 0,
          Anm1 =< 18, 57 =< Stm2, Stm2 =< 75, Anm2 =< 18,
          57 =< Stm3, Stm3 =< 75, Anm3 =< 18, 57 =< Stm4,
          Stm4 =< 75, Anm4 =< 18, 57 =< Stm5, Stm5 =< 75,
          Anm5 =< 18, 57 =< Stm6, Stm6 =< 75, Anm6 =< 18
        }.

       allpos([]).
       allpos([X|Xs]) :- {X >= 0}, allpos(Xs).

   We can first check whether the relaxed problem has indeed the quoted
infimum:
     clp(r) ?- example(flugpl, Obj, _, _, _), inf(Obj, Inf).

     Inf = 1167185.7255923203

   Computing the infimum under the additional constraints that 'Stm6',
'Stm5', 'Stm4', 'Stm3', 'Stm2', 'Anm6', 'Anm5', 'Anm4', 'Anm3', 'Anm2',
'Anm1' assume integer values at the infimum is computationally harder,
but the query does not change much:
     clp(r) ?- example(flugpl, Obj, _, Ints, _),
               bb_inf(Ints, Obj, Inf, Vertex, 0.001).

     Inf = 1201500.0000000005,
     Vertex = [75.0,70.0,70.0,60.0,60.0,0.0,12.0,7.0,16.0,6.0,6.0]


File: sicstus.info,  Node: CLPQR Implementation Architecture,  Prev: CLPQR MIP,  Up: lib-clpqr

10.11.9 Implementation Architecture
-----------------------------------

The system consists roughly of the following components:
   * A polynomial normal form expression simplification mechanism.
   * A solver for linear equations [Holzbaur 92a].
   * A simplex algorithm to decide linear inequalities [Holzbaur 94].

* Menu:

* CLPQR Fragments and Bits:: Fragments and Bits
* CLPQR Bugs:: Bugs


File: sicstus.info,  Node: CLPQR Fragments and Bits,  Next: CLPQR Bugs,  Up: CLPQR Implementation Architecture

10.11.9.1 Fragments and Bits
............................

_Rationals._  The internal data structure for rational numbers is
'rat(NUM,DEN)'.  DEN is always positive, i.e. the sign of the rational
number is the sign of NUM.  Further, NUM and DEN are relative prime.
Note that integer N looks like 'rat(N,1)' in this representation.  You
can control printing of terms with 'user:portray/1'.

   _Partial Evaluation, Compilation._  Once one has a working solver, it
is obvious and attractive to run the constraints in a clause definition
at read time or compile time and proceed with the answer constraints in
place of the original constraints.  This gets you constant folding and
in fact the full algebraic power of the solver applied to the avoidance
of computations at run time.  The mechanism to realize this idea is to
use 'dump/3' for the expansion of '{}/1', via the goal and term
expansion hook predicates.

   _Asserting with Constraints._  If you use the database, then the
clauses you assert might have constraints associated with their
variables.  You should use 'projecting_assert/1' instead of 'assert/1'
in order to ensure that only the relevant and projected constraints get
stored in the database.

     | ?- {A+B=<33}, projecting_assert(test(A,B)).

     {A+B=<33}

     | ?- listing(test).
     test(A, B) :-
             {A+B=<rat(33,1)}

     | ?- test(A,B).

     {A+B=<33}


File: sicstus.info,  Node: CLPQR Bugs,  Prev: CLPQR Fragments and Bits,  Up: CLPQR Implementation Architecture

10.11.9.2 Bugs
..............

   * The fuzzy comparison of floats is the source for all sorts of
     weirdness.  If a result in R surprises you, then try to run the
     program in Q before you send me a bug report.

   * The projector for floundered nonlinear relations keeps too many
     variables.  Its output is rather unreadable.

   * Disequations are not projected properly.

   * This list is probably incomplete.


File: sicstus.info,  Node: lib-codesio,  Next: lib-csv,  Prev: lib-clpqr,  Up: The Prolog Library

10.12 I/O on Lists of Character Codes--'library(codesio)'
=========================================================

This package defines I/O predicates that read from, or write to, a code
list.  There are also predicates to open a stream referring to a code
list.  The stream may be used with general Stream I/O predicates.

   Exported predicates:

'format_to_codes(+FORMAT, :ARGUMENTS, -CODES)'
'format_to_codes(+FORMAT, :ARGUMENTS, ?S0, ?S)'

     Prints ARGUMENTS into a code list using 'format/3'.  CODES is
     unified with the list, alternatively S0 and S are unified with the
     list and its end, respectively.
'write_to_codes(+TERM, -CODES)'
'write_to_codes(+TERM, ?S0, ?S)'

     A specialized 'format_to_codes/[3,4]'.  Writes TERM into a code
     list using 'write/2'.  CODES is unified with the list.
     Alternatively, S0 and S are unified with the list and its end,
     respectively.
'write_term_to_codes(+TERM, -CODES, +OPTIONS)'
'write_term_to_codes(+TERM, ?S0, ?S, +OPTIONS)'

     A specialized 'format_to_codes/[3,4]'.  Writes TERM into a code
     list using 'write_term/3' and OPTIONS.  CODES is unified with the
     list.  Alternatively, S0 and S are unified with the list and its
     end, respectively.
'read_from_codes(+CODES, -TERM)'

     Reads TERM from CODES using 'read/2'.  The CODES must, as usual, be
     terminated by a FULL STOP, i.e. a '.', possibly followed by
     LAYOUT-TEXT.
'read_term_from_codes(+CODES, -TERM, +OPTIONS)'

     Reads TERM from CODES using 'read_term/3' and OPTIONS.  The CODES
     must, as usual, be terminated by a FULL STOP, i.e. a '.', possibly
     followed by LAYOUT-TEXT.
'open_codes_stream(+CODES, -STREAM)'

     STREAM is opened as an input stream to an existing code list.  The
     stream may be read with the Stream I/O predicates and must be
     closed using 'close/1'.  The list is copied to an internal buffer
     when the stream is opened and must therefore be a ground code list
     at that point.
'with_output_to_codes(:GOAL, -CODES)'
'with_output_to_codes(:GOAL, ?S0, ?S)'
'with_output_to_codes(:GOAL, -STREAM, ?S0, ?S)'

     GOAL is called with the 'current_output' stream set to a new
     stream.  This stream writes to an internal buffer, which is, after
     the successful execution of GOAL, converted to a list of character
     codes.  CODES is unified with the list, alternatively S0 and S are
     unified with the list and its end, respectively.
     'with_output_to_codes/4' also passes the stream in the STREAM
     argument.  It can be used only by GOAL for writing.


File: sicstus.info,  Node: lib-csv,  Next: lib-comclient,  Prev: lib-codesio,  Up: The Prolog Library

10.13 I/O on Comma-Separated Values (CSV) Files and Strings--'library(csv)'
===========================================================================

This library module provides some utilities for Comma-Separated Values
(CSV) files and strings.  In this context, a file is a sequence of
_records_, and a record is a sequence of _fields_.  In a CSV file,
fields are separated by commas, and each record is terminated by <RET>.

   This module does not report any syntax errors.  In the event of
prematurely terminated input file, the current field and record will be
terminated silently.

   Then a CSV record is read, it will yield a list of fields of the
following form:

'integer(NUMBER,CODES)'
     Stands for the integer NUMBER, where 'number_codes(NUMBER,CODES)'
     holds, and CODES is the list of character codes actually read.

'float(NUMBER,CODES)'
     Stands for the float NUMBER, where 'number_codes(NUMBER,CODES)'
     holds, and CODES is the list of character codes actually read.

'string(CODES)'
     Stands for the text string (list of character codes) CODES, and
     'number_codes(NUMBER,CODES)' does not hold.

   When a CSV records is written, the CODES argument of the above terms
is used, but the following fields are also allowed:

'integer(NUMBER)'
     Stands for the integer NUMBER.

'float(NUMBER)'
     Stands for the float NUMBER.

'atom(ATOM)'
     Stands for the atom ATOM.

   Adapted to the conventions of this manual, RFC 4180 specifies the
following.  Where this module relaxes the requirements, that is
explicitly mentioned:

  1. Each record is located on a separate line, delimited by a line
     break.  For example:
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx <RET>

  2. The last record in the file may or may not have an ending line
     break.  For example:
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx

  3. There may be an optional header line appearing as the first line of
     the file with the same format as normal record lines.  This header
     will contain names corresponding to the fields in the file and
     should contain the same number of fields as the records in the rest
     of the file.  For example:
          field_name,field_name,field_name <RET>
          aaa,bbb,ccc <RET>
          zzz,yyy,xxx <RET>
     This module does not attempt to detect a header line nor treat it
     in any special way.

  4. Within the header and each record, there may be one or more fields,
     separated by commas.  Each record should contain the same number of
     fields throughout the file.  Spaces are considered part of a field
     and should not be ignored.  The last field in the record must not
     be followed by a comma, so if the record ends with a comma, the
     last field is treated as empty.  For example, the following is
     treated as four fields:
          aaa,bbb,ccc,
     This module does not require or check that each record contains the
     same number of fields.

  5. Each field may or may not be enclosed in double quotes.  If fields
     contain line breaks (<RET>), double quotes or commas, then they
     should be enclosed in double quotes, otherwise the double quotes
     may be omitted.  For example:
          "aaa","bbb","ccc" <RET>
          "aaa","b <RET>
          bb","ccc" <RET>
          zzz,yyy,xxx
     If an unenclosed field is immediately followed by a '"', (or vice
     versa), then this module treats that as a new enclosed (or
     unenclosed) field to be read and appended to the field read so far.

  6. If double quotes are used to enclose fields, then a double quote
     appearing inside a field must be escaped by preceding it with
     another double quote.  For example:
          "aaa","b""bb","ccc"

   Exported predicates:

'read_record(-RECORD)'
'read_record(+STREAM, -RECORD)'

     Reads a single record from the stream STREAM, which defaults to the
     current input stream, and unifies it with RECORD.  On end of file,
     RECORD is unified with 'end_of_file'.
'read_records(-RECORDS)'
'read_records(+STREAM, -RECORDS)'

     Reads records from the stream STREAM, which defaults to the current
     input stream, up to the end of the stream, and unifies them with
     RECORDS.
'read_record_from_codes(-RECORD, +CODES)'
'read_record_from_codes(-RECORD, +CODES, -SUFFIX)'

     Reads a record from the code list CODES.  In the arity 2 variant,
     there must be no trailing character codes after the record.  In the
     arity 3 variant, any trailing character codes are unified with
     SUFFIX, which can be used for reading subsequent records.
'write_record(+RECORD)'
'write_record(+STREAM, +RECORD)'

     Writes a single record to the stream STREAM, which defaults to the
     current output stream.
'write_records(+RECORDS)'
'write_records(+STREAM, +RECORDS)'

     Writes records to the stream STREAM, which defaults to the current
     output stream.
'write_record_to_codes(+RECORD, -CODES)'

     Writes a single record to the code list CODES, without the
     terminating <RET>.


File: sicstus.info,  Node: lib-comclient,  Next: lib-fdbg,  Prev: lib-csv,  Up: The Prolog Library

10.14 COM Client--'library(comclient)'
======================================

This library provides rudimentary access to COM automation objects.  As
an example it is possible to manipulate Microsoft Office applications
and Internet Explorer.  It is not possible, at present, to build COM
objects using this library.

   Feedback is very welcome.  Please contact SICStus support
(<sicstus-support@ri.se>) if you have suggestions for how this library
could be improved.

* Menu:

* Preliminaries::               Preliminaries
* Terminology::                 Terminology
* COM Client Predicates::       Predicate Reference
* COM Client Examples::         Examples


File: sicstus.info,  Node: Preliminaries,  Next: Terminology,  Up: lib-comclient

10.14.1 Preliminaries
---------------------

In most contexts both atoms and code lists are treated as strings.  With
the wide character support available in release 3.8 and later, is should
now be possible to pass UNICODE atoms and strings successfully to the
COM interface.


File: sicstus.info,  Node: Terminology,  Next: COM Client Predicates,  Prev: Preliminaries,  Up: lib-comclient

10.14.2 Terminology
-------------------

"ProgID"
     A human readable name for an object class, typically as an atom,
     e.g. ''Excel.Application''.

"CLSID (Class Identifier)"
     A globally unique identifier of a class, typically as an atom, e.g.
     ''{00024500-0000-0000-C000-000000000046}''.

     Where it makes sense a PROGID can be used instead of the
     corresponding CLSID.

"IID (Interface Identifier)"
     A globally unique identifier of an interface.  Currently only the
     ''IDispatch'' interface is used so you do not have to care about
     this.

"IName (Interface Name)"
     The human readable name of an interface, e.g. ''IDispatch''.

     Where it makes sense an INAME can be used instead of the
     corresponding IID.

"Object"
     A COM-object (or rather a pointer to an interface).

"ComValue"
     A value that can be passed from COM to SICStus Prolog.  Currently
     numeric types, booleans (treated as 1 for 'true', 0 for 'false'),
     strings, and COM objects.

"ComInArg"
     A value that can be passed as an input argument to COM, currently
     one of:
     atom
          Passed as a string (BSTR)
     numeric
          Passed as the corresponding number
     list
          A code list is treated as a string.
     COM object
          A compound term referring to a COM object.
     compound
          Other compound terms are presently illegal but will be used to
          extend the permitted types.

"SimpleCallSpec"
     Denotes a single method and its arguments.  As an example, to call
     the method named 'foo' with the arguments '42' and the string
     '"bar"' the SIMPLECALLSPEC would be the compound term
     'foo(42,'bar')' or, as an alternative, 'foo(42,"bar")'.

     The arguments of the compound term are treated as follows:
     "ComInArg"
          See above
     "variable"
          The argument is assumed to be output.  The variable is bound
          to the resulting value when the method returns.

     "mutable"
          The argument is assumed to be input/output.  The value of the
          mutable is passed to the method and when the method returns
          the mutable is updated with the corresponding return value.

"CallSpec"
     Either a SimpleCallSpec or a list of CallSpecs.  If it is a list
     then all but the last SimpleCallSpec are assumed to denote method
     calls that return a COM-object.  So for instance the VB statement
     'app.workbooks.add' can be expressed either as:
          comclient_invoke_method_proc(App, [workbooks, add])
     or as
          comclient_invoke_method_fun(App, workbooks, WorkBooks),
          comclient_invoke_method_proc(WorkBooks, add),
          comclient_release(WorkBooks)


File: sicstus.info,  Node: COM Client Predicates,  Next: COM Client Examples,  Prev: Terminology,  Up: lib-comclient

10.14.3 Predicate Reference
---------------------------

'comclient_garbage_collect'

     Release Objects that are no longer reachable from SICStus Prolog.
     To achieve this the predicate 'comclient_garbage_collect/0'
     performs an atom garbage collection, i.e.
     'garbage_collect_atoms/0', so it should be used sparingly.
'comclient_is_object(+OBJECT)'

     Succeeds if OBJECT "looks like" an object.  It does not check that
     the object is (still) reachable from SICStus Prolog, see
     'comclient_valid_object/1'.  Currently an object looks like
     ''$comclient_object'(STUFF)' where STUFF is some prolog term.  Do
     not rely on this representation!
'comclient_valid_object(+OBJECT)'

     Succeeds if OBJECT is an object that is still available to SICStus
     Prolog.
'comclient_equal(+OBJECT1, +OBJECT2)'

     Succeeds if OBJECT1 and OBJECT2 are the same object.  (It succeeds
     if their ''IUnknown'' interfaces are identical)
'comclient_clsid_from_progid(+PROGID, -CLSID).'

     Obtain the CLSID corresponding to a particular PROGID.  Uses the
     Win32 routine 'CLSIDFromProgID'.  You rarely need this since you
     can use the ProgID directly in most cases.
'comclient_progid_from_clsid(+CLSID, -PROGID).'

     Obtain the PROGID corresponding to a particular CLSID.  Uses the
     Win32 routine 'ProgIDFromCLSID'.  Rarely needed.  The PROGID
     returned will typically have the version suffix appended.

     Example, to determine what version of 'Excel.Application' is
     installed:
          | ?- comclient_clsid_from_progid('Excel.Application, CLSID),
               comclient_progid_from_clsid(CLSID, ProgID).
          CLSID = '{00024500-0000-0000-C000-000000000046}',
          ProgID = 'Excel.Application.8'
'comclient_iid_from_name(+INAME, -IID)'

     Look in the registry for the IID corresponding to a particular
     Interface.  Currently of little use.
          | ?- comclient_iid_from_name('IDispatch', IID).
          IID = '{00020400-0000-0000-C000-000000000046}'
'comclient_name_from_iid(+IID, -INAME)'

     Look in the registry for the name corresponding to a particular
     IID.  Currently of little use.
'comclient_create_instance(+ID, -OBJECT)'

     Create an instance of the Class identified by the CLSID or ProgID
     ID.
          comclient_create_instance('Excel.Application', App)
     Corresponds to 'CoCreateInstance'.
'comclient_get_active_object(+ID, -OBJECT)'

     Retrieves a running object of the Class identified by the CLSID or
     ProgID ID.
          comclient_get_active_object('Excel.Application', App)
     An exception is thrown if there is no suitable running object.
     Corresponds to 'GetActiveObject'.
'comclient_invoke_method_fun(+OBJECT, +CALLSPEC, -COMVALUE)'

     Call a method that returns a value.  Also use this to get the value
     of properties.
'comclient_invoke_method_proc(+OBJECT, +CALLSPEC)'

     Call a method that does not return a value.
'comclient_invoke_put(+OBJECT, +CALLSPEC, +COMINARG)'

     Set the property denoted by CALLSPEC to COMVALUE.  Example:
     'comclient_invoke_put(App, visible, 1)'
'comclient_release(+OBJECT)'

     Release the object and free the data structures used by SICStus
     Prolog to keep track of this object.  After releasing an object the
     term denoting the object can no longer be used to access the object
     (any attempt to do so will raise an exception).
          *Please note*: The same COM-object can be represented by
          different prolog terms.  A COM object is not released from
          SICStus Prolog until all such representations have been
          released, either explicitly by calling 'comclient_release/1'
          or by calling 'comclient_garbage_collect/0'.

          You cannot use 'OBJ1 == OBJ2' to determine whether two
          COM-objects are identical.  Instead use 'comclient_equal/2'.
'comclient_is_exception(+EXCEPTIONTERM)'

     Succeeds if EXCEPTIONTERM is an exception raised by the comclient
     module.
          catch(<some code>,
                Exception,
                ( comclient_is_exception(E) ->
                   handle_com_related_errors(E)
                ; otherwise -> % Pass other exceptions upwards
                   throw(E)
                ))
'comclient_exception_code(+EXCEPTIONTERM, -ERRORCODE)'

'comclient_exception_culprit(+EXCEPTIONTERM, -CULPRIT)'

'comclient_exception_description(+EXCEPTIONTERM, -DESCRIPTION)'

     Access the various parts of a comclient exception.  The ERRORCODE
     is the 'HRESULT' causing the exception.  CULPRIT is a term
     corresponding to the call that gave an exception.  DESCRIPTION, if
     available, is either a term ''EXCEPINFO'(...)' corresponding to an
     'EXCEPINFO' structure or ''ARGERR'(MethodName, ArgNumber)'.

     The 'EXCEPINFO' has six arguments corresponding to, and in the same
     order as, the arguments of the 'EXCEPINFO' struct.


File: sicstus.info,  Node: COM Client Examples,  Prev: COM Client Predicates,  Up: lib-comclient

10.14.4 Examples
----------------

The following example launches Microsoft Excel, adds a new worksheet,
fill in some fields and finally clears the worksheet and quits _Excel_
     :- use_module(library(comclient)).
     :- use_module(library(lists)).

     test :-
        test('Excel.Application').

     test(ProgID) :-
        comclient_create_instance(ProgID, App),
        %% Visuall Basic: app.visible = 1
        comclient_invoke_put(App, visible, 1),
        %% VB: app.workbooks.add
        comclient_invoke_method_proc(App, [workbooks, add]),
        %% VB: with app.activesheet
        comclient_invoke_method_fun(App, activesheet, ActiveSheet),

        Rows = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
        Cols = Rows,
        %% VB: .cells i,j . value = i+j/100
        (
          member(I, Rows),
          member(J, Cols),
          ValIJ is I+J/100,

          comclient_invoke_put(ActiveSheet, [cells(I,J),value], ValIJ),
          fail
        ; true
        ),
        (
          member(I, Rows),
          member(J, Cols),
          %% retrieve cell values
          comclient_invoke_method_fun(ActiveSheet, [cells(I,J), value],CellValue),
          format(user_error, '~nCell(~w,~w) = ~w', [I,J,CellValue]),
          fail
        ; true
        ),

        Range = 'A1:O15',
        format(user_error, '~Npress return to clear range (~w)', [Range]),
        flush_output(user_error),
        get_code(_),

        %% VB: .range A1:O15 .Clear
        comclient_invoke_method_proc(ActiveSheet, [range(Range),clear]),

        %% Avoid Excel query "do you want to save..."
        %%  VB: app.activeworkbook.saved = 1
        comclient_invoke_put(App, [activeworkbook,saved], 1),

        format(user_error, '~Npress return to quit \'~w\'', [ProgID]),
        flush_output(user_error),
        get_code(_),

        %% VB: app.quit
        comclient_invoke_method_proc(App, quit),

        comclient_release(ActiveSheet),
        comclient_release(App).



File: sicstus.info,  Node: lib-fdbg,  Next: lib-file_systems,  Prev: lib-comclient,  Up: The Prolog Library

10.15 Finite Domain Constraint Debugger--'library(fdbg)'
========================================================

* Menu:

* FDBG Introduction:: Introduction
* FDBG Concepts:: Concepts
* FDBG Basics:: Basics
* FDBG Advanced Usage:: Advanced Usage


File: sicstus.info,  Node: FDBG Introduction,  Next: FDBG Concepts,  Up: lib-fdbg

10.15.1 Introduction
--------------------

FDBG is a CLP(FD) debugger for SICStus Prolog.  Its main purpose is to
enable the CLP programmer to trace the changes of domains of variables.
See [Hanak et al.  04].

   FDBG defines the following prefix operator:

     :- op(400, fy, #).

   The presence of FDBG affects the translation and execution, but not
the semantics, of subsequently loaded arithmetic constraints.


File: sicstus.info,  Node: FDBG Concepts,  Next: FDBG Basics,  Prev: FDBG Introduction,  Up: lib-fdbg

10.15.2 Concepts
----------------

In this section, several concepts and terms are defined.  These terms
will later be heavily used in the documentation; therefore, it is
important that you understand them well.

* Menu:

* FDBG Events:: Events
* FDBG Labeling Levels:: Labeling Levels
* FDBG Visualizers:: Visualizers
* FDBG Names of Terms:: Names of Terms
* FDBG Selectors:: Selectors
* FDBG Name Auto-Generation:: Name Auto-Generation
* FDBG Legend:: Legend
* FDBG The fdbg_output Stream:: The 'fdbg_output' Stream


File: sicstus.info,  Node: FDBG Events,  Next: FDBG Labeling Levels,  Up: FDBG Concepts

10.15.2.1 Events
................

An FDBG event can (currently) belong to one of the two following major
classes:

"constraint event"
     A constraint is woken.

"labeling event"
     Three events belong to this class, namely:

        * the labeling of an FD variable is started
        * an FD variable gets constrained
        * the labeling of an FD variable fails, i.e. all elements of its
          domain have been tried and caused failure

   These events are intercepted by the FDBG core.  When any of them
occurs, the appropriate visualizer (*note FDBG Visualizers::) gets
called with a representation of the event (a Prolog term) as extra
arguments.


File: sicstus.info,  Node: FDBG Labeling Levels,  Next: FDBG Visualizers,  Prev: FDBG Events,  Up: FDBG Concepts

10.15.2.2 Labeling Levels
.........................

In this subsection we give three definitions regarding the labeling
procedure.

"labeling session"
     This term denotes the whole labeling procedure that starts with the
     call of 'labeling/2' or an equivalent predicate and finishes by
     exiting this predicate.  Normally, there is at most one labeling
     session per run.

"labeling attempt"
     One choicepoint of a labeling session.  Exactly one variable is
     associated with a labeling attempt, although this is not
     necessarily true vice versa.  For example in 'enum' mode labeling,
     a single labeling attempt tries every possible value, but in 'step'
     mode labeling, several binary choicepoints are created.

"labeling step"
     The event of somehow constraining the domain of a variable.  This
     usually means either setting the variable to a specific value or
     limiting it with a lower or an upper bound.

   As you can see there is a hierarchical relation among these
definitions: a labeling session consists of several labeling attempts,
which, in turn, might consist of several labeling steps.

   A "labeling event", on the other hand, can either be a labeling step,
or the start of a labeling attempt, or the failure of the same.  *Note
FDBG Events::.


File: sicstus.info,  Node: FDBG Visualizers,  Next: FDBG Names of Terms,  Prev: FDBG Labeling Levels,  Up: FDBG Concepts

10.15.2.3 Visualizers
.....................

A visualizer is a Prolog predicate reacting to FDBG events (*note FDBG
Events::).  It is called directly by the FDBG core when any FDBG event
occurs.  It is called "visualizer", because usually it should present
the events to the user, but in general it can do any kind of processing,
like checking invariants, etc.

   For all major event classes, a different visualizer type is used.
The set of visualizers you would like to use for a session is specified
in the option list of 'fdbg_on/1' (*note FDBG Options::), when FDBG is
switched on.

   A specific visualizer can have several arguments, some are supplied
by the FDBG core, the rest (if any) should be specified when FDBG is
switched on.  Note that the obligatory arguments will be appended to the
_end_ of the user defined argument list.

   The set of built-in visualizers installed by default (*note FDBG
Options::) is the following:

   * for constraint awakenings: 'fdbg_show'
   * for labeling events: 'fdbg_label_show'

   For details on built-in visualizers, *note FDBG Built-In
Visualizers::.


File: sicstus.info,  Node: FDBG Names of Terms,  Next: FDBG Selectors,  Prev: FDBG Visualizers,  Up: FDBG Concepts

10.15.2.4 Names of Terms
........................

FDBG provides a service to assign names to Prolog terms for later
reference.  A name is an atom and it is usually associated with a
compound term containing constraint variables, or with a single
variable.  In the former case, each variable appearing in the compound
term is also assigned a name automatically by FDBG. This auto-assigned
name is derived from the name of the term; *note FDBG Name
Auto-Generation::.

   Perhaps the most useful utilization of names is "annotation", another
service of FDBG. Here, each variable appearing in a Prolog term is
replaced with a compound term describing it (i.e. containing its name,
the variable itself, and some data regarding its domain).  During
annotation, unnamed constraint variables are also given a unique
"anonymous" name automatically, these names begin with a 'fdvar' prefix.
*Note FDBG Writing Visualizers::.

   The names will be used by the built-in visualizers when referring to
constraint variables, and they can also be used to retrieve the terms
assigned to them in user defined visualizers.  *Note FDBG Visualizers::.


File: sicstus.info,  Node: FDBG Selectors,  Next: FDBG Name Auto-Generation,  Prev: FDBG Names of Terms,  Up: FDBG Concepts

10.15.2.5 Selectors
...................

A "selector" is a Prolog term denoting a (path to a) subterm of a given
term T.  Let SUBTERM(T,S) denote the subterm of T wrt. a selector S, and
let N denote an integer.  A selector then takes one of the following
forms:

S            SUBTERM(T,S)
'[]'         T
'[...,N]'    Nth argument of the compound term SUBTERM(T,'[...]')
'[...,#N]'   Nth element of the list SUBTERM(T,'[...]')


File: sicstus.info,  Node: FDBG Name Auto-Generation,  Next: FDBG Legend,  Prev: FDBG Selectors,  Up: FDBG Concepts

10.15.2.6 Name Auto-Generation
..............................

There are two cases when a name is automatically generated.

  1. When a name is assigned to a compound term by the user, each
     variable appearing in it is assigned a so called "derived" name,
     which is created by appending a variant of the selector of the
     variable to the original name.  For example, the call:
          fdbg_assign_name(bar(A, [B, C], foobar(D, E)), foo)
     will create the following name/term entries:

     NAME        TERM/VARIABLE                    SELECTOR
     'foo'       'bar(A, [B, C], foobar(D, E))'   '[]'
     'foo_1'     'A'                              '[1]'
     'foo_2_1'   'B'                              '[2,#1]'
     'foo_2_2'   'C'                              '[2,#2]'
     'foo_3_1'   'D'                              '[3,1]'
     'foo_3_2'   'E'                              '[3,2]'

     *Note FDBG Naming Terms::.

  2. If, during the annotation of a term (*note FDBG Annotation::) an
     unnamed constraint variable is found, then it is assigned a unique
     "anonymous" name.  This name consists of the prefix 'fdvar', an
     underscore character, and an integer.  The integer is automatically
     incremented when necessary.


File: sicstus.info,  Node: FDBG Legend,  Next: FDBG The fdbg_output Stream,  Prev: FDBG Name Auto-Generation,  Up: FDBG Concepts

10.15.2.7 Legend
................

The "legend" is a list of variables and their domains, usually appearing
after a description of the current constraint.  This is necessary
because the usual visual representation of a constraint contains only
the _names_ of the variables in it (*note FDBG Annotation::), and does
not show anything about their domain.  The legend links these names to
the corresponding domains.  The legend also shows the changes of the
domains made by the constraint.  Finally, the legend may contain some
conclusions regarding the behavior of the constraint, like failure or
side effects.

   The format of the legend is somewhat customizable by defining a hook
function; *note FDBG Customizing Output::.  The default format of the
legend is the following:

     list_2 = 0..3
     list_3 = 0..3
     list_4 = 0..3
     fdvar_2 = 0..3 -> 1..3

   Here, we see four variables, with initial domains 0..3, but the
domain of the (previously unnamed) variable 'fdvar_2' is narrowed by the
constraint (not shown here) to 1..3.

   A legend is automatically printed by the built-in visualizer
'fdbg_show', but it can be easily printed from user defined visualizers
too.


File: sicstus.info,  Node: FDBG The fdbg_output Stream,  Prev: FDBG Legend,  Up: FDBG Concepts

10.15.2.8 The 'fdbg_output' Stream
..................................

The 'fdbg_output' is a stream alias created when FDBG is switched on and
removed when it is switched off.  All built-in visualizers write to this
stream, and the user defined visualizers should do the same.


File: sicstus.info,  Node: FDBG Basics,  Next: FDBG Advanced Usage,  Prev: FDBG Concepts,  Up: lib-fdbg

10.15.3 Basics
--------------

Here, we describe the set of FDBG services and commands necessary to do
a simple debugging session.  No major modification of your CLP(FD)
program is necessary to use FDBG this way.  Debugging more complicated
programs, on the other hand, might also require user written extensions
to FDBG, since the wallpaper trace produced by the built-in visualizer
'fdbg_show' could be too detailed and therefore hard to analyze.  *Note
FDBG Advanced Usage::.

* Menu:

* FDBG Options:: FDBG Options
* FDBG Naming Terms:: Naming Terms
* FDBG Built-In Visualizers:: Built-In Visualizers
* FDBG Debugger Commands:: New Debugger Commands
* FDBG Annotation:: Annotating Programs
* FDBG An Example Session:: An Example Session


File: sicstus.info,  Node: FDBG Options,  Next: FDBG Naming Terms,  Up: FDBG Basics

10.15.3.1 FDBG Options
......................

FDBG is switched on and off with the predicates:

'fdbg_on'
'fdbg_on(:OPTIONS)'
     Turns on FDBG by putting advice points on several predicates of the
     CLP(FD) module.  OPTIONS is a list of options; *note FDBG
     Options::.  The empty list is the default value.

     'fdbg_on/[0,1]' can be called safely several times consecutively;
     only the first call will have an effect.

'fdbg_off'
     Turns the debugger off by removing the previously installed advice
     points.

   'fdbg_on/1' accepts the following options:

'file(FILENAME, MODE)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the file
     called FILENAME opened in mode MODE.  MODE can either be 'write' or
     'append'.  The file specified is opened on a call to 'fdbg_on/1'
     and is closed on a call to 'fdbg_off/0'.

'socket(HOST, PORT)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the socket
     connected to HOST on port PORT.  The specified socket is created on
     a call to 'fdbg_on/1' and is closed on a call to 'fdbg_off/0'.

'stream(STREAM)'
     Tells FDBG to attach the stream alias 'fdbg_output' to the stream
     STREAM.  The specified stream remains open after calling
     'fdbg_off/0'.

     If none of the above three options is used, then the stream alias
     'fdbg_output' is attached to the current output stream.
      

'constraint_hook(GOAL)'
     Tells FDBG to extend GOAL with two (additional) arguments and call
     it on the exit port of the constraint dispatcher.

'no_constraint_hook'
     Tells FDBG not to use any constraint hook.

     If none of the above two options is used, then the default is
     'constraint_hook(fdbg:fdbg_show)'.
      

'labeling_hook(GOAL)'
     Tells FDBG to extend GOAL with three (additional) arguments and
     call it on any of the three labeling events.

'no_labeling_hook'
     Tells FDBG not to use any labeling hook.

     If none of the above two options is used, then the default is
     'labeling_hook(fdbg:fdbg_label_show)'.

   For both 'constraint_hook' and 'labeling_hook', GOAL should be a
visualizer, either built-in (*note FDBG Built-In Visualizers::) or user
defined.  More of these two options may appear in the option list, in
which case they will be called in their order of occurrence.

   *Note FDBG Writing Visualizers:: for more details on these two
options.


File: sicstus.info,  Node: FDBG Naming Terms,  Next: FDBG Built-In Visualizers,  Prev: FDBG Options,  Up: FDBG Basics

10.15.3.2 Naming Terms
......................

Naming is a procedure of associating names with terms and variables;
*note FDBG Names of Terms::.  Three predicates are provided to assign
and retrieve names, these are the following:

'fdbg_assign_name(+TERM, ?NAME)'
     Assigns the atom NAME to TERM, and a derived name to each variable
     appearing in TERM.  If NAME is a variable, then use a default
     (generated) name, and return it in NAME.  *Note FDBG Name
     Auto-Generation::.

'fdbg_current_name(?TERM, ?NAME)'
     Retrieves TERM associated with NAME, or enumerates all term-name
     pairs.

'fdbg_get_name(+TERM, -NAME)'
     Returns the name associated to TERM in NAME, if it exists.
     Otherwise, silently fails.


File: sicstus.info,  Node: FDBG Built-In Visualizers,  Next: FDBG Debugger Commands,  Prev: FDBG Naming Terms,  Up: FDBG Basics

10.15.3.3 Built-In Visualizers
..............................

The default visualizers are generic predicates to display FDBG events
(*note FDBG Events::) in a well readable form.  These visualizers
naturally do not exploit any problem specific information--to have more
"fancy" output, you have to write your own visualizers; *note FDBG
Writing Visualizers::.  To use these visualizers, pass them in the
appropriate argument to 'fdbg_on/1'; *note FDBG Options::, or call them
directly from user defined visualizers.

'fdbg_show(+CONSTRAINT, +ACTIONS)'
     This visualizer produces a trace output of all woken constraints,
     in which a line showing the constraint is followed by a legend
     (*note FDBG Legend::) of all the variables appearing in it, and
     finally an empty line to separate events from each other.  The
     usual output will look like this:

          <fdvar_1>#=0
              fdvar_1 = inf..sup -> {0}
              Constraint exited.

     Here, we can see an arithmetical constraint being woken.  It
     narrows 'fdvar_1' to a domain consisting of the singleton value 0,
     and since this is the narrowest domain possible, the constraint
     does not have anything more to do: it exits.

     Note that when you pass 'fdbg_show' as an option, you should omit
     the two arguments, like in:

          fdbg_on([..., constraint_hook(fdbg_show), ...]).

'fdbg_label_show(+EVENT, +LABELID, +VARIABLE)'
     This visualizer produces a wallpaper trace output of all labeling
     events.  It is best used together with 'fdbg_show/2'.  Each
     labeling event produces a single line of output, some of them are
     followed by an empty line, some others are always followed by
     another labeling action and therefore the empty line is omitted.
     Here is a sample output of 'fdbg_label_show/3':

          Labeling [9, <list_1>]: starting in range 0..3.
          Labeling [9, <list_1>]: step: <list_1> = 0

     What we see here is the following:

        * The prefix 'Labeling' identifies the event.
        * The number in the brackets (9) is a unique identification
          number belonging to a labeling attempt.  Only _one_ labeling
          step with this number can be in effect at a time.  This number
          in fact is the invocation number of the predicate doing the
          labeling for that variable.
        * The name in the brackets ('<list_1>') identifies the variable
          currently being labeled.  Note that several identification
          numbers might belong to the same variable, depending on the
          mode of labeling.
        * The text after the colon specifies the actual labeling event.
          This string can be:

             - "starting in range RANGE."  meaning the starting of a
               labeling attempt in range RANGE
             - "MODE: NARROWING."  meaning a labeling step in mode MODE.
               NARROWING is the actual narrowing done in the labeling
               step.  MODE is one of the following:

               'step'
                    meaning 'step' mode labeling
               'indomain_up'
                    meaning 'enum' mode labeling or a direct call to
                    'indomain/1'
               'indomain_down'
                    meaning 'enum,down' mode labeling
               'bisect'
                    meaning 'bisect' mode labeling
               'dual'
                    when the domain contains exactly two values and the
                    labeling attempt is nothing more than a selection
                    between them

             - "failed."  meaning the labeling attempt failed.

     Note that when you pass 'fdbg_label_show/3' as an option, you
     should omit the three arguments, like in

          fdbg_on([..., labeling_hook(fdbg_label_show), ...]).


File: sicstus.info,  Node: FDBG Debugger Commands,  Next: FDBG Annotation,  Prev: FDBG Built-In Visualizers,  Up: FDBG Basics

10.15.3.4 New Debugger Commands
...............................

The Prolog debugger is extended by FDBG. The '&' debugger is modified,
and two new commands are added:

'&'
'& N'
     This debugger command is extended so that the annotated form of
     domain variables is also printed when listing the variables with
     blocked goals.

'A'
'A SELECTOR'
     Annotates and prints the current goal and a legend of the variables
     appearing in it.  If a selector is specified, then the subterm
     specified by it is assumed to be an action list, and is taken into
     account when displaying the legend.  For example:

          23  2 Exit: clpfd:dispatch_global_fast(no_threat(2,_1001,1),0,0,
                      [exit,_1001 in_set[[3|3]]]) ? A [2,4]

          clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
                                     [exit,<board_2> in_set[[3|3]]])
              board_2 = 1..4 -> {3}
              Constraint exited.

'W NAME=SELECTOR'
     Assigns the atom NAME to the variable specified by the SELECTOR.
     For example:

          7      15 Call: bar(4, [_101,_102,_103]) ? W foo=[2,#2]

     This would assign the name 'foo' to '_102', being the second
     element of the second argument of the current goal.


File: sicstus.info,  Node: FDBG Annotation,  Next: FDBG An Example Session,  Prev: FDBG Debugger Commands,  Up: FDBG Basics

10.15.3.5 Annotating Programs
.............................

In order to use FDBG efficiently, you have to make some changes to your
CLP(FD) program.  Fortunately the calls you have to add are not
numerous, and when FDBG is turned off they do not decrease efficiency
significantly or modify the behavior of your program.  On the other
hand, they are necessary to make FDBG output easier to understand.

   Assign names to the more important and more frequently occurring
variables by inserting 'fdbg_assign_name/2' calls at the beginning of
your program.  It is advisable to assign names to variables in larger
batches (i.e. as lists or compound terms) with a single call.

   Use predefined labeling predicates if possible.  If you define your
own labeling predicates and you want to use them even in the debugging
session, then you should follow these guidelines:

  1. Add a call to 'clpfd:fdbg_start_labeling(+VAR)' at the beginning of
     the predicate doing a labeling attempt, and pass the currently
     labeled variable as an argument to the call.

  2. Call 'clpfd:fdbg_labeling_step(+VAR, +STEP)' before each labeling
     step.  STEP should be a compound term describing the labeling step,
     this will be

       a. printed "as is" by the built-in visualizer as the mode of the
          labeling step (*note FDBG Built-In Visualizers::)--you can use
          'portray/1' to determine how it should be printed;
       b. passed as 'step(STEP)' to the user defined labeling
          visualizers in their EVENT argument; *note FDBG Writing
          Visualizers::.

   This way FDBG can inform you about the labeling events created by
your labeling predicates exactly like it would do in the case of
internal labeling.  If you ignore these rules, then FDBG will not be
able to distinguish labeling events from other FDBG events any more.


File: sicstus.info,  Node: FDBG An Example Session,  Prev: FDBG Annotation,  Up: FDBG Basics

10.15.3.6 An Example Session
............................

The problem of magic sequences is a well known constraint problem.  A
magic sequence is a list, where the I-th item of the list is equal to
the number of occurrences of the number I in the list, starting from
zero.  For example, the following is a magic sequence:

     [1,2,1,0]

   The CLP(FD) solution can be found in
'library('clpfd/examples/magicseq')', which provides a couple of
different solutions, one of which uses the 'global_cardinality/2'
constraint.  We'll use this solution to demonstrate a simple session
with FDBG.

   First, the debugger is imported into the user module:

     | ?- use_module(library(fdbg)).
     % loading /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po...
     % module fdbg imported into user

     [...]

     % loaded /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/fdbg.po in module fdbg, 220 msec 453936 bytes

     | ?- use_module(library(clpfd)).
     [...]

   Then, the magic sequence solver is loaded:

     | ?- [library('clpfd/examples/magicseq')].
     % consulting /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl...
     %  module magic imported into user
     %  module clpfd imported into magic
     % consulted /home/matsc/sicstus3/Utils/x86-linux-glibc2.2/lib/sicstus-3.9.1/library/clpfd/examples/magicseq.pl in module magic, 30 msec 9440 bytes

   Now we turn on the debugger, telling it to save the trace in
'fdbg.log'.

     | ?- fdbg_on([file('fdbg.log',write)]).
     % The clp(fd) debugger is switched on

   To produce a well readable trace output, a name has to be assigned to
the list representing the magic sequence.  To avoid any modifications to
the source code, the name is assigned by a separate call before calling
the magic sequence finder predicate:

     | ?- length(L,4), fdbg_assign_name(L,list), magic_demo(4,L).
     L = [1,2,1,0] ? ;
     L = [2,0,2,0] ? ;

     no

     *Please note*: the call to 'length/2' is necessary; otherwise, 'L'
     would be a single variable instead of a list of four variables when
     the name is assigned.

   Finally we turn the debugger off:

     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   The output of the sample run can be found in 'fdbg.log'.  Here, we
show selected parts of the trace.  In each block, the woken constraint
appears on the first line, followed by the corresponding legend.

   In the first selected block, 'scalar_product/4' removes infeasible
domain values from 'list_4', adjusting its upper bound.  The legend
shows the domains before and after pruning.  Note also that the
constraint is rewritten to a more readable form:

     <list_2>+2*<list_3>+3*<list_4>#=<list_1>+<list_2>+<list_3>+<list_4>
         list_1 = 0..3
         list_2 = 0..3
         list_3 = 0..3
         list_4 = 0..3 -> 0..1

   The following block shows the initial labeling events, trying the
value 0 for 'list_1':

     Labeling [9, <list_1>]: starting in range 0..3.
     Labeling [9, <list_1>]: indomain_up: <list_1> = 0

   This soon leads to a dead end:

     <list_1>=0
         list_1 = 0..3 -> {0}
         Constraint exited.

     <list_2>+2*<list_3>+3*<list_4>#=<list_2>+<list_3>+<list_4>
         list_2 = 0..3
         list_3 = 0..3 -> {0}
         list_4 = 0..1 -> {0}
         Constraint exited.

     <list_2>+<list_3>+<list_4>#=4
         list_2 = 0..3
         list_3 = {0}
         list_4 = {0}
         Constraint failed.

   We backtrack on 'list_1', trying instead the value 1.  This leads to
the following propagation steps and to the first solution.  In these
propagation steps, the constraint exits, which means that it holds no
matter what value any remaining variable takes (like 'list_2' in the
second step):

     Labeling [9, <list_1>]: indomain_up: <list_1> = 1

     <list_1>=1
         list_1 = 0..3 -> {1}
         Constraint exited.

     <list_2>+2*<list_3>+3*<list_4>#=1+<list_2>+<list_3>+<list_4>
         list_2 = 0..3
         list_3 = 0..3 -> {1}
         list_4 = 0..1 -> {0}
         Constraint exited.

     1+<list_2>+<list_3>+<list_4>#=4
         list_2 = 0..3 -> {2}
         list_3 = {1}
         list_4 = {0}
         Constraint exited.

     global_cardinality([1,<list_2>,<list_3>,<list_4>],[0-1,1-<list_2>,2-<list_3>,3-<list_4>],[consistency(domain)])
         list_2 = {2}
         list_3 = {1}
         list_4 = {0}
         Constraint exited.

   Then, we backtrack again on 'list_1', which leads to the second
solution after a chain of propagation steps:

     Labeling [9, <list_1>]: indomain_up: <list_1> = 2

     [...]

     global_cardinality([2,<list_2>,<list_3>,<list_4>],[0-2,1-<list_2>,2-<list_3>,3-<list_4>],[consistency(domain)])
         list_2 = {0}
         list_3 = {2}
         list_4 = {0}
         Constraint exited.

   Then we backtrack on 'list_1' yet another time, but no more solutions
are found:

     Labeling [9, <list_1>]: indomain_up: <list_1> = 3

     [...]

     <list_2>+2*<list_3>+3*<list_4>#=3+<list_2>+<list_3>+<list_4>
         list_2 = {0}
         list_3 = {1}
         list_4 = {0}
         Constraint failed.

     Labeling [9, <list_1>]: failed.


File: sicstus.info,  Node: FDBG Advanced Usage,  Prev: FDBG Basics,  Up: lib-fdbg

10.15.4 Advanced Usage
----------------------

Sometimes the output of the built-in visualizer is inadequate.  There
might be cases when only minor changes are necessary to produce a more
readable output; in other cases, the trace output should be completely
reorganized.  FDBG provides two ways of changing the appearance of the
output by defining hook predicates.  In this section, these predicates
will be described in detail.

* Menu:

* FDBG Customizing Output:: Customizing Output
* FDBG Writing Visualizers:: Writing Visualizers
* FDBG Writing Legend Printers:: Writing Legend Printers
* FDBG Showing Selected Constraints (simple version):: Showing Selected Constraints (simple version)
* FDBG Showing Selected Constraints (advanced version):: Showing Selected Constraints (advanced version)
* FDBG Debugging Global Constraints:: Debugging Global Constraints


File: sicstus.info,  Node: FDBG Customizing Output,  Next: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.15.4.1 Customizing Output
............................

The printing of variable names is customized by defining the following
hook predicate.

'fdbg:fdvar_portray(NAME, VAR, FDSET)   hook'
     This hook predicate is called whenever an annotated constraint
     variable (*note FDBG Annotation::) is printed.  NAME is the
     assigned name of the variable VAR, whose domain _will be_ FDSET as
     soon as the narrowings of the current constraint take effect.  The
     _current_ domain is not passed to the hook, but it can be easily
     determined with a call to 'fd_set/2'.  (Although these two sets may
     be the same if the constraint did not narrow it.)

     If 'fdbg:fdvar_portray/3' is undefined or fails, then the default
     representation is printed, which is NAME between angle brackets.

   The printing of legend lines is customized by defining the following
hook predicate.

'fdbg:legend_portray(NAME, VAR, FDSET)   hook'
     This hook is called for each line of the legend by the built-in
     legend printer.  The arguments are the same as in the case of
     'fdbg:fdvar_portray/3'.  Note that a prefix of four spaces and a
     closing newline character is always printed by FDBG.

     If 'fdbg:fdvar_portray/3' is undefined or fails, then the default
     representation is printed, which is

          NAME = RANGENOW [ -> RANGEAFTER ]

     The arrow and RANGEAFTER are only printed if the constraint
     narrowed the domain of VAR.

   The following example will print a list of all possible values
instead of the range for each variable in the legend:

     :- multifile fdbg:legend_portray/3.
     fdbg:legend_portray(Name, Var, Set) :-
             fd_set(Var, Set0),
             fdset_to_list(Set0, L0),
             fdset_to_list(Set, L),
             (   L0 == L
             ->  format('~p = ~p', [Name, L])
             ;   format('~p = ~p -> ~p', [Name, L0, L])
             ).


File: sicstus.info,  Node: FDBG Writing Visualizers,  Next: FDBG Writing Legend Printers,  Prev: FDBG Customizing Output,  Up: FDBG Advanced Usage

10.15.4.2 Writing Visualizers
.............................

For more complicated problems you might want to change the output more
drastically.  In this case you have to write and use your own
visualizers, which could naturally be problem specific, not like
'fdbg_show/2' and 'fdbg_label_show/3'.  As we described earlier,
currently there are two types of visualizers:

"constraint visualizer"

          MYGLOBALVISUALIZER([+ARG1, +ARG2, ...] +CONSTRAINT, +ACTIONS)

     This visualizer is passed in the 'constraint_hook' option.  It must
     take at least two arguments, the last two of which being:

     CONSTRAINT
          the constraint that was handled by the dispatcher
     ACTIONS
          the action list returned by the dispatcher

     Other arguments can be used for any purpose, for example to select
     the verbosity level of the visualizer.  This way you do not have to
     modify your code if you would like to see less or more information.
     Note however, that the two obligatory arguments must appear at the
     _end_ of the argument list.

     When passing as an option to 'fdbg_on/1', only the optional
     arguments have to be specified; the two mandatory arguments should
     be omitted.  *Note FDBG Debugging Global Constraints:: for an
     example.

"labeling visualizer"

          MYLABELINGVISUALIZER([+ARG1, +ARG2, ...] +EVENT, +ID, +VAR)

     This visualizer is passed in the 'labeling_hook' option.  It must
     have at least three arguments, the last three of which being:

     EVENT
          a term representing the labeling event, can be one of the
          following:

          start
               labeling has just started for a variable
          fail
               labeling has just failed for a variable
          step(STEP)
               variable has been constrained in a labeling step
               described by the compound term STEP, which is either
               created by 'library(clpfd)''s labeling predicates (in
               this case, simply print it--FDBG will know how to handle
               it) or by you; *note FDBG Annotation::.

     ID
          identifies the labeling session, i.e. binds step and fail
          events to the corresponding start event
     VAR
          the variable being the subject of labeling

   The failure of a visualizer is ignored and multiple choices are cut
by FDBG. Exceptions, on the other hand, are not caught.

   FDBG provides several predicates to ease the work of the visualizer
writers.  These predicates are the following:

'fdbg_annotate(+TERM0, -TERM, -VARIABLES)'
'fdbg_annotate(+TERM0, +ACTIONS, -TERM, -VARIABLES)'
     Replaces each constraint variable in TERM0 by a compound term
     describing it and returns the result in TERM.  Also, collects these
     compound terms into the list VARIABLES.  These compound terms have
     the following form:

          fdvar(NAME, VAR, FDSET)

     NAME
          is the name of the variable (auto-generated, if necessary;
          *note FDBG Name Auto-Generation::)
     VAR
          is the variable itself
     FDSET
          is the domain of the variable _after_ narrowing with ACTIONS,
          if specified; otherwise, it is the _current_ domain of the
          variable

'fdbg_legend(+VARS)'
     Prints a legend of VARS, which is a list of 'fdvar/3' compound
     terms returned by 'fdbg_annotate/[3,4]'.

'fdbg_legend(+VARS, +ACTIONS)'
     Prints a legend of VARS followed by some conclusions regarding the
     constraint (exiting, failing, etc.)  based on ACTIONS.


File: sicstus.info,  Node: FDBG Writing Legend Printers,  Next: FDBG Showing Selected Constraints (simple version),  Prev: FDBG Writing Visualizers,  Up: FDBG Advanced Usage

10.15.4.3 Writing Legend Printers
.................................

When you write your own visualizers, you might not be satisfied with the
default format of the legend.  Therefore you might want to write your
own legend printer, replacing 'fdbg_legend/[1,2]'.  This should be quite
straightforward based on the variable list returned by
'fdbg_annotate/[3,4]'.  Processing the rest of the action list and
writing conclusions about the constraint behavior is not that easy
though.  To help your work, FDBG provides a predicate to transform the
raw action list to a more readable form:

'fdbg_transform_actions(+ACTIONS, +VARS, -TRANSFORMEDACTIONS)'
     This will do the following transformations to ACTIONS, returning
     the result in TRANSFORMEDACTIONS:

       1. remove all actions concerning variables in VARS (the list
          returned by 'fdbg_annotate/[3,4]');
       2. remove multiple 'exit' and/or 'fail' commands;
       3. remove all ground actions, translating those that will cause
          failure into 'fail(ACTION)';
       4. substitute all other narrowings with an 'fdvar/3' compound
          term per variable.

     The transformed action list may contain the following terms:

     'exit'
          the constraint exits

     'fail'
          the constraint fails due to a 'fail' action

     'fail(ACTION)'
          the constraint fails because of ACTION

     'call(GOAL)'
          ACTIONS originally contained this action.  FDBG cannot do
          anything with that but to inform the user about it.

     'fdvar(NAME, VAR, FDSET)'
          ACTIONS also narrowed some variables that did not appear in
          the VARS list, this is one of them.  The meaning of the
          arguments is the usual, described in *note FDBG Writing
          Visualizers::.  This should normally not happen.

     'ANYTHINGELSE'
          ACTIONS contained unrecognized actions too, these are copied
          unmodified.  This should not happen!


File: sicstus.info,  Node: FDBG Showing Selected Constraints (simple version),  Next: FDBG Showing Selected Constraints (advanced version),  Prev: FDBG Writing Legend Printers,  Up: FDBG Advanced Usage

10.15.4.4 Showing Selected Constraints (simple version)
.......................................................

Sometimes the programmer is not interested in every constraint, only
some selected ones.  Such a filter can be easily implemented with a
user-defined visualizer.  Suppose that you are interested in the
constraints 'all_different/[1,2]' and 'all_distinct/[1,2]' only:

     %% spec_filter(+Constraint, +Actions):  Call fdbg_show for all constraints
     %%   for which interesting_event(Constraint) succeeds.
     %%
     %%   Use this filter by giving the constraint_hook(spec_filter) option to
     %%   fdbg_on.
     spec_filter(Constraint, Actions) :-
             interesting_event(Constraint),
             fdbg_show(Constraint, Actions).

     interesting_event(all_different(_)).
     interesting_event(all_different(_,_)).
     interesting_event(all_distinct(_)).
     interesting_event(all_distinct(_,_)).

   Here is a session using the visualizer.  Note that the initialization
part ('domain/3' events), are filtered out, leaving only the
'all_distinct/[1,2]' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(spec_filter)]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     all_distinct([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>],[consistency(domain)])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_distinct([7,6,2,5,8,4,1,3,9],[consistency(domain)])
         Constraint exited.
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   Note that failure of 'spec_filter/2' does not cause any unwanted
output.


File: sicstus.info,  Node: FDBG Showing Selected Constraints (advanced version),  Next: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (simple version),  Up: FDBG Advanced Usage

10.15.4.5 Showing Selected Constraints (advanced version)
.........................................................

Suppose that you want to give the constraints that you are interested in
as an argument to the visualizer, instead of defining them in a table.
The following visualizer implements this.

     %% filter_events(+CtrSpecs, +Constraint, +Actions):  This predicate will
     %%   only show constraint events if they match an element in the list CtrSpecs,
     %%   or if CtrSpecs is wrapped in -/1, all the non-matching events will
     %%   be shown.
     %%   CtrSpecs can contain the following types of elements:
     %%     ctr_name             - matches all constraints of the given name
     %%     ctr_name/arity       - matches constraints with the given name and arity
     %%     ctr_name(...args...) - matches constraints unifyable with the given term
     %%
     %%   For the selected events fdbg_show(Constraint, Actions) is called.
     %%   This visualizer can be specified when turning fdbg on, e.g.:
     %%     fdbg_on([constraint_hook(filter_events([count/4]))]), or
     %%     fdbg_on([constraint_hook(filter_events(-[in_set]))]).
     filter_events(CtrSpecs, Constraint, Actions) :-
             filter_events(CtrSpecs, fdbg_show, Constraint, Actions).

     %% filter_events(+CtrSpecs, +Visualizer, +Constraint, +Actions):  Same as
     %%   the above predicate, but the extra argument Visualizer specifies the
     %%   predicate to be called for the selected events (in the same form as
     %%   in the constraint_hook option, i.e. without the last two arguments). E.g.
     %%     fdbg_on([constraint_hook(filter_events([count/4],my_show))]).
     filter_events(-CtrSpecs, Visualizer, Constraint, Actions) :- !,
             \+ show_constraint(CtrSpecs, Constraint),
             call(Visualizer, Constraint, Actions).
     filter_events(CtrSpecs, Visualizer, Constraint, Actions) :-
             show_constraint(CtrSpecs, Constraint),
             call(Visualizer, Constraint, Actions).

     show_constraint([C|_], Constraint) :-
             matches(C, Constraint), !.
     show_constraint([_|Cs], Constraint) :-
             show_constraint(Cs, Constraint).

     matches(Name/Arity, Constraint) :- !,
             functor(Constraint, Name, Arity).
     matches(Name, Constraint) :-
             atom(Name), !,
             functor(Constraint, Name, _).
     matches(C, Constraint) :-
             C = Constraint.

   Here is a session using the visualizer, filtering out everything but
'all_distinct/2' constraints:

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events([all_distinct/2]))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     all_distinct([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>,
                    4,<fdvar_4>,<fdvar_5>,<fdvar_6>],[consistency(domain)])
         fdvar_1 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_2 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_3 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_4 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_5 = 1..9 -> (2..3)\/(5..7)\/{9}
         fdvar_6 = 1..9 -> (2..3)\/(5..7)\/{9}

     [...]

     all_distinct([7,6,2,5,8,4,1,3,9],[consistency(domain)])
         Constraint exited.
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the next session, all constraints named 'all_distinct' are
ignored, irrespective of arity.  Also, we explicitly specified the
visualizer to be called for the events that are kept (here, we have
written the default, 'fdbg_show', so the actual behavior is not
changed).

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events(-[all_distinct],fdbg_show))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     domain([1,<fdvar_1>,<fdvar_2>,8,<fdvar_3>, ...,
             <fdvar_50>,<fdvar_51>,9],1,9)
         fdvar_1 = inf..sup -> 1..9
         fdvar_2 = inf..sup -> 1..9
         ...
         fdvar_50 = inf..sup -> 1..9
         fdvar_51 = inf..sup -> 1..9
         Constraint exited.

     [...]
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off

   In the last session, we specify a list of constraints to ignore,
using a pattern to select the appropriate constraints.  Since all
constraints in the example match one of the items in the given list, no
events are printed.

     | ?- [library('clpfd/examples/suudoku')].
     [...]
     | ?- fdbg_on([constraint_hook(filter_events(-[domain(_,1,9),all_distinct]))]).
     % The clp(fd) debugger is switched on
     % advice
     | ?- suudoku([], 1, domain).
     1 5 6 8 9 4 3 2 7
     9 2 8 7 3 1 4 5 6
     4 7 3 2 6 5 9 1 8
     3 6 2 4 1 7 8 9 5
     7 8 9 3 5 2 6 4 1
     5 1 4 9 8 6 2 7 3
     8 3 1 5 4 9 7 6 2
     6 9 7 1 2 3 5 8 4
     2 4 5 6 7 8 1 3 9
     yes
     % advice
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: FDBG Debugging Global Constraints,  Prev: FDBG Showing Selected Constraints (advanced version),  Up: FDBG Advanced Usage

10.15.4.6 Debugging Global Constraints
......................................

Missing pruning and excessive pruning are the two major classes of bugs
in the implementation of global constraints.  Since CLP(FD) is an
incomplete constraint solver, missing pruning is mainly an efficiency
concern (but _ground_ instances for which the constraint does not hold
should be rejected).  Excessive pruning, however, means that some valid
combinations of values are pruned away, leading to missing solutions.
The following exported predicate helps spotting excessive pruning in
user-defined global constraints:

'fdbg_guard(:GOAL, +CONSTRAINT, +ACTIONS)'
     A constraint visualizer that does no output, but notifies the user
     by calling GOAL if a solution is lost through domain narrowings.
     Naturally you have to inform 'fdbg_guard/3' about the solution in
     question--stating which variables should have which values.  To use
     'fdbg_guard/3', first:

       1. Set it up as a visualizer by calling:

               fdbg_on([..., constraint_hook(fdbg_guard(GOAL)), ...])

          As usual, the two other arguments will be supplied by the FDBG
          core when calling 'fdbg_guard/3'.

       2. At the beginning of your program, form a pair of lists 'XS-VS'
          where XS is the list of variables and VS is the list of values
          in question.  This pair should then be assigned the name
          'fdbg_guard' using:
               | ?- fdbg_assign_name(XS-VS, fdbg_guard).

     When these steps have been taken, 'fdbg_guard/3' will watch the
     domain changes of XS done by each constraint C.  Whenever VS is in
     the domains of XS at entry to C, but not at exit from C, GOAL is
     called with three more arguments:

     VARIABLE LIST
          a list of 'VARIABLE-VALUE' terms for which VALUE was removed
          from the domain of VARIABLE
     CONSTRAINT
          the constraint that was handled by the dispatcher
     ACTIONS
          the action list returned by the dispatcher

   We will now show an example using 'fdbg_guard/3'.  First, we will
need a few extra lines of code:

     %% print_and_trace(MissValues, Constraint, Actions):  To be used as a Goal for
     %%   fdbg_guard to call when the given solution was removed from the domains
     %%   of the variables.
     %%
     %%   MissValues is a list of Var-Value pairs, where Value is the value that
     %%   should appear in the domain of Var, but has been removed.  Constraint is
     %%   the current constraint and Actions is the list of actions returned by it.
     %%
     %%   This predicate prints MissValues in a textual form, then shows the current
     %%   (culprit) constraint (as done by fdbg_show/2), then turns on the Prolog
     %%   tracer.
     print_and_trace(MissValues, Constraint, Actions) :-
             print(fdbg_output, '\nFDBG Guard:\n'),
             display_missing_values(MissValues),
             print(fdbg_output, '\nCulprit constraint:\n\n'),
             fdbg_show(Constraint, Actions),
             trace.

     display_missing_values([]).
     display_missing_values([Var-Val|MissVals]) :-
             fdbg_annotate(Var,AVar,_),
             format(fdbg_output, '  ~d was removed from ~p~n', [Val,AVar]),
             display_missing_values(MissVals).

   Suppose that we have written the following N Queens program, using a
global constraint 'no_threat/3' with a bug in it:

     :- use_module(library(fdbg)).
     :- use_module(library(clpfd)).

     queens(L, N) :-
             length(L, N),
             domain(L, 1, N),
             constrain_all(L),
             labeling([enum], L).

     constrain_all([]).
     constrain_all([X|Xs]):-
             constrain_between(X,Xs,1),
             constrain_all(Xs).

     constrain_between(_X,[],_N).
     constrain_between(X,[Y|Ys],N) :-
             no_threat(X,Y,N),
             N1 is N+1,
             constrain_between(X,Ys,N1).

     no_threat(X,Y,I) :-
             fd_global(no_threat(X,Y,I), 0, [val(X),val(Y)]).

     :- multifile clpfd:dispatch_global/4.
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(X), !,
             remove_threat(Y, X, I, NewYSet),
             Actions = [exit, Y in_set NewYSet].
     clpfd:dispatch_global(no_threat(X,Y,I), S, S, Actions) :-
             ground(Y), !,
             remove_threat(X, Y, I, NewXSet),
             Actions = [exit, X in_set NewXSet].
     clpfd:dispatch_global(no_threat(_,_,_), S, S, []).

     remove_threat(X, V, I, Set) :-
             Vp is V+I+1,   % Bug introduced here
     %       Vp is V+I,     % Good code
             Vn is V-I,
             fd_set(X, Set0),
             list_to_fdset([Vn, V, Vp], VSet),
             fdset_subtract(Set0, VSet, Set).

     missing(L, Tuple) :-
          length(Tuple, N),
          length(L, N),
          domain(L, 1, N),
          lex_chain([[2,4,1,3],L]),
          fdbg_assign_name(L-Tuple, fdbg_guard),
          fdbg_assign_name(L, board),
          fdbg_on([constraint_hook(fdbg_guard(print_and_trace))]),
          queens(L, N).

   We will now use 'print_and_trace/3' as an argument to the
'fdbg_guard' visualizer to handle the case when a solution has been
removed by a constraint.  The bug shown above causes three invalid
solutions to be found instead of the two correct solutions '[2,4,1,3]'
and '[3,1,4,2]'.  The constraint:

     'lex_chain([[2,4,1,3],L]),'

constraints the search to solutions lexicographically greater than or
equal to the first correct solution, and FDBG is told to watch for its
disappearance.  At some point, the buggy constraint removes it, and
'fdbg_guard/3' calls the given predicate.  This prints the cause of
waking (the value that should not have been removed by the constraint),
prints the constraint itself, then switches the Prolog debugger to trace
mode.  At this point, we type 'A' (*note FDBG Debugger Commands::) to
print the annotated form of the goal containing the culprit constraint.
Finally, we type 'A [2,4]' to print the same information, but taking
into account the action list, which is the 4th argument of the 2nd
argument of the module prefixed goal.  For clarity, the labeling events
were not turned off in the session below.

   This example shows how FDBG can be used to narrow down what causes
invalid pruning.

     | ?- missing(L, [2,4,1,3]).
     % The clp(fd) debugger is switched on
     Labeling [8, <board_1>]: starting in range 2..4.
     Labeling [8, <board_1>]: indomain_up: <board_1> = 2


     FDBG Guard:
       4 was removed from <board_2>

     Culprit constraint:

     user:no_threat(2,<board_2>,1)
         board_2 = 1..4 -> {3}
         Constraint exited.

     % The debugger will first creep -- showing everything (trace)
            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511 in_set[[3|3]]],
            global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _10779,user:no_threat(2,_1511,1))) ? A

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
             [exit,<board_2> in_set[[3|3]]],global($mutable(0,0),no_threat(2,<board_2>,1),
             $mutable(11,596),<fdvar_1>,user:no_threat(2,<board_2>,1)))
         board_2 = 1..4
         fdvar_1 = inf..sup

            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511 in_set[[3|3]]],
            global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _23859,user:no_threat(2,_1511,1))) ? A [2,4]

     clpfd:dispatch_global_fast(no_threat(2,<board_2>,1),0,0,
             [exit,<board_2> in_set[[3|3]]],global($mutable(0,0),no_threat(2,<board_2>,1),
             $mutable(11,596),<fdvar_1>,user:no_threat(2,<board_2>,1)))
         board_2 = 1..4 -> {3}
         fdvar_1 = inf..sup
         Constraint exited.

            11      2 Exit:
            clpfd:dispatch_global_fast(no_threat(2,_1511,1),0,0,
            [exit,_1511
            in_set[[3|3]]],global('$mutable'(0,0),no_threat(2,_1511,1),'$mutable'(11,596),
            _23859,user:no_threat(2,_1511,1))) ? a
     % Execution aborted
     % advice,source_info
     | ?- fdbg_off.
     % The clp(fd) debugger is switched off


File: sicstus.info,  Node: lib-file_systems,  Next: lib-gauge,  Prev: lib-fdbg,  Up: The Prolog Library

10.16 Accessing Files And Directories--'library(file_systems)'
==============================================================

This module provides operations on files and directories, such as
renaming, deleting, opening, checking permissions, accessing members of.

   The following principles have been observed:

   * An absolute distinction is drawn between files and directories.
     The set of operations one can usefully perform on a directory is
     different from the set one can perform on a file: for example,
     having write permission to a directory allows the user to create
     new files in it, not to rewrite the entire directory!  If any
     routine in this package tells you that a "file" exists, you can be
     sure that it means a file and not a directory (and vice versa for
     "directory" exists).
   * The directory scanning routines do not actually open the files they
     find.  Thus finer discriminations, such as that between source and
     object code, are not made.
   * All paths are expanded as if by 'absolute_file_name/3'.
   * Every predicate acts like a genuine logical relation insofar as it
     possibly can.
   * If anything goes wrong, the predicates raise an error exception.
     Any time that a predicate fails quietly, it should mean "this
     question is meaningful, but the answer is no".
   * The directory scanning routines insist that the directory argument
     name a searchable directory.
   * On Unix-like systems, symbolic links are followed by default and
     symbolic links that can not be followed are treated as
     non-existing.  This means 'file_exists/1' will fail if passed such
     a "broken" link and that neither 'file_members_of_directory/1' nor
     'directory_members_of_directory/1' et al. will return such a link.

     On Windows, symbolic links (and other reparse points) are _not_
     followed when enumerating directory contents with
     'file_members_of_directory/1' nor
     'directory_members_of_directory/1' et al. and are not returned for
     these predicates.

     The behavior for symbolic links (and reparse points) may change on
     all platforms in the future to ensure a well defined and consistent
     behavior on all platforms.

     To see _all_ members of a directory you can use
     'absolute_file_name/3' with a 'glob('*')' option.

   The "property" routines use the same simplistic access control model
as that used by the 'absolute_file_name/3' 'access/1'-option.  *Note
mpg-ref-absolute_file_name::, for details.

   Exported predicates:

'rename_file(+OLDNAME, +NEWNAME)'

     OLDNAME must identify an existing file, which will be renamed to
     NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename within the same file system.
'rename_directory(+OLDNAME, +NEWNAME)'

     OLDNAME must identify an existing directory, which will be renamed
     to NEWNAME.  The details of just when this can be done are
     operating-system dependent.  Typically it is only possible to
     rename empty directories within the same file system.
'delete_file(+OLDNAME)'

     OLDNAME must identify an existing file, which will be deleted.
'delete_directory(+DIRECTORY)'
'delete_directory(+DIRECTORY, +OPTIONS)'

     DIRECTORY must identify an existing directory, which will be
     deleted, if empty.  OPTIONS should be a list of at most one term of
     the form:
     'if_nonempty(VALUE)'
          Defines what to do if the directory is nonempty.  One of:
          'ignore'
               The predicate simply succeeds, deleting nothing.
          'fail'
               The predicate simply fails, deleting nothing.
          'error'
               The predicate raises a permissison error.
          'delete'
               The predicate recursively deletes the directory and its
               contents.
'directory_exists(+DIRECTORY)'
'directory_exists(+DIRECTORY, +MODE)'

     is true when DIRECTORY is an existing directory that is accessible
     according to MODE.  MODE defaults to 'exist'.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [file_type(directory),access([exist|MODE]),file_errors(fail)])'.
'make_directory(+DIRECTORY)'

     DIRECTORY is expanded, as if by 'absolute_file_name/3', and the
     resulting directory is created.
'file_exists(+FILE)'
'file_exists(+FILE, +MODE)'

     is true when FILE is an existing file that is accessible according
     to MODE.  MODE defaults to 'exist'.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(fail)])'.
'file_must_exist(+FILE)'
'file_must_exist(+FILE, +MODE)'

     is like 'file_exists(FILE[, MODE])' except that if the file is
     _not_ accessible it reports an error.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [access([exist|MODE]),file_errors(error)])'.
'directory_must_exist(+FILE)'
'directory_must_exist(+FILE, +MODE)'

     is like 'file_must_exists(FILE[, MODE])', but for directories.

     This is more or less equivalent to 'absolute_file_name(FILE, _,
     [file_type(directory),access([exists|MODE]),file_errors(error)])'.
'close_all_streams'

     closes all the streams (other than the standard streams) which are
     currently open.  The time to call this is after an 'abort/0'.  Note
     that 'current_stream/3' does not notice the standard streams.
'directory_member_of_directory(?BASENAME, ?FULLNAME)'

     is true when BASENAME is the name of a subdirectory of the current
     directory (other than '.'  or '..')  and FULLNAME is its absolute
     name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'

     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a subdirectory of
     that directory (other than '.'  or '..')  and FULLNAME is its
     absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'

     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a directory of that
     directory (other than '.'  or '..')  which matches the given
     PATTERN, and FULLNAME is the absolute name of the subdirectory.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'directory_members_of_directory(-SET)'

     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the current
     directory.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY.  DIRECTORY need not be absolute; the FULLNAMES will be
     regardless.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'directory_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given Pattern.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'file_member_of_directory(?BASENAME, ?FULLNAME)'

     is true when BASENAME is the name of a file in the current
     directory and FULLNAME is its absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_member_of_directory(+DIRECTORY, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory, and FULLNAME is its absolute name.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_member_of_directory(+DIRECTORY, +PATTERN, ?BASENAME, ?FULLNAME)'
     is true when DIRECTORY is a name (not necessarily the absolute
     name) of a directory, BASENAME is the name of a file in that
     directory which matches the given PATTERN, and FULLNAME is its
     absolute name.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'file_members_of_directory(-SET)'

     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the current directory.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_members_of_directory(+DIRECTORY, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of the files in the given DIRECTORY.
     DIRECTORY need not be absolute; the FULLNAMES will be regardless.

     This uses 'absolute_file_name/3' with the 'glob/1' option.
'file_members_of_directory(+DIRECTORY, +PATTERN, -SET)'
     is true when SET is a set of BASENAME-FULLNAME pairs being the
     relative and absolute names of subdirectories of the given
     DIRECTORY, such that each BASENAME matches the given PATTERN.

     This uses 'absolute_file_name/3' with a 'glob(PATTERN)' option.
'directory_property(+DIRECTORY, ?PROPERTY)'

     is true when DIRECTORY is a name of a directory, and PROPERTY is a
     boolean property which that directory possesses, e.g.
              directory_property(., searchable).

     The current set of file and directory properties include:
     'readable'
     'writable'
     'executable'
     'searchable'

          Tries to determine whether the process has permission to read,
          write, execute (only for files) or search (only for
          directories) the file.

     'size_in_bytes'
          The size, in bytes, of the file.  Not available for
          directories.

     'create_timestamp'
     'modify_timestamp'
     'access_timestamp'

          The time of creation, last modification or last access
          expressed as a timestamp.  A "timestamp" is an integer
          expressing the time interval, in seconds, since the "Epoch".
          The "Epoch" is the time zero hours, zero minutes, zero
          seconds, on January 1, 1970 Coordinated Universal Time (UTC).

          The timestamp is what should be used when comparing
          information between files since it is independent of locale
          issues like time zone and daylight savings time etc.

     'create_localtime'
     'modify_localtime'
     'access_localtime'

          The same as the corresponding '..._timestamp' values passed
          through 'system:datime/2', i.e. expressed as local time and
          split up in the components year, month, day, hour, minute,
          seconds.

     'set_user_id'
     'set_group_id'
     'save_text'

          True if the set-uid, set-group-id, save-text bits,
          respectively, are set for the file.  Always false on Windows.

     'who_can_read'
     'who_can_write'
     'who_can_execute'
     'who_can_search'

          A list containing the subset of '[user,group,other]' for the
          process classes that can, respectively, read, write, execute
          (only for files) or search (only for directories.

     'owner_user_id'
     'owner_group_id'

          The id of the owner and group of the file.  The id is an
          integer on UNIX and an atom (expressed as a string security
          identifier) on Windows.

     'owner_user_name'
     'owner_group_group'

          The atom containing the name of the files owner and group
          respectively.  On Windows a name like ''DOMAIN\NAME'' will be
          used.

          If for some reason the name cannot be found it will fall back
          to using the same value as 'owner_user_id' and
          'owner_group_id'.

     Other properties may be added in the future.  You can backtrack
     through the available properties by calling 'file_property/3' or
     'directory_property/3' with an uninstantiated PROPERTY argument.

'directory_property(+DIRECTORY, ?PROPERTY, ?VALUE)'
     is true when DIRECTORY is a name of a directory, PROPERTY is a
     property of directories, and VALUE is DIRECTORY's PROPERTY VALUE.
     See 'directory_property/2', above, for a list of properties.
'file_property(+FILE, ?PROPERTY)'

     is true when FILE is a name of a file, and PROPERTY is a boolean
     property which that file possesses, e.g.
              file_property('foo.txt', readable).
     See 'directory_property/2', above, for a list of properties.
'file_property(+FILE, ?PROPERTY, ?VALUE)'
     is true when FILE is a name of a file, PROPERTY is a property of
     files, and VALUE is FILE's PROPERTY VALUE.  See
     'directory_property/2', above, for a list of properties.
'current_directory(-DIRECTORY)'
'current_directory(-DIRECTORY, +NEWDIRECTORY)'

     DIRECTORY is unified with the current working directory and the
     working directory is set to NEWDIRECTORY.


File: sicstus.info,  Node: lib-gauge,  Next: lib-heaps,  Prev: lib-file_systems,  Up: The Prolog Library

10.17 The Gauge Profiling Tool--'library(gauge)'
================================================

The Gauge library package is a graphical interface to the SICStus
built-in predicates 'profile_data/1' and 'profile_reset/0'.  *Note
Execution Profiling:: for more information about execution profiling.
The interface is based on Tcl/Tk (*note lib-tcltk::).

   The SICStus IDE (*note SPIDER::) can also show profiling information.
This makes the Gauge library largely obsolescent.

'view   since release 4.2'

     Creates a graphical user interface for viewing the profile data
     accumulated so far.  When the display first comes up it is blank
     except for the control panel.  A screen shot is shown below.


 [image src="images/gauge.png" text="" ]
                    Gauge graphical user interface

   The menus and buttons on the control panel are used as follows:

_Specification_
     Selects what statistics to display.  One of:

     _Calls_
          The number of times a predicate was called.

     _Instructions_
          The number of abstract instructions executed, plus two times
          the number of choice point accesses.

     _Choicepoints_
          Number of choicepoints accessed (saved or restored).

_Sort Order_
     Selects the sort order of the histogram.  One of:

     _Alphabetic_
          Sort the bars in alphabetic order.

     _Descending values_
          Sort the bars by descending values.

     _Ascending values_
          Sort the bars by ascending values.

     _Top 40_
          Show just the 40 highest values in descending order.

_Scale_
     Controls the scaling of the bars.  One of:

     _Linear_
          Display values with a linear scale.

     _Logarithmic_
          Display values with a logarithmic scale.

_Show_
     Controls whether to show bars with zero counts.  One of:

     _All_
          Show all values in the histogram.

     _No zero values_
          Show only non-zero values.

_Font_
     The font used in the histogram chart.

_Calculate_
     Calculates the values according to the current settings.  The
     values are displayed in a histogram.

_Reset_
     The execution counters of the selected predicates and clauses are
     reset.

_Print_
     A choice of printing the histogram on a Postscript printer, or to a
     file.

_Help_
     Shows a help text.

_Quit_
     Quits Gauge and closes its windows.

   By clicking on the bars of the histogram, the figures are displayed
in the _Value Info_ window.


File: sicstus.info,  Node: lib-heaps,  Next: lib-is_directives,  Prev: lib-gauge,  Up: The Prolog Library

10.18 Heap Operations--'library(heaps)'
=======================================

A heap is a labeled binary tree where the key of each node is less than
or equal to the keys of its sons.  The point of a heap is that we can
keep on adding new elements to the heap and we can keep on taking out
the minimum element.  If there are N elements total, the total time is
O(N LG N).  If you know all the elements in advance, you are better off
doing a merge-sort, but this file is for when you want to do say a
best-first search, and have no idea when you start how many elements
there will be, let alone what they are.

   A heap is represented as a triple 'heap(N,Free,Tree)' where N is the
number of elements in the tree, FREE is a list of integers which
specifies unused positions in the tree, and TREE is a tree made of:
'heap'
     terms for empty subtrees and
'heap(KEY,DATUM,LSON,RSON)'
     terms for the rest

   The nodes of the tree are notionally numbered like this:

                                     1
                      2				    3
              4               6               5               7
          8      12      10     14       9       13      11     15
       ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
   The idea is that if the maximum number of elements that have been in
the heap so far is M, and the tree currently has K elements, the tree is
some subtreee of the tree of this form having exactly M elements, and
the FREE list is a list of M-K integers saying which of the positions in
the M-element tree are currently unoccupied.  This free list is needed
to ensure that the cost of passing N elements through the heap is O(N LG
M) instead of O(N LG N).  For M say 100 and N say 10^4 this means a
factor of two.  The cost of the free list is slight.  The storage cost
of a heap in a copying Prolog is 2K+3M words.  Exported predicates:

'add_to_heap(+OLDHEAP, +KEY, +DATUM, -NEWHEAP)'
'add_to_heap/4 (heaps)'
     inserts the new KEY-DATUM pair into the heap.  The insertion is not
     stable, that is, if you insert several pairs with the same KEY it
     is not defined which of them will come out first, and it is
     possible for any of them to come out first depending on the history
     of the heap.
'delete_from_heap(+OLDHEAP, +KEY, -DATUM, -NEWHEAP)'
'delete_from_heap/4 (heaps)'
     deletes a single KEY-DATUM pair from the OLDHEAP producing a
     NEWHEAP.  This is useful if you want to e.g.  change the priority
     of Datum.
'get_from_heap(+OLDHEAP, -KEY, -DATUM, -NEWHEAP)'
'get_from_heap/4 (heaps)'
     returns the KEY-DATUM pair in OLDHEAP with the smallest KEY, and
     also a NEWHEAP which is the OLDHEAP with that pair deleted.
'heap_size(+HEAP, -SIZE)'
'heap_size/2 (heaps)'
     reports the number of elements currently in the heap.
'heap_to_list(+HEAP, -LIST)'
'heap_to_list/2 (heaps)'
     returns the current set of KEY-DATUM pairs in the HEAP as a LIST,
     sorted into ascending order of KEYS.
'list_to_heap(+LIST, -HEAP)'
'list_to_heap/2 (heaps)'
     takes a proper list of KEY-DATUM pairs (such as 'keysort/2' could
     be used to sort) and forms them into a heap.
'empty_heap(?HEAP)'
'empty_heap/1 (heaps)'
     is true when HEAP represents an empty heap.  There is only one way
     it can be true.
'is_heap(+HEAP)'
'is_heap/1 (heaps)'
     is true when HEAP is a well formed heap.  For this to be true, the
     size must be right and the tree must satisfy the heap condition.
'min_of_heap(+HEAP, -KEY, -DATUM)'
'min_of_heap/3 (heaps)'
     returns the KEY-DATUM pair at the top of the heap (which is of
     course the pair with the smallest KEY), but does not remove it from
     the heap.  It fails if the heap is empty.
'min_of_heap(+HEAP, -KEY1, -DATUM1, -KEY2, -DATUM2)'
'min_of_heap/5 (heaps)'
     returns the smallest (KEY1) and second smallest (KEY2) pairs in the
     heap, without deleting them.  It fails if the heap does not have at
     least two elements.
'portray_heap(+HEAP)'
'portray_heap/1 (heaps)'
     writes a heap to the current output stream in a pretty format so
     that you can easily see what it is.  Note that a heap written out
     this way can _not_ be read back in.  The point of this predicate is
     that you can add a clause
              portray(X) :- is_heap(X), !, portray_heap(X).


File: sicstus.info,  Node: lib-is_directives,  Next: lib-jasper,  Prev: lib-heaps,  Up: The Prolog Library

10.19 Declaring determinacy attributes--'library(is_directives)'
================================================================

This library module gives access to the information declared by 'is/2'
directives.  The 'is/2' declarations can be used for declaring arbitrary
predicate attributes, but the main application is for declaring
determinacy information, and this is what is described here.

10.19.1 Introduction
--------------------

Determinacy, i.e. whether a call to a predicate can produce more than
one solution on backtracking, is an important property for understanding
the predicate and the code that uses it.  For this reason it is
desirable to describe the behavior in the documentation that accompanies
a predicate.

   The determinacy properties of a predicate can also be used by various
tools, and for this reason it is possible to declare the determinacy of
a predicate in a way that can be automatically processed by such tools.
One example is the determinacy analyzer in the SPIDER IDE (*note
SPIDER::), which uses the declared determinacy of a called predicate to
improve the precision of the analysis of the caller in the common case
that the caller does not have any determinacy declaration of its own.

   The SICStus libraries contain determinacy declarations for most
exported predicates.  These can serve as useful examples.

   Determinacy declarations are _hints_, i.e. they are meant to convey
the _expected_ behavior.  Due to the dynamic nature of Prolog, almost
any call can fail, throw an exception, or succeed more than once for
reasons not directly related to the called predicate.  Examples where
these things can happen are timeouts ('library(timeout)') and
functionality that can cause goals to run when a variable is bound, e.g.
'freeze/2'.  For this reason, anything that uses determinacy
declarations must be prepared to handle any run-time behavior, not just
the behavior specified by the declarations.

10.19.2 Available Determinacy Annotations
-----------------------------------------

The following determinacy attributes are available:

'det'
     A call will always succeed exactly once.  I.e. the number of
     solutions is expected to be one.  This is probably the most common
     behavior.

'semidet'
     A call will fail, or succeed exactly once.  I.e. the number of
     solutions is expected to be zero or one.  This can be used for for
     describing tests, e.g.  'X>Y'.

'multi'
     A call will succeed more than once.  I.e. the number of solutions
     is expected to be one or more.  This is uncommon, but could be used
     to describe the builtin 'repeat/0'.

'nondet'
     A call may fail or succeed any number of times.  I.e. the number of
     solutions is expected to be zero or more.  This is the most general
     determinacy information and is what must be assumed unless no other
     information is available.

'failing'
     A call will fail.  I.e. the number of solutions is expected to be
     zero.  This is uncommon, but could be used to describe the builtin
     'false/0'.

'throwing'
     A call is expected to throw an exception.  This is similar to
     'failing' in that the number of solutions is expected to be zero
     but differs in situations where failure is treated specially, like
     if-then-else.  This is uncommon, but could be used to describe the
     builtin 'throw/1' and some of the error reporting predicates in
     'library(types)'.

10.19.3 Syntax of Determinacy Declarations
------------------------------------------

Determinacy is declared using directives that use 'is/2'.  Note that in
this usage, 'is/2' has nothing to do with the arithmetic predicate of
the same name.

   The format of a determinacy directive is:

     :- SPEC is ANNOTATION.

   where ANNOTATION is one of the atoms used for determinacy annotation.
The SPEC describes the predicate and can be either a predicate
specification (like those used by the 'abolish/1' predicate) or a
skeletal goal (like those used by the 'meta_predicate/1' directive).

   Example:

     % foo/2 is expected to always succeed, once, for any argument.
     :- foo/2 is det.

     foo(X, Y) :-
             Y = hello(X).

     % bar/2, when called with a non-variable first argument,
     % is expected to succeed at most once.
     :- bar(+, ?) is semidet.

     % bar/2, when called with a variable first argument,
     % is expected to succeed any number of times.
     :- bar(-, ?) is nondet.

     bar('a', lowercase).
     bar('A', uppercase).
     ...
     bar('z', lowercase).
     bar('Z', uppercase).

   The SPEC tells which predicate is being annotated and, if it is a
skeletal goal, it can restrict the declaration to only apply for the
specified instantiation of the arguments.  It can have one of the
following forms:

'MODULE:NAME/ARITY'
'NAME/ARITY'
     MODULE and NAME should be atoms, ARITY should be a non-negative
     integer.  This predicate specification denotes the predicate NAME
     with arity ARITY in module MODULE, where MODULE defaults to the
     source module.

'MODULE:NAME(ARG1, ARG2, ..., ARGN)'
'NAME(ARG1, ARG2, ..., ARGN)'

     This skeletal goal denotes the predicate NAME with arity N in the
     module MODULE, where MODULE defaults to the source module.  The
     argument positions is typically used to indicate an instantiation
     pattern.

10.19.3.1 Specifying Instantiation Patterns
...........................................

Many predicates have different determinacy depending on how their
arguments are instantiated.  This can be indicated using the skeleton
goal form of specification, with each argument of the skeleton goal
being one of the following:

'+'
     Indicates that the argument is instantiated, i.e. it is not a
     variable when the predicate is called.
'-'
     Indicates that the argument is uninstantiated, i.e. it is a
     variable when the predicate is called.
'?'
'*'
     Indicates that the argument can be anything, i.e. the declared
     determinism is not affected by the instantiation of this argument
if the argument is a compound term with one argument (like '+ hello', or
'- Bar'), only the functor is used when interpreting the argument.  This
makes it possible to use variables as descriptive names for the
arguments, e.g.

     :- parent_of(+Parent, -Child) is nondet.

   Not only variables can be used as descriptions in this way, any term
is accepted.

   When declaring determinism, the skeleton argument only specifies
whether an argument is a variable or not.  This is different from
whether the argument should be considered input or output ('var(X)' has
only an input argument, but will often be called with a variable as
input argument).


10.19.3.2 Declaring Meta Predicate Determinacy
..............................................

The declarations above is sufficient for most predicates.  However, they
do not suffice for predicates whose determinism depends on an argument
goal, like 'lists:maplist/2'.

   For such predicates, i.e. meta predicates that take a single closure
(goal) argument, it is possible to specify different determinacy for
each of the possible determinacies of the closure argument, as in the
following example:

     % The last argument of dolist/3 is a closure with two
     % suppressed arguments that will be supplied using call/3.
     :- meta_predicate dolist(*, *, 2).

     % This is the expected mode, a determinate producer. In this
     % case dolist/3 will also succeed exactly once.
     :- dolist(+, -, det) is det.

     % If the closure can fail, then dolist/2 can also fail.
     :- dolist(+, -, semidet) is semidet.

     % If the closure succeeds more than once, then so will dolist/2.
     :- dolist(+, -, multi) is multi.

     % If the closure always fails (a strange usage, indeed) then dolist/3
     % can nevertheless succeed, when the input is an empty list.
     :- dolist(+, -, failing) is semidet.

     % In general, dolist/3 will be nondeterminate if the closure is
     % nondeterminate.
     % This declaration may seem redundant, but it may not be for some tools.
     :- dolist(+, -, nondet) is nondet.

     % dolist/3 calls the argument closure, which expects two extra
     % arguments, on each pair of corresponding list elements
     dolist([], [], _G_2).           % The closure is ignored here
     dolist([X|Xs], [Y|Ys], G_2) :-
             call(G_2, X, Y),
             dolist(Xs, Ys, G_2).

     :- square/2 is det. % always expected to succeed (once)
     square(X, XX) :-
             XX is X*X.

     %  Example use:
     %  | ?- square_list([1,2,3], Squares).
     %  Squares = [1,4,9] ?
     %
     % It can be inferred that this is expected to succeed exactly once.
     square_list(Numbers, Squares) :-
             % Calls square(X,Y) on each X in Numbers and Y in Squares.
             % Since square/2 is 'det', the call do dolist/3 will
             % be considered 'det' as well.
             dolist(Numbers, Squares, square).

10.19.4 Using Determinacy Declarations
--------------------------------------

Since determinacy declarations by necessity are only _hints_, it is
often better to focus on the expected behavior rather than the exact
behavior when declaring determinism for a predicate.

   Also, only very simple instantiation patterns can be specified, so it
may be useful to pretend they indicate more than they actually do.

   As an example, consider how to declare the determinacy of the builtin
'length(List, Length)':
  1. It will succeed at most once if the second argument is instantiated
     (It will succeed once if the first argument can be unified with a
     list of the specified length, otherwise it will fail), regardless
     of the instantiation of the first argument.  This corresponds to
     the attribute 'semidet'.

  2. It will succeed exactly once if the first argument is a proper list
     and the second argument is a variable.  This corresponds to the
     attribute 'det'.

  3. It will succeed more than once if the first argument is a partial
     list (i.e. is a variable or has a variable tail).  This corresponds
     to the attribute 'multi'.

  4. Finally, it will throw an exception for some invalid inputs, but
     this is not specified with determinacy declarations ('... is
     throwing' is only meant for predicates expected to _always_ throw
     an exception).

   However, it is not possible to specify "proper list", "partial list"
and non-list as instantiation patterns.  On the other hand, it would be
unfortunate to not be able to say anything about the determinacy of
'length/2'.

   In such cases it may make sense to pretend that '+', the non-variable
argument instantiation, means "a properly/fully instantiated input",
i.e. a "proper list" in the case of 'length/2'.  Similarly, it may make
sense to pretend that '?', any instantiation, means "a partially
instantiated input", i.e. a "partial list" in the case of 'length/2'.

   So, for the builtin 'length/2' it would make sense to specify the
following determinacy declarations:
     :- length(*, +) is semidet.     % this is precise
     :- length(+, -) is det.         % pretend '+' means proper list
     :- length(?, -) is multi.       % pretend '?' means partial list
   It is up to the documentation accompanying the predicate, and any
tools that use these declarations, to handle this appropriately.

10.19.5 Accessing Determinacy Declarations at Runtime
-----------------------------------------------------

The determinacy declarations are saved when code is compiled or
consulted and can be accessed when the code has been loaded.  This could
be used by documentation generators, smart debuggers, and many other
purposes, not all of which documented.  New uses may be added without
notice, so you should ignore any recorded 'is/2' directive that you do
not understand.

   The loaded 'is/2' directives can be accessed using the following,
non-determinate, predicate:
     current_is_directive(Skel, M, Annotation, Spec, Directive, Context).

SKEL
     This is a compound term with the same name as the predicate and one
     anonymous variable in each argument position.

M
     This is the module of the predicate specification.  Typically the
     same as the source module.

ANNOTATION
     This is the second argument of the 'is/2' directive.

SPEC
     This is the first argument of the 'is/2' directive, with module
     prefixes peeled off.

DIRECTIVE
     This is the entire 'is/2' directive (without the surrounding ':-
     ...').
CONTEXT
     this is the source module.

   Consider the following code:
     :- module(example, [p1/3]).

     :- p1/3 is det.
     :- user:bar(+, +) is semidet.


   This corresponds to the following two clauses of
'current_is_directive/6':
     current_is_directive(p1(_,_,_),
                          example,
                          det,
                          p1/3,
                          (p1/3 is det),
                          example).
     current_is_directive(bar(_,_),
                          user,
                          semidet,
                          bar(+,+),
                          (user:bar(+,+) is semidet),
                          example).

   Exported predicates:

'current_is_directive(SKEL, M, ANNOTATION, SPEC, DIRECTIVE, CONTEXT).'
     Low-level access to the information recorded by 'is/2' directives.
     See the library documentation for details.

'current_is_directive(:MSKEL, ANNOTATION, SPEC).'
     Like 'current_is_directive(SKEL, M, ANNOTATION, SPEC, _, _)' where
     M and SKEL are the parts of the meta argument MSKEL.


File: sicstus.info,  Node: lib-jasper,  Next: lib-json,  Prev: lib-is_directives,  Up: The Prolog Library

10.20 Jasper Interface--'library(jasper)'
=========================================

* Menu:

* Jasper Overview:: Jasper Overview
* Getting Started:: Getting Started
* Calling Prolog from Java:: Calling Prolog from Java
* Jasper Package Class Reference:: Jasper Package Class Reference
* Java Exception Handling:: Java Exception Handling
* SPTerm and Memory:: SPTerm and Memory
* Java Threads:: Java Threads
* The Jasper Library: The Jasper Library


File: sicstus.info,  Node: Jasper Overview,  Next: Getting Started,  Up: lib-jasper

10.20.1 Jasper Overview
-----------------------

Jasper is a bi-directional interface between Java and SICStus.  The Java
side of the interface consists of a Java package ('se.sics.jasper')
containing classes representing the SICStus runtime system ('SICStus',
'SPTerm', etc).  The Prolog part is designed as a library module
('library(jasper)').

   The library module 'library(jasper)' (*note The Jasper Library::)
provides functionality for controlling the loading and unloading the JVM
(Java Virtual Machine), method call functionality ('jasper_call/4'), and
predicates for managing object references.

   Jasper can be used in two modes, depending on which system acts as
"Parent Application".  If Java is the parent application, then the
SICStus runtime kernel will be loaded into the JVM using the
'System.loadLibrary()' method (this is done indirectly when
instantiating a 'SICStus' object).  In this mode, SICStus is loaded as a
runtime system (*note Runtime Systems::).

   As of release 3.9, it is possible to use Jasper in multi threaded
mode.  This means that several Java threads can call SICStus runtime via
a server thread.  The communication between the client threads and the
server thread is hidden from the programmer, and the API is based on
Java 'Interfaces', which are implemented both by the multi thread
capable classes and the pre-3.9 classes, which are restricted to single
threaded mode.  The decision whether to run in single thread mode or in
multi threaded mode can thus be left until runtime.

   If SICStus is the parent application, then Java will be loaded as a
foreign resource using the query 'use_module(library(jasper))'.  The
Java engine is initialized using 'jasper_initialize/[1,2]'.

   * Some of the information in this chapter is a recapitulation of the
     information in *note Mixing C and Prolog::.  The intention is that
     this chapter should be possible to read fairly independently.
   * Before proceeding, please read *note Jasper Notes: (relnotes)Jasper
     Notes.  It contains important information about requirements,
     availability, installation tips, limitations, and how to access
     other (online) Jasper/Java resources.


File: sicstus.info,  Node: Getting Started,  Next: Calling Prolog from Java,  Prev: Jasper Overview,  Up: lib-jasper

10.20.2 Getting Started
-----------------------

*Note Java: (relnotes)Getting Started.  for a detailed description of
how to get started using the interface.  It addresses issues such as
finding SICStus from within Java and vice versa, setting the classpath
correctly, etc.  If you have trouble in getting started with Jasper,
then read that chapter before contacting SICStus Support.


File: sicstus.info,  Node: Calling Prolog from Java,  Next: Jasper Package Class Reference,  Prev: Getting Started,  Up: lib-jasper

10.20.3 Calling Prolog from Java
--------------------------------

Calling Prolog from Java is done by using the Java package
'se.sics.jasper'.  This package contains a set of Java classes, which
can be used to create and manipulate terms, ask queries and request one
or more solutions.  The functionality provided by this set of classes is
basically the same as the functionality provided by the C-Prolog
interface (*note Mixing C and Prolog::).

   It is possible to debug the Prolog code using the Prolog debugger,
either from the command line or from the SICStus Prolog IDE (SPIDER),
see *note Examples of Debugging Runtime Systems::.

   The usage is easiest described by some examples.

* Menu:

* Single Threaded Example:: Single Threaded Example
* Multi Threaded Example:: Multi Threaded Example
* Another Multi Threaded Example (Prolog Top Level):: Another Multi Threaded Example (Prolog Top Level)


File: sicstus.info,  Node: Single Threaded Example,  Next: Multi Threaded Example,  Up: Calling Prolog from Java

10.20.3.1 Single Threaded Example
.................................

The following is a Java version of the 'train' example.  *Note Train
Example:: for information about how the 'train.sav' file is created.

   This code demonstrates the use of Jasper in single threaded mode.  In
this mode only one thread can access the SICStus runtime via a 'SICStus'
object.

                                                       _// Simple.java_
     import se.sics.jasper.SICStus;
     import se.sics.jasper.Query;
     import java.util.HashMap;

     public class Simple
     {
         public static void main(String argv[]) {

             SICStus sp;
             Query query;
             HashMap WayMap = new HashMap();

             try {
                 sp = new SICStus(argv,null);

     	    sp.restore("train.sav");

                 query = sp.openPrologQuery("connected('O"rebro', 'Stockholm',
                                            Way, Way).",
                                      WayMap);

                 try {
                     while (query.nextSolution()) {
                         System.out.println(WayMap);
                     }
                 } finally {
                     query.close();
                 }
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }
     }

   It is assumed that the reader has read the section on *note Getting
Started::, which describes how to get the basics up and running.

   This is how the example works:

  1. Before any predicates can be called, the SICStus runtime system
     must be initialized.  This is done by instantiating the 'SICStus'
     class.  Each SICStus object correspond to one independent copy of
     the SICStus runtime system (a rather heavy-weight entity).

     In this example, we have specified 'null' as the second argument to
     'SICStus'.  This instructs SICStus to search for 'sprt.sav' using
     its own internal methods.

  2. Queries are made through method 'query'.  The arguments to this
     method are a string specifying a Prolog goal, and a 'Map', which
     will contain a mapping of variable names to bindings.  This method
     is for finding a single solution.  Note that the string is read by
     the Prolog reader, so it must conform to the syntax rules for
     Prolog, including the terminating period.  There are two more
     methods for making queries: 'queryCutFail', for side effects only,
     and 'openQuery' to produce several solutions through backtracking.

  3. The next step is to load the Prolog code.  This is done by the
     method 'restore'.  Corresponds to 'SP_restore()' in the
     C-interface.  *Note Loading Prolog Code::.  Note that this method
     must be called before any other SICStus method is called.  See the
     HTML Jasper documentation for details.

  4. The 'openQuery' method returns a reference to a query, an object
     implementing the 'Query' interface.  To obtain solutions, the
     method 'nextSolution' is called with no arguments.  'nextSolution'
     returns 'true' as long as there are more solutions, and the example
     above will print the value of the Map 'WayMap' until there are no
     more solutions.  Note that the query must be closed, even if
     'nextSolution' has indicated that there are no more solutions.


File: sicstus.info,  Node: Multi Threaded Example,  Next: Another Multi Threaded Example (Prolog Top Level),  Prev: Single Threaded Example,  Up: Calling Prolog from Java

10.20.3.2 Multi Threaded Example
................................

Following is a Java version of the 'train' example.

   This is a multi threaded version of the 'train' example.  In this
mode several threads can access the SICStus runtime via a 'Prolog
interface'.  The static method 'Jasper.newProlog()' returns an object
that implements a 'Prolog interface'.  A thread can make queries by
calling the query-methods of the Prolog object.  The calls will be sent
to a separate server thread that does the actual call to SICStus
runtime.

                                                  _// MultiSimple.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import java.util.HashMap;

     public class MultiSimple
     {
         class Client extends Thread
         {
             Prolog jp;
             String qs;

             Client(Prolog p,String queryString)
             {
                 jp = p;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         {
             try {
                 Prolog jp = Jasper.newProlog(argv,null,"train.sav");

                 Client c1 =
                     new Client(jp,"connected('O"rebro', 'Hallsberg',
                                Way1, Way1).");
                 c1.start();
                 // The prolog variable names are different from above
                 // so we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp,"connected('Stockholm', 'Hallsberg',
                                Way2, Way2).");
                 c2.start();
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

         public static void main(String argv[])
         {
             new MultiSimple(argv);
         }
     }

  1. The 'Prolog' object 'jp' is the interface to SICStus.  It
     implements the methods of 'interface Prolog', making it possible to
     write quite similar code for single threaded and multi threaded
     usage of Jasper.  The static method 'Jasper.newProlog()' returns
     such an object.

  2. In this example, the Prolog code is loaded by the server thread
     just after creating the SICStus object (which is invisible to the
     user).  The third argument to the method 'Jasper.newProlog' is the
     .sav file to restore.  Two threads are then started, which will
     make different queries with the 'connected' predicate.

  3. 'openPrologQuery' is not recommended in multi threaded mode, but if
     you must use it from more than one Java thread, then you should
     enclose the call to 'openPrologQuery' and the closing of the query
     in a single synchronized block, synchronizing on the Prolog object.
     *Note SPTerm and Memory:: for details on one of the reasons why
     this is necessary.


File: sicstus.info,  Node: Another Multi Threaded Example (Prolog Top Level),  Prev: Multi Threaded Example,  Up: Calling Prolog from Java

10.20.3.3 Another Multi Threaded Example (Prolog Top Level)
...........................................................

This is another multi threaded version of the 'train' example (*note
Train Example::).

   In this example, Prolog is the top level and Java is invoked via
'library(jasper)'.

                                                 _// MultiSimple2.java_
     import se.sics.jasper.Jasper;
     import se.sics.jasper.Query;
     import se.sics.jasper.Prolog;
     import se.sics.jasper.SICStus;
     import java.util.ArrayList;
     import java.util.HashMap;
     import java.util.ListIterator;

     public class MultiSimple2
     {
         class Client extends Thread
         {
             Prolog jp;
             SICStus sp;
             String qs;

             Client(Prolog p, SICStus s, String queryString)
             {
                 jp = p;
                 sp = s;
                 qs = queryString;
             }
             public void run()
             {
                 HashMap WayMap = new HashMap();
                 try {
                     synchronized(jp) {
                         Query query = jp.openPrologQuery(qs, WayMap);
                         try {
                             while (query.nextSolution()) {
                                 System.out.println(WayMap);
                             }
                         } finally {
                             query.close();
                         }
                     }
                 } catch ( Exception e ) {
                     e.printStackTrace();
                 }
             }
         }
         class Watcher extends Thread
         {
             SICStus mySp;
             ArrayList threadList = new ArrayList(2);

             public boolean add(Client cl)
             {
                 return threadList.add((Object)cl);
             }
             boolean at_least_one_is_alive(ArrayList tl)
             {
                 ListIterator li = tl.listIterator();
                 boolean f = false;
                 while (li.hasNext()) {
                     boolean alive = ((Client)(li.next())).isAlive();
                     f = f || alive;
                 }
                 return f;
             }
             public void run()
             {
                 while (at_least_one_is_alive(threadList)) {
                     try {
                         this.sleep(1000);
                     } catch (InterruptedException ie) {
                         System.err.println("Watcher interrupted.");
                     }
                 }
                 mySp.stopServer();
             }
             Watcher(SICStus sp)
             {
                 mySp = sp;
             }
         }
         public void CallBack()
         {
             try {
                 SICStus sp = SICStus.getCaller(); // get the SICStus object
                 sp.load("train.ql");
                 Prolog jp = sp.newProlog(); // Create a new Prolog Interface
                 Client c1 =
                     new Client(jp, sp,
                                "connected('O"rebro', 'Hallsberg', Way1, Way1).");
                 c1.start();
                 // The prolog variable names in the Map are different from above so
                 // we can tell which query gives what solution.
                 Client c2 =
                     new Client(jp, sp,
                                "connected('Stockholm', 'Hallsberg', Way2, Way2).");
                 c2.start();
                 Watcher w = new Watcher(sp);
                 w.add(c1);
                 w.add(c2);
                 w.start();
                 sp.startServer();   // And finally start the server. This
                                     //  method call does not return until
                                     //  some other thread calls sp.stopServer().
             }
             catch ( Exception e ) {
                 e.printStackTrace();
             }
         }

     }
                                                    _% multisimple2.pl_
     :- use_module(library(jasper)).
     main:-
             jasper_initialize(JVM),
             jasper_new_object(JVM,
                               'MultiSimple2',
                               init,
                               init,
                               Obj),
             jasper_call(JVM,
                         method('', 'CallBack', [instance]),
                         'CallBack'(+object('')),
                         'CallBack'(Obj)).


  1. This example is similar to the previous multi threaded example
     *Note Multi Threaded Example::, but in this case Prolog is the top
     level.

  2. Since a SICStus object already exists when the java method
     'CallBack' is called, we cannot use 'Jasper.newProlog' to obtain a
     'Prolog' interface.  Instead we can use the 'SICStus' method
     'getCaller' to get a handle on the 'SICStus' object.

  3. In this example we cannot use the 'restore' method to load the
     Prolog saved state, since it unloads all foreign resources.  This
     includes 'library(jasper)' from which the call to Java was made.
     Instead the method 'SICStus.load' can be used to load a compiled
     Prolog file.  See the HTML Jasper documentation for details on this
     method.  *Note ref-lod-lod:: for how to create a '.ql' file.

  4. The rest of the example is similar to the previous multi threaded
     example with the addition of a watcher class, which is used to
     monitor the client threads.  This is necessary if the method
     'startServer' is to return.  See the HTML Jasper documentation on
     the methods 'SICStus.startServer' and 'SICStus.stopServer'.


File: sicstus.info,  Node: Jasper Package Class Reference,  Next: Java Exception Handling,  Prev: Calling Prolog from Java,  Up: lib-jasper

10.20.4 Jasper Package Class Reference
--------------------------------------

Detailed documentation of the classes in the 'jasper' package can be
found in the HTML documentation installed with SICStus and also on the
SICStus documentation page
(<https://sicstus.sics.se/documentation.html>).

     *Please note*: None of the 'se.sics.jasper' methods are thread
     safe, unless explicitly mentioned, they can only be called from the
     thread that created the SICStus object.  (This is different from
     how 'se.sics.jasper' worked in release 3.8.)

   As of release 3.9, Jasper supports multi threaded mode.  Several Java
threads can access SICStus runtime through a server thread that does the
actual calls.

   The API is defined by three 'interfaces': 'Prolog', 'Query' and
'Term'.  The methods of these 'interfaces' are implemented by inner
classes of the 'Jasper' server.  Instances of these inner classes are
returned by methods of the class 'Jasper' and can then be used from
multiple threads by the Java programmer.

   In multi threaded mode the Java programmer obtains an object
implementing the 'interface Prolog'.  That interface has methods similar
to the methods of the 'SICStus' class described below.  'Interface
Query' and 'interface Term' have the same relations to 'class SPQuery'
and 'class SPTerm', respectively.  In addition the 'SICStus' class, the
'SPQuery' class and the 'SPTerm' class all implement the above
interfaces.  The methods of the interfaces are preferred over the old
methods.

   See the HTML documentation for details on the methods of the
'interfaces'.

   *Note Jasper Notes: (relnotes)Jasper Notes.  for limitations in multi
threaded Jasper.

 -- Method on SICStus: boolean query '(String module, String name,
          SPTerm args[])'
     Call NAME with ARGS (a vector of 'SPTerm' objects).  Like
     'once(Module:Name(Args...))'.

     Returns 'true' if the call succeeded, 'false' if the call failed,
     i.e. there were no solutions.

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query '(String goal, Map varMap)'
     Call a goal specified as a string.

     'goal'
          The textual representation of the goal to execute, with
          terminating period.

     'varMap'
          A map from variable names to SPTerm objects.  Used both for
          passing variable bindings into the goal and to obtain the
          bindings produced by the goal.  May be null.

          On success, the values of variables with names that do not
          start with underscore ('_') will be added to the map.

     Returns 'true' if the call succeeded, 'false' if the call failed,
     i.e. there were no solutions.

          HashMap varMap = new HashMap();

          varMap.put("File", new SPTerm(sp, "datafile.txt"));

          if (sp.query("see(File),do_something(Result),seen.", varMap)) {
             System.out.println("Result==" +
                                ((SPTerm)varMap.get("Result")).toString());
          } else {
             System.out.println("Failed);
          }

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean query '(SPPredicate pred, SPTerm args[])'
     Obsolescent version of 'SICStus::query()' above.

 -- Method on SICStus: boolean queryCutFail '(String module, String
          name, SPTerm args[])'
     Call NAME with ARGS for side effect only.

     As 'SICStus.query()' it only finds the first solution, and then it
     cuts away all other solutions and fails.

     It corresponds roughly to the following Prolog code:
             ( \+ call(Module:Name(Args...)) -> fail; true )
     Introduced in release 3.8.5.

 -- Method on SICStus: boolean queryCutFail '(String goal, Map varMap)'
     Call a goal specified as a string, for side effect only.  The map
     is only used for passing variable bindings _into_ the goal.  See
     'query' for details

     Introduced in release 3.8.5.
 -- Method on SICStus: boolean queryCutFail '(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of 'queryCutFail' above.

 -- Method on SICStus: SPQuery openQuery '(String module, String name,
          SPTerm args[])'
     Sets up a query (an object of class 'SPQuery'), which can later be
     asked to produce solutions.  You must _close_ an opened query when
     no more solutions are required; see below.

     It corresponds roughly to the following Prolog code:
             ( true     % just calling openQuery does not call the predicate

             ; % failing (nextSolution) will backtrack for more solutions
               call(Module:Name(Args...))
             )

     Introduced in release 3.8.5.

 -- Method on SICStus: boolean openQuery '(String goal, Map varMap)'
     Sets up a query specified as a string.  See 'openQuery' and 'query'
     for details.

     Introduced in release 3.8.5.

 -- Method on SICStus: SPQuery openQuery '(SPPredicate pred, SPTerm
          args[])'
     Obsolescent version of 'openQuery' above.

   The following methods are used to obtain solutions from an opened
query and to tell the SICStus runtime system that no more answers are
required.

 -- Method on SPQuery: boolean nextSolution ()
     Obtain the next solution.  Returns 'true' on success and 'false' if
     there were no more solutions.  When you are no longer interested in
     any more solutions, you should call 'SPQuery.close' or
     'SPQuery.cut' to _close_ the query.

     Returns 'true' if a new solution was produced, 'false' if there
     were no more solutions.  This corresponds roughly to 'fail/0'.
     *Note SPTerm and Memory:: for additional details.

 -- Method on SPQuery: close ()
     Cut and fail away any previous solution to the query.  After
     closing a query object, you should not use it anymore.  This
     corresponds roughly to '!, fail'.  *Note SPTerm and Memory:: for
     additional details.

 -- Method on SPQuery: cut ()
     Cut, but do not fail away, any previous solution.  After closing a
     query object with 'cut', you should not use it anymore.  This
     corresponds roughly to '!'.  *Note SPTerm and Memory:: for
     additional details.


File: sicstus.info,  Node: Java Exception Handling,  Next: SPTerm and Memory,  Prev: Jasper Package Class Reference,  Up: lib-jasper

10.20.5 Java Exception Handling
-------------------------------

Exceptions are handled seamlessly between Java and Prolog.  This means
that exceptions can be thrown in Prolog and caught in Java and the other
way around.  For example, if a predicate called from Java throws an
exception with 'throw/1' and the predicate itself does not catch the
exception, then the Java method that performed the query,
'queryCutFail()' for example, will throw an exception (of class
'SPException') containing the exception term.  Symmetrically, a Java
exception thrown (and not caught) in a method called from Prolog will
cause the corresponding predicate ('simple/2' in the example above) to
throw an exception consisting of the exception object (in the internal
Prolog representation of a Java object).  *Note Handling Java
Exceptions:: for examples of catching Java exceptions in Prolog.


File: sicstus.info,  Node: SPTerm and Memory,  Next: Java Threads,  Prev: Java Exception Handling,  Up: lib-jasper

10.20.6 SPTerm and Memory
-------------------------

Java and Prolog have quite different memory management policies.  In
Java, memory is reclaimed when the garbage collector can determine that
no code will ever use the object occupying the memory.  In Prolog, the
garbage collector additionally reclaims memory upon failure (such as the
failure implied in the use of 'SPQuery.close()' and
'SPQuery::nextSolution()').  This mismatch in the notion of memory
lifetime can occasionally cause problems.

* Menu:

* Lifetime of SPTerms and Prolog Memory:: Lifetime of SPTerms and Prolog Memory
* Preventing SPTerm Memory Leaks:: Preventing SPTerm Memory Leaks


File: sicstus.info,  Node: Lifetime of SPTerms and Prolog Memory,  Next: Preventing SPTerm Memory Leaks,  Up: SPTerm and Memory

10.20.6.1 Lifetime of SPTerms and Prolog Memory
...............................................

There are three separate memory areas involved when manipulating Prolog
terms from Java using 'SPTerm' objects.  These areas have largely
independent life times.

  1. The 'SPTerm' object itself.
  2. Creating 'SPTerm' object also tells Prolog to allocate an
     SP_term_ref.  SP_term_refs have a life-time that is independent of
     the lifetime of the corresponding SPTerm object.
  3. Any Prolog terms allocated on the global stack.  An 'SPTerm' refer
     to a Prolog term indirectly via a SP_term_ref.

   A SP_term_ref REF (created as a side effect of creating a 'SPTerm'
object) will be reclaimed if either:
   * Java returns to Prolog.  This may never happen, especially if Java
     is the top-level application.
   * Assume there exists a still open query Q that was opened before the
     SP_term_ref REF was created.  The SP_term_ref REF will be reclaimed
     if the query Q is closed (using 'Q.close()' or 'Q.cut()') or if
     'Q.nextSolution()' is called.

   An 'SPTerm' object will be invalidated (and eventually reclaimed by
the garbage collector) if the corresponding SP_term_ref is reclaimed as
above.  If passed an invalidated SP_term_ref, then most methods will
throw an 'IllegalTermException' exception.

   A Prolog term (allocated on the global stack) will be deallocated
when:
   * Assume there exists a still open query Q that was opened before the
     term was created.  The memory of the term will be reclaimed if the
     query Q is closed using 'Q.close()' or if 'Q.nextSolution()' is
     called.  The memory is not reclaimed if the query is closed with
     'Q.cut()'.

     *Please note*: it is possible to get a 'SPTerm' object and its
     SP_term_ref to refer to deallocated Prolog terms, in effect
     creating "dangling" pointers in cases where the 'SPTerm' would
     ordinarily still be valid.  This will be detected and invalidate
     the 'SPTerm':
          {
            SPTerm old = new SPTerm(sp);
            SPQuery q;

            q = sp.openQuery(....);
            ...
            old.consFunctor(...);  // allocate a Prolog term _newer_ than q
            ...
            q.nextSolution(); // or q.close()
            // *error:*
            // The SP_term_ref in q refers to an invalid part of the global stack
            // the SPTerm old will be invalidated by q.nextSolution()
          }


File: sicstus.info,  Node: Preventing SPTerm Memory Leaks,  Prev: Lifetime of SPTerms and Prolog Memory,  Up: SPTerm and Memory

10.20.6.2 Preventing SPTerm Memory Leaks
........................................

Some uses of 'SPTerm' will leak memory on the Prolog side.  This happens
if a new 'SPTerm' object is allocate, but Java neither returns to Prolog
nor backtracks (using the method 'close', 'cut' or 'nextSolution') into
a query opened before the allocation of the 'SPTerm' object.

   As of release 3.8.5, it is possible to explicitly delete a 'SPTerm'
object using the 'SPTerm.delete()' method.  The 'delete()' method
invalidates the SPTerm object and makes the associated SP_term_ref
available for reuse.

   Another way to ensure that all SP_term_refs are deallocated is to
open a dummy query only for this purpose.  The following code
demonstrates this:

     // Always synchronize over creation and closing of SPQuery objects
     synchronized (sp) {
         // Create a dummy query that invokes true/0
         SPQuery context = sp.openQuery("user","true",new SPTerm[]{});
         // All SP_term_refs created after this point will be reclaimed by
         // Prolog when doing context.close() (or context.cut())

         try {           // ensure context is always closed
             SPTerm tmp = new SPTerm(sp); // created _after_ context
             int i = 0;

             while (i++ < 5) {
                 // reused instead of doing tmp = new SPTerm(sp,"...");
                 tmp.putString("Iteration #" + i + "\n");
                 // e.g. user:write('Iteration #1\n')
                 sp.queryCutFail("user", "write", new SPTerm[]{tmp});
             }
         }
         finally {
             // This will invalidate tmp and make Prolog
             // reclaim the corresponding SP_term_ref
             context.close(); // or context.cut() to retain variable bindings.
         }
     }


File: sicstus.info,  Node: Java Threads,  Next: The Jasper Library,  Prev: SPTerm and Memory,  Up: lib-jasper

10.20.7 Java Threads
--------------------

None of the pre-3.9 methods in 'se.sics.jasper' are thread safe.  They
can only be called from the thread that created the SICStus object.
(This is different from how 'se.sics.jasper' used to work in release
3.8.)

   As of 3.9 there are two ways to set up for calls to SICStus from
multiple threads.

   One way is to use the static method 'newProlog' in the class
'Jasper':

 -- Method on Jasper: Prolog newProlog '(String argv[], String
          bootPath)'
     Creates a 'Prolog' interface object.  Starts a server thread, which
     will serve that 'Prolog'.  The server thread takes care of all
     interaction with the Prolog runtime, making sure that all calls to
     the Prolog runtime will be done from one and the same thread.

   See the HTML documentation on the 'interface Prolog' for details on
what methods are available for a client thread.

   Another way is to create a SICStus object and use the following
methods:

 -- Method on SICStus: Prolog newProlog '()'
     Returns the 'Prolog' interface for this SICStus object.  Creates a
     server and a client ('Prolog') interface for this SICStus object.
     The server may be started by calling 'startServer()'

 -- Method on SICStus: startServer '()'
     Start serving requests from a Prolog client.  This method does not
     return until another thread calls 'stopServer()'.  Before calling
     this method you should call 'newProlog()' and hand the result over
     to another Thread.

 -- Method on SICStus: stopServer '()'
     Stops the server.  Calling this method causes the Thread running in
     the 'startServer()' method to return.

   As with the first method, the 'interface Prolog' defines the methods
available for the client threads.


File: sicstus.info,  Node: The Jasper Library,  Prev: Java Threads,  Up: lib-jasper

10.20.8 The Jasper Library
--------------------------

The Jasper library module is the Prolog interface to the Java VM. It
corresponds to the 'se.sics.jasper' package in Java.  It is loaded by
executing the query:

     | ?- use_module(library(jasper)).

   The Jasper library fully supports multiple SICStus runtimes in a
process.

   Jasper cannot be used when the SICStus runtime is statically linked
to the executable, such as when using 'spld --static'.

   The following functionality is provided:

   * Initializing the Java VM using the _JNI Invocation API_
     ('jasper_initialize/[1,2]', 'jasper_deinitialize/1').
   * Creating and deleting Java objects directly from Prolog
     ('jasper_new_object/5').
   * Method calls ('jasper_call/4').

   * Global and local (object) reference management
     ('jasper_create_global_ref/3', 'jasper_delete_global_ref/2',
     'jasper_delete_local_ref/2').  Global references are used to
     prevent the JVM from garbage collecting a Java object referenced
     from Prolog.
   * There is also a subdirectory containing example programs
     ('library('jasper/examples')').

* Menu:

* Jasper Method Call Example:: Jasper Method Call Example
* Jasper Library Predicates:: Jasper Library Predicates
* Conversion between Prolog Arguments and Java Types:: Conversion between Prolog Arguments and Java Types
* Global vs. Local References:: Global vs. Local References
* Handling Java Exceptions:: Handling Java Exceptions
* Deprecated Jasper API:: Deprecated Jasper API


File: sicstus.info,  Node: Jasper Method Call Example,  Next: Jasper Library Predicates,  Up: The Jasper Library

10.20.8.1 Jasper Method Call Example
....................................

We begin with a small example.

                                                       _// Simple.java_
     import se.sics.jasper.*;

     public class Simple {
       private String instanceDatum = "this is instance data";

       static int simpleMethod(int value) {
         return value*42;
       }

       public String getInstanceData(String arg) {
         return instanceDatum + arg;
       }
     }

   Compile 'Simple.java' (UNIX):
     % javac -deprecation \
       -classpath <installdir>/lib/sicstus-4.7.0/bin/jasper.jar Simple.java

   Under Windows this may look like (the command should go on a single
line):
     C:\> c:\jdk1.2.2\bin\javac -deprecation
      -classpath "D:\Program Files\SICStus Prolog 4.7.0\bin\jasper.jar" Simple.java

   The option '-deprecation' is always a good idea, it makes 'javac'
warn if your code use deprecated methods.

                                                          _% simple.pl_
     :- use_module(library(jasper)).
     main :-
        %% Replace '/my/java/dir' below with the path containing
        %% 'Simple.class', e.g. to look in the current directory use
        %% classpath(['.']).
        %% You can also use the CLASSPATH environment variable and call
        %% jasper_initialize(JVM)
        %% Under Windows it may look like classpath(['C:/MyTest'])
        jasper_initialize([classpath(['/my/java/dir'])],JVM),

        format('Calling a static method...~n',[]),
        jasper_call(JVM,
                    method('Simple','simpleMethod',[static]), % Which method
                    simple_method(+integer,[-integer]), % Types of arguments
                    simple_method(42,X)), % The arguments.
        format('simpleMethod(~w) = ~w~n',[42,X]),

        format('Creating an object...~n',[]),
        jasper_new_object(JVM, 'Simple', init, init, Object),

        format('Calling an instance method on ~w...~n',[Object]),
        jasper_call(JVM,
                    method('Simple','getInstanceData',[instance]),
                    %% first arg is the instance to call
                    get_instance_data(+object('Simple'), +string,[-string]),
                    get_instance_data(Object, 'foobar', X1)),
        format('getInstanceData(~w) = ~w~n',['foobar',X1]).

   Then, run SICStus:

     % echo "[simple],main." | sicstus
     SICStus 4.7.0 ...
     Licensed to SICS
     % consulting /home1/jojo/simple.pl...
     [...]
     % consulted /home1/jojo/simple.pl in module user, 100 msec 26644 bytes
     Calling a static method...
     simpleMethod(42) = 1764
     Creating an object...
     Calling and instance method on $java_object(135057576)...
     getInstanceData(foobar) = this is instance datafoobar

   This example performed three things.

   * The static method 'simpleMethod' was called with argument '42', and
     returned the square of '42', '1764'.
   * An object of class 'Simple' was created.
   * The method 'getInstanceData' was executed on the object just
     created.  The method took an atom as an argument and appended the
     atom to a string stored as a field in the object, yielding "this is
     instance datafoobar".


File: sicstus.info,  Node: Jasper Library Predicates,  Next: Conversion between Prolog Arguments and Java Types,  Prev: Jasper Method Call Example,  Up: The Jasper Library

10.20.8.2 Jasper Library Predicates
...................................

'jasper_initialize(-JVM)'
'jasper_initialize(+OPTIONS, -JVM)'

     Loads and initializes the Java VM. JVM is a reference to the Java
     VM. OPTIONS is a list of options.  The options can be of the
     following types:

     'classpath(<classpath>)'
          If '<classpath>' is an atom, then it will be added
          (unmodified) to the Java VM's classpath.  If '<classpath>' is
          a list, then each element will be expanded using
          'absolute_file_name/2' and concatenated using the Java VM's
          path separator.  Example:
               classpath([library('jasper/examples'),'$HOME/joe'])
          In addition to the classpaths specified here, Jasper will
          automatically add 'jasper.jar' to the classpath together with
          the contents of the 'CLASSPATH' environment variable.

     'if_exists(OPTION)'
          This option determines what happens if a JVM has already been
          initialized, either through a previous call to
          'jasper_initialize' or because Prolog have been called from
          Java.  If a JVM already exists, then the other options are
          ignored.
          'ok'
               The default.  Argument JVM is bound to the existing JVM.
          'fail'
               The call to 'jasper_initialize/2' fails.
          'error'
               The call to 'jasper_initialize/2' throws an exception
               ('java_exception(SOME TEXT)').

     'if_not_exists(OPTION)'
          This option determines what happens if a JVM has not already
          been initialized.
          'ok'
               The default.  The remaining options are used to
               initialize the JVM.
          'fail'
               The call to 'jasper_initialize/2' fails.
          'error'
               The call to 'jasper_initialize/2' throws an exception
               ('java_exception(SOME TEXT)').

          As an example, to access the currently running JVM and to give
          an error if there is no running JVM use
          'jasper_initialize([if_exists(ok),if_not_exists(error)],
          JVM)'.

     'OPTION'
          The option is an atom that will be passed directly to the Java
          VM as an option.  This enables the user to send additional
          options to the Java VM. Example:
               jasper_initialize(['-Dkenny.is.dead=42'],JVM),
     In addition to the options specified by the user, Jasper adds a
     couple of options on its own in order for Java to find the Jasper
     classes and the Jasper native library.

     There is currently no support for creating multiple JVMs (few JDKs,
     if any, supports this).

'jasper_deinitialize(+JVM)'

     De-initialize Java.  Do Not call this, current versions of the JVM
     does not support deinitialization.

'jasper_call(+JVM,+METHOD,+TYPEINFO,+ARGS)'

     Calls a Java static or instance method.

     JVM
          A reference to the Java VM, as obtained by
          'jasper_initialize/[1,2]'.

     METHOD

          A term of the form 'method(CLASSNAME, METHODNAME, FLAGS)' that
          identifies the method to call.

          CLASSNAME
               This is the "Fully Qualified Classname" of the class (for
               example, 'java/lang/String') of the object or where to
               look for the static method.  Note that you need to
               surround the atom with single quotes since it contains
               '/' characters.  The class is ignored when calling
               instance methods but should still be an atom, e.g. ''''.
          NAME
               This is the name of the method, as an atom.
          FLAGS
               This is the singleton list '[instance]' for instance
               methods and '[static]' for static methods.

     TYPEINFO
          Information about the argument types and the argument
          conversion that should be applied.  *Note Conversion between
          Prolog Arguments and Java Types:: for more information on
          specifying argument types.

          Note that for an instance method the first argument must be an
          object reference (specified with '+object(CLASS)').  In this
          case the class is ignored but should still be an atom, e.g.
          ''''.

     ARGS
          A term with one position for each argument to the method.  For
          an instance method the first argument is the instance.

'jasper_new_object(+JVM,+CLASSNAME,+TYPEINFO,+ARGS,-OBJECT)'

     Creates a new Java object.

     See 'jasper_call/4' above for an explanation of the arguments JVM,
     CLASSNAME, TYPEINFO and ARGS.
     CLASSNAME
          An an atom containing the _fully qualified classname_
     TYPEINFO
          TYPEINFO has the same format as for a static void method.
     ARGS
          A term with one position for each argument to the constructor.
     OBJECT
          This argument is bound to a (local) reference to the created
          object.  *Note Global vs. Local References::.

     As an example, the following code creates a 'java/lang/Integer'
     object initialized from a string of digits.  It then calls the
     instance method 'doubleValue' to obtain the floating point
     representation of the Integer.

          | ?- Chars = "4711",
               %% get existing JVM
               jasper_initialize([if_not_exists(error)], JVM),
               jasper_new_object(JVM, 'java/lang/Integer',
                                 init(+chars), init(Chars), S),
               jasper_call(JVM,
                           method('java/lang/Integer', doubleValue, [instance]),
                           to_double(+object('java/lang/Integer'), [-double]),
                           to_double(S,X)).

          S = '$java_object'(135875344),
          X = 4711.0,  % note that this is now a floating point number
          JVM = '$jvm'(1076414148),
          Chars = [52,55,49,49]  % a.k.a. "4711"


'jasper_create_global_ref(+JVM,+REF,-GLOBALREF)'

     Creates a global reference (GLOBALREF) for a (non-null) Java object
     (REF).  *Note Global vs. Local References::.

'jasper_delete_global_ref(+JVM,+GLOBALREF)'

     Destroys a global reference.  *Note Global vs. Local References::.

'jasper_create_local_ref(+JVM,+REF,-LOCALREF)'

     Creates a local reference (LOCALREF) for a (non-null) Java object
     (REF).  *Note Global vs. Local References::.  Rarely needed.

'jasper_delete_local_ref(+JVM,+GLOBALREF)'

     Destroys a local reference.  *Note Global vs. Local References::.

'jasper_is_jvm(+JVM)'

     Succeeds if JVM is a reference to a Java Virtual Machine.

'jasper_is_object(+OBJECT)'
'jasper_is_object(+JVM,+OBJECT)'

     Succeeds if OBJECT is a reference to a Java object.  The
     representation of Java object _will_ change so use
     'jasper_is_object/1' to recognize objects instead of relying on the
     internal representation.  Currently the JVM argument is ignored.
     If, and when, multiple JVMs becomes a possibility
     'jasper_is_object/2' will verify that OBJECT is an object in a
     particular JVM.

'jasper_is_same_object(+JVM,+OBJECT1,+OBJECT2)'

     Succeeds if OBJECT1 and OBJECT2 refers to the same Java object (or
     both are null object references).  The same object may be
     represented by two different terms in Prolog so '==/2' can _not_ be
     used to reliably detect if two object references refer to the same
     object.

'jasper_is_instance_of(+JVM,+OBJECT,+CLASSNAME)'

     Succeeds if OBJECT is an instance of class CLASSNAME; fails
     otherwise.  CLASSNAME is a fully qualified classname; see
     'jasper_call/4'.

'jasper_object_class_name(+JVM,+OBJECT,-CLASSNAME)'

     Returns the fully qualified name of the class of +OBJECT as an
     atom.

'jasper_null(+JVM,-NULLREF)'

     Create a null object reference.

'jasper_is_null(+JVM,+REF)'

     Succeeds if REF is a null object reference, fails otherwise, e.g.
     if REF is not an object reference.


File: sicstus.info,  Node: Conversion between Prolog Arguments and Java Types,  Next: Global vs. Local References,  Prev: Jasper Library Predicates,  Up: The Jasper Library

10.20.8.3 Conversion between Prolog Arguments and Java Types
............................................................

The following table lists the possible values of arguments of the
argument type specification to 'jasper_call/4' and 'jasper_new_object/5'
(*note Jasper Library Predicates::).  The value specifies which
conversion between corresponding Prolog argument and Java type will take
place.

   There is currently no mechanism for specifying Java arrays in this
way.

   In the following the package prefix ('java/lang' or 'se/sics/jasper')
has been left out for brevity.

   For several of the numerical types there is the possibility that the
target type cannot accurately represent the source type, e.g. when
converting from a Prolog integer to a Java byte.  The behavior in such
cases is unspecified.

'Prolog: +integer'
'Java: int'

     The argument should be a number.  It is converted to a Java 'int',
     a 32 bit signed integer.

'Prolog: +byte'
'Java: byte'

     The argument should be a number.  It is converted to a Java 'byte'.

'Prolog: +short'
'Java: short'

     The argument should be a number.  It is converted to a Java
     'short', a 16 bit signed integer.

'Prolog: +long'
'Java: long'

     The argument should be a number.  It is converted to a Java 'long',
     a 64-bit signed integer.

     In releases prior to 3.9.1, the value was truncated to 32 bits when
     passed between Java and Prolog.  This is no longer the case.

'Prolog: +float'
'Java: float'

     The argument should be a number.  It is converted to a Java
     'float'.

'Prolog: +double'
'Java: double'

     The argument should be a number.  It is converted to a Java
     'double'.

'Prolog: +term'
'Java: SPTerm'

     The argument can be any term.  It is passed to Java as an object of
     the class 'SPTerm'.

'Prolog: +object(CLASS)'
'Java: CLASS'

     The argument should be the Prolog representation of a Java object
     of class CLASS.  Unless it is the first argument in a non-static
     method (in which case is it treated as the object on which the
     method should be invoked), it is passed to the Java method as an
     object of class 'Class'.

'Prolog: +atom   obsolescent'
'Java: SPCanonicalAtom'
     The argument should be an atom.  The Java method will be passed an
     object of class 'SPCanonicalAtom'.  Often '+string', see below, is
     more useful.

'Prolog: +boolean'
'Java: boolean'

     The argument should be an atom in {'true','false'}.  The Java
     method will receive a 'boolean'.

'Prolog: +chars'
'Java: String'

     The argument should be a code list.  The Java method will receive
     an object of class 'String'.

'Prolog: +codes'
'Java: String'

     '+codes' is an alias for '+chars'.

'Prolog: +string'
'Java: String'

     The argument should be an atom.  The Java method will receive an
     object of class 'String'.

'Note.'
     When using '+chars', '+codes' or '+string' the automatic type
     conversion mechanism will also create a type signature of the form
     java/lang/String.  If you want to call a method that accepts a
     String object as a parameter, but has different signature, then the
     method lookup will fail.  A workaround is to explicitly create a
     String object and then call the method.  For example:
          :- use_module(library(jasper)).

          main :-
              jasper_initialize([],JVM),
              jasper_new_object(JVM,
          		      'java/lang/String',
          		      init(+chars),
          		      init("hamburger"),
          		      H),
              Str = "urge",
              jasper_new_object(JVM,
           		      'java/lang/String',
           		      init(+chars),
           		      init(Str),
           		      S),
              jasper_call(JVM,
          		method('', contains, [instance]),
          		contains(+object(''),
          			+object('java/lang/CharSequence'),
          			[-boolean]),
          		contains(H, S, B)),
              format('Contains? ~a~n', [B]).

'Prolog: -atom   obsolescent'
'Java: SPTerm'
     The Java method will receive an object of class 'SPTerm', which
     should be set to an atom (e.g. using 'SPTerm.putString').  The
     argument will be bound to the value of the atom when the method
     returns.  Often '-term', see below, is more useful.

'Prolog: -chars'
'Java: StringBuffer'

     The Java method will receive an (empty) object of type
     'StringBuffer', which can be modified.  The argument will be bound
     to a code list of the 'StringBuffer' object.

'Prolog: -codes'
'Java: StringBuffer'

     '-codes' is an alias for '-chars'.

'Prolog: -string'
'Java: StringBuffer'

     The Java method will receive an object of type 'StringBuffer',
     which can be modified.  The argument will be bound to an atom
     converted from the 'StringBuffer' object.

'Prolog: -term'
'Java: SPTerm'

     The Java method will receive an object of class 'SPTerm', which can
     be set to a term (e.g. using 'SPTerm.consFunctor').  The argument
     will be bound to the term when the method returns.

'Prolog: [-integer]'
'Java: int M()'

     The Java method should return an 'int'.  The value will be
     converted to a Prolog integer.

'Prolog: [-byte]'
'Java: byte M()'

     The Java method should return a 'byte'.  The value will be
     converted to a Prolog integer.

'Prolog: [-short]'
'Java: short M()'

     The Java method should return a 'short'.  The value will be
     converted to a Prolog integer.

'Prolog: [-long]'
'Java: long M()'

     The Java method should return a 'long', a 64 bit signed integer.
     The value will be converted to a Prolog integer.

'Prolog: [-float]'
'Java: float M()'

     The Java method should return a 'float'.  The value will be
     converted to a Prolog float.

'Prolog: [-double]'
'Java: double M()'

     The Java method should return a 'double'.  The value will be
     converted to a Prolog float.

'Prolog: [-term]'
'Java: SPTerm M()'

     The Java method should return an object of class 'SPTerm', which
     will be converted to a Prolog term.

'Prolog: [-object(CLASS)]'
'Java: SPTerm M()'

     The Java method should return an object of class CLASS, which will
     be converted to the internal Prolog representation of the Java
     object.

'Prolog: [-atom]  obsolescent'
'Java: SPTerm M()'

     The Java method should return an object of class 'SPCanonicalAtom',
     which will be converted to a Prolog atom.  Often '[-term]', see
     above, is more useful.

'Prolog: [-boolean]'
'Java: boolean M()'

     The Java should return a 'boolean'.  The value will be converted to
     a Prolog atom in {'true','false'}.

'Prolog: [-chars]'
'Java: String M()'

     The Java method should return an object of class 'String', which
     will be converted to a code list.

'Prolog: [-codes]'
'Java: String M()'

     '[-codes]' is an alias for '[-chars]'.

'Prolog: [-string]'
'Java: String M()'

     The Java method should return an object of class 'String', which
     will be converted to an atom.


File: sicstus.info,  Node: Global vs. Local References,  Next: Handling Java Exceptions,  Prev: Conversion between Prolog Arguments and Java Types,  Up: The Jasper Library

10.20.8.4 Global vs. Local References
.....................................

It is important to understand the rules determining the life-span of
Java object references.  These are similar in spirit to the SP_term_refs
of the C-Prolog interface, but since they are used to handle Java
objects instead of Prolog terms they work a little differently.

   Java object references (_currently_ represented in Prolog as
''$java_object'/1' terms) exist in two flavors: _local_ and _global_.
Their validity are governed by the following rules.

  1. A local reference is valid until Prolog returns to Java or the
     reference is deleted with 'jasper_delete_local_ref/2'.  It is only
     valid in the (native) thread in which is was created.  As a rule of
     thumb a local reference can be used safely as long as it is not
     saved away using 'assert/3' or similar.

     Since local references are _never_ reclaimed until Prolog returns
     to Java (which may never happen) you should typically call
     'jasper_delete_local_ref/2' when your code is done with an object.

  2. A global reference is valid until explicitly freed.  It can be used
     from any native thread.
  3. All objects returned by Java methods are converted to local
     references.
  4. Java exceptions not caught by Java are thrown as Prolog exceptions
     consisting of a _global_ reference to the exception object, see
     *note Handling Java Exceptions::.

   Local references can be converted into global references
('jasper_create_global_ref/3').  When the global reference is no longer
needed, it should be deleted using 'jasper_delete_global_ref/2'.

   For a more in-depth discussion of global and local references,
consult the JNI Documentation
(https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html).

   Using a local (or global) reference that has been deleted (either
explicitly or by returning to Java) is illegal and will generally lead
to crashes.  This is a limitation of the Java Native Interface used to
implement the low level interface to Java.


File: sicstus.info,  Node: Handling Java Exceptions,  Next: Deprecated Jasper API,  Prev: Global vs. Local References,  Up: The Jasper Library

10.20.8.5 Handling Java Exceptions
..................................

If a Java method throws an exception, e.g. by using 'throw new
Exception("...")' and the exception is not caught by Java, then it is
passed on as a Prolog exception.  The thrown term is a _global_
reference to the Exception object.  The following example code
illustrates how to handle Java exceptions in Prolog:

     exception_example(JVM, ...) :-
        catch(
              %% Call Java method that may raise an exception
              jasper_call(JVM, ...),
              Excp,
              (
                ( is_java_exception(JVM, Excp)
                -> print_exception_info(JVM, Excp)
                ; throw(Excp)       % pass non-Java exceptions to caller
                )
              )
             ).

     is_java_exception(_JVM, Thing) :- var(Thing), !, fail.
     is_java_exception(_JVM, Thing) :-
        Thing = java_exception(_),      % misc error in Java/Prolog glue
        !.
     is_java_exception(JVM, Thing) :-
        jasper_is_object(JVM, Thing),
        jasper_is_instance_of(JVM, Thing, 'java/lang/Throwable').
     print_exception_info(_JVM, java_exception(Message)) :- !,
        format(user_error, '~NJasper exception: ~w~n', [Message]).
     print_exception_info(JVM, Excp) :-
        /*
        // Approximate Java code
        {
           String messageChars = excp.getMessage();
        }
        */
        jasper_call(JVM,
                    method('java/lang/Throwable', 'getMessage', [instance]),
                    get_message(+object('java/lang/Throwable'), [-chars]),
                    get_message(Excp, MessageChars)),
        /* // Approximate Java code
        {
           StringWriter stringWriter = new StringWriter();
           PrintWriter printWriter =  new PrintWriter(stringWriter);
           excp.printStackTrace(printWriter);
           printWriter.close();
           stackTraceChars = StringWriter.toString();
        }
        */
        jasper_new_object(JVM, 'java/io/StringWriter',
                          init, init, StringWriter),
        jasper_new_object(JVM, 'java/io/PrintWriter',
                          init(+object('java/io/Writer')),
                          init(StringWriter), PrintWriter),
        jasper_call(JVM,
                    method('java/lang/Throwable', 'printStackTrace', [instance]),
                    print_stack_trace(+object('java/lang/Throwable'),
                                      +object('java/io/PrintWriter')),
                    print_stack_trace(Excp, PrintWriter)),
        jasper_call(JVM,
                    method('java/io/PrintWriter','close',[instance]),
                    close(+object('java/io/PrintWriter')),
                    close(PrintWriter)),
        jasper_call(JVM,
                    method('java/io/StringWriter','toString',[instance]),
                    to_string(+object('java/io/StringWriter'),[-chars]),
                    to_string(StringWriter, StackTraceChars)),
        jasper_delete_local_ref(JVM, PrintWriter),
        jasper_delete_local_ref(JVM, StringWriter),
        %% ! exceptions are thrown as global references
        jasper_delete_global_ref(JVM, Excp),
        format(user_error, '~NJava Exception: ~s\nStackTrace: ~s~n',
               [MessageChars, StackTraceChars]).


File: sicstus.info,  Node: Deprecated Jasper API,  Next: Deprecated Argument Conversions,  Prev: Handling Java Exceptions,  Up: The Jasper Library

10.20.8.6 Deprecated Jasper API
...............................

* Menu:

* Deprecated Argument Conversions:: Deprecated Argument Conversions
* Deprecated Jasper Predicates:: Deprecated Jasper Predicates

The information in this section is only of interest to those that need
to read or modify code that used 'library(jasper)' before release 3.8.5.

   A different way of doing method call and creating objects was used in
versions of 'library(jasper)' predating release 3.8.5.  Use of these
facilities are strongly discouraged although they are still available in
the interest of backward compatibility.

   The old method call predicates are 'jasper_call_static/6' and
'jasper_call_instance/6' as well as the old way of calling
'jasper_new_object/5'.


File: sicstus.info,  Node: Deprecated Argument Conversions,  Up: Deprecated Jasper API

10.20.8.7 Deprecated Argument Conversions
.........................................

The pre release 3.8.5 method call predicates in this library use a
specific form of argument lists containing conversion information so the
predicates know how to convert the input arguments from Prolog datatypes
to Java datatypes.  This is similar to the (new) mechanism described in
*note Conversion between Prolog Arguments and Java Types::.  The
argument lists are standard Prolog lists containing terms on the
following form:

'jboolean(X)'
     X is the atom 'true' or 'false', representing a Java 'boolean'
     primitive type.
'jbyte(X)'
     X is an integer, which is converted to a Java 'byte'.
'jchar(X)'
     X is an integer, which is converted to a Java 'char'.
'jdouble(X)'
     X is a float, which is converted to a Java 'double'.
'jfloat(X)'
     X is a float, which is converted to a Java 'float'.
'jint(X)'
     X is an integer, which is converted to a Java 'int'.
'jlong(X)'
     X is an integer, which is converted to a Java 'long'.
'jshort(X)'
     X is an integer, which is converted to a Java 'short'.
'jobject(X)'
     X is a reference to a Java object, as returned by
     'jasper_new_object/5' (*note Jasper Library Predicates::).
'jstring(X)'
     X is an atom, which is converted to a Java 'String'.

   If the Prolog term does not fit in the corresponding Java data type
('jbyte(4711)', for example), then the result is undefined.


File: sicstus.info,  Node: Deprecated Jasper Predicates,  Up: Deprecated Jasper API

10.20.8.8 Deprecated Jasper Predicates
......................................

'jasper_new_object(+JVM,+CLASS,+TYPESIG,+ARGS,-OBJECT)   obsolescent'

     Creates a new Java object.
     JVM
          A reference to the Java VM, as obtained by
          'jasper_initialize/[1,2]'.
     CLASS
          An an atom containing the _fully qualified classname_ (i.e.
          package name separated with '/', followed by the class name),
          for example 'java/lang/String', 'se/sics/jasper/SICStus'.
     TYPESIG
          The _type signature_ of the class constructor.  A type
          signature is a string that uniquely defines a method within a
          class.  For a definition of type signatures, see the JNI
          Documentation
          (http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html).
     ARGS
          A list of argument specifiers.  *Note Deprecated Argument
          Conversions::.
     OBJECT
          A term on the form ''$java_object'(X)', where X is a Java
          object reference.  This is the Prolog handle to the Java
          object.  *Note Global vs. Local References::.


File: sicstus.info,  Node: lib-json,  Next: lib-jsonrpc,  Prev: lib-jasper,  Up: The Prolog Library

10.21 JSON format serialization--'library(json)'
================================================

This library module provides some utilities for reading and writing
structured data using the JSON (https://json.org/) (JavaScript Object
Notation) serialization format.  The library module is part of SICStus
Prolog since release 4.5.0.

   JSON is a light-weight, language independent, data-interchange format
with good support in many environments.  As such, it is a convenient
format when transferring data between Prolog and other programming
languages.  The format is specified in ECMA-404 and in RFC 8259.

   The Prolog representation of JSON values is as follows:

NUMBER
     A JSON number is represented as the corresponding Prolog number; as
     a float when the JSON number has an exponent or a fractional part,
     otherwise as an integer.

STRING
     A JSON string is represented as the corresponding Prolog atom
     (escaped surrogate pairs are combined into the corresponding
     Unicode code point).

ARRAY
     A JSON array is represented as a list of the corresponding Prolog
     terms.

OBJECT
     A JSON object is a sequence of 'NAME:VALUE' pairs, where each name
     is a JSON string and each value is an arbitrary JSON value.  It is
     represented as a term 'json(MEMBERS)' where MEMBERS is a list of
     'NAME=VALUE' pairs, where NAME is a representation of the JSON
     string name and VALUE is a representation of the JSON value.

'null'
'true'
'false'
     These special JSON literals are, by default, translated to the
     Prolog terms '@(null)', '@(true)', and '@(false)', respectively.

   Examples:
     123 => 123

     12.3 => 12.3

     12E3 => 12.0E3

     "foo" => 'foo'

     null => @(null)

     ["a", 2, "bar"] => ['a', 2, 'bar']

     {"age": 42,
      "name": {"first":"Kim", "last":"Jones"},
      "children": ["Lisa","Jim","John"]
     }
     =>
     json(['age'=42,
           'name'=json(['first'='Kim', 'last'='Jones']),
           'children'=['Lisa','Jim','John']])


   It is possible to specify other Prolog representations of a JSON
value using the option argument.  See below for details.

10.21.1 Options
---------------

The following options are used.  They are valid for all predicates that
takes options, unless stated otherwise.

'compact(BOOLEAN)'
     Valid values for BOOLEAN are 'true' and 'false' (default).

     If 'false' (default), JSON values are written with extra whitespace
     and end-of-line characters to make it easier for humans to read.
     The details of the non-compact format is subject to change without
     notice.

     If 'true', JSON values are written with a minimum of whitespace.
     Since this implies that no end-of-line characters will be written,
     it makes it possible to read the resulting JSON as a single line.

     Only valid for predicates that write.

'ascii(BOOLEAN)'
     Valid values for BOOLEAN are 'true' (default) and 'false'.

     If 'true' (default), JSON values are written using only 7-bit ASCII
     characters, which makes the format less sensitive to stream
     encodings.

     If 'false', JSON values are written using full Unicode.  In this
     case any streams should use UTF-8 encoding.

     Only valid for predicates that write.

'null(X)'
'true(X)'
'false(X)'
     The specified term X, which may be a variable, is used for
     representing the corresponding JSON literal.

'array_tag(TAG)'
     The TAG must be an atom.

     A JSON array is represented as the compound term 'TAG(ELEMENTS)',
     where ELEMENTS is a list of the representations of the array
     elements.  This may be useful if you need to be able to distinguish
     between an empty JSON array ('[]'), and a JSON string '"[]"', since
     these have the same Prolog representation (the atom '[]') in the
     default representation.

     If this option is not specified (the default), then JSON arrays are
     represented as a list of the representations of the array elements.

'object_tag(TAG)'
     The TAG must be an atom.  TAG defaults to ''json''.

     A JSON object is represented as the compound term 'TAG(MEMBERS)',
     where MEMBERS is a list of 'NAME=VALUE' pairs, where NAME is a
     representation of the JSON string name and VALUE is a
     representation of the JSON value.

'width(WIDTH)'
     This option is present for compatibility with other systems.

     If WIDTH is '0' (zero), it is treated as a synonym for
     'compact(true)'.  Otherwise, the option is currently ignored.

     Only valid for predicates that write.

'value_string_as(VALUE)'
'step(VALUE)'
'tab(VALUE)'
'serialize_unknown(VALUE)'

     These options are present for compatibility with other systems.
     They are currently ignored.

     Only valid for predicates that write.

10.21.2 Exported Predicates
---------------------------

The OPTIONS argument is described in the module documentation.

'json_read(+STREAM, -TERM)'
'json_read(+STREAM, -TERM, +OPTIONS)'

     Reads a single JSON value from the text stream STREAM and unifies
     it with TERM.
'json_write(+STREAM, +TERM)'
'json_write(+STREAM, +TERM, +OPTIONS)'

     Write the JSON value TERM to the text stream STREAM.
'is_json_term(+TERM)'
'is_json_term(+TERM, +OPTIONS)'

     True if the TERM is a valid representation of a JSON value.
'json_to_codes(+TERM, -JSONCODES)'
'json_to_codes(+TERM, -JSONCODES, +OPTIONS)'

     Writes TERM as JSON and unifies JSONCODES with the list of
     resulting character codes.
'json_to_atom(+TERM, -JSONATOM)'
'json_to_atom(+TERM, -JSONATOM, +OPTIONS)'

     Writes TERM as JSON and unifies JSONATOM with an atom consisting of
     the resulting character codes.
'json_from_codes(+JSONCODES, -TERM)'
'json_from_codes(+JSONCODES, -TERM, +OPTIONS)'

     Converts a JSON text, represented as the list of character codes
     JSONCODES, into the corresponding Prolog term TERM.
'json_from_atom(+JSONATOM, -TERM)'
'json_from_atom(+JSONATOM, -TERM, +OPTIONS)'

     Converts a JSON text, represented as the character codes of
     JSONATOM, into the corresponding Prolog term TERM.
   A small example:
     | ?- JSONCodes = "{\"foo\": 42, \"bar\": null}",
          json_from_codes(JSONCodes, JSONTerm),
          json_to_atom(JSONTerm, JSONAtom, [compact(true)]).
     JSONCodes = [123,34,102,111,111,34,58,32,52,50|...],
     JSONTerm = json([foo=42,bar= @(null)]),
     JSONAtom = '{"foo":42,"bar":null}' ?
     yes
     | ?-


File: sicstus.info,  Node: lib-jsonrpc,  Next: lib-linda,  Prev: lib-json,  Up: The Prolog Library

10.22 JSON mediated process communication--'library(jsonrpc/jsonrpc_server)'
============================================================================

This is not a library module proper, but a collection of examples of
using JSON to communicate between a non-Prolog parent process and a
SICStus sub-process.  There are examples of writing the parent process
using Python, C#, Java, C, Prolog etc..  These examples provide
functionality that is similar to what is available in the
language-specific libraries, e.g. 'library(jasper)' and
'library(prologbeans)', but do so in a language-agnostic way.  The
collection has been part of SICStus Prolog since release 4.5.0, but was
made more visible in release 4.7.0.  The code is meant to demonstrate
possibilities of this process communication method.  It is not intended
for production use.

   The collection can be found in 'library/jsonrpc' and consists of a
server written in Prolog, 'library/jsonrpc/jsonrpc_server.pl', and
clients written in C, C#, Java, Prolog, Go, and Python,
'library/jsonrpc/clients/*'.

   Following is a number of sessions.  Each session has the same
structure.  The client process first creates a server subprocess, then
issues a number of requests to the server and reads the replies, finally
shuts down the server.  The interactions illustrate functionality like
state updates, determinate and nondeterminate Prolog queries,
backtracking, failures, and exceptions:

  1. Read the initial state.
  2. Set state to 4.
  3. Read current state.
  4. Increment current state.
  5. Increment current state again.
  6. Call 'member/2' and ask for the first solution.
  7. Ask for the next solution.
  8. Commit to the last solution.
  9. Call 'member/2' again and ask for the first solution.
  10. Ask for the next solution.
  11. Ask for the next solution.
  12. Ask for the next solution, which fails.
  13. Make a call that throws an error exception.
  14. Shut down the server.

   These sessions are using Linux or macOS, the '%' is the shell prompt.
On Windows starting the programs will be different but program outputs
will be very similar.  Recall that '$SP_APP_PATH' denotes the absolute
path to the SICStus development system.

   The clients are intentionally written to be very similar in
structure, and to have almost identical outputs, regardless of
implementation language.

   The first session is with the Python client:

     % python3 "$SP_LIBRARY_DIR/jsonrpc/clients/jsonrpc_client.py" "$SP_APP_PATH"
     state ==> State is None
     state:=4 ==> State was None
     state ==> State is 4

     once(Result is StateIn+1, StateOut=Result). ==> Result=5
     once(Result is StateIn+1, StateOut=Result). ==> Result=6

     Increment=5, once(Result is StateIn+Increment, StateOut=Result). ==> Result=11

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     cut ==> Result=None

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     retry ==> (next) Result=311
     retry ==> Prolog failed (this is expected)

     once(foo is bar). ==> Prolog threw an exception (this is expected): msg=Exception, data=type_error(evaluable,bar/0)

     quit ==> Result=Bye

   The next session is with the Prolog client:

     % sicstus --nologo --noinfo \
       -l "$SP_LIBRARY_DIR/jsonrpc/clients/jsonrpc_client.pl"
     state ==> State is @(null)
     state:=4 ==> State was @(null)
     state ==> State is 4

     once('Result is StateIn+1, StateOut=Result.'). ==> Result=5
     once('Result is StateIn+1, StateOut=Result.'). ==> Result=6

     Increment=5, once('Result is StateIn+Increment, StateOut=Result.'). ==> Result=11

     Multiplier=10, call('member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc.'). ==> First Result=111
     retry ==> (next) Result=211
     cut ==> Result=@(null)

     Multiplier=10, call('member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc.'). ==> First Result=111
     retry ==> (next) Result=211
     retry ==> (next) Result=311
     retry ==> Prolog failed (this is expected)

     once('foo is bar.'). ==> Prolog threw an exception (this is expected): Exception 'type_error(evaluable,bar/0)'

     quit ==> Result='Bye'

   The next session is with the Java client:

     % javac -d . "$SP_LIBRARY_DIR/jsonrpc/clients/JSONRPCClient.java"
     % jar cf JSONRPCClient.jar JSONRPCClient*.class
     % java -Dlogging=false -cp JSONRPCClient.jar \
       JSONRPCClient "$SP_APP_PATH"
     state ==> State is null
     state:=4 ==> State was null
     state ==> State is 4

     once(Result is StateIn+1, StateOut=Result). ==> Result=5
     once(Result is StateIn+1, StateOut=Result). ==> Result=6

     Increment=5, once(Result is StateIn+Increment, StateOut=Result). ==> Result=11

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     cut ==> Result=null

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     retry ==> (next) Result=311
     retry ==> Prolog failed (this is expected)

     once(foo is bar). ==> Prolog threw an exception (this is expected): "type_error(evaluable,bar/0)"

     quit ==> Result="Bye"

   The next session is with the C client:

     % cc "$SP_LIBRARY_DIR/jsonrpc/clients/jsonrpc_client.c" -o jsonrpc_client
     % ./jsonrpc_client "$SP_APP_PATH"

     state ==> State is null
     state:=4 ==> State was null
     state ==> State is 4

     once(Result is StateIn+1, StateOut=Result). ==> Result=5
     once(Result is StateIn+1, StateOut=Result). ==> Result=6

     Increment=5, once(Result is StateIn+Increment, StateOut=Result). ==> Result=11

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     cut ==> Result=null

     Multiplier=10, call(member(E,[10,20,30]), Inc is Multiplier*E, Result is StateIn+Inc). ==> First Result=111
     retry ==> (next) Result=211
     retry ==> (next) Result=311
     retry ==> Prolog failed (this is expected)

     once(foo is bar). ==> Prolog threw an exception (this is expected)

     quit ==> Result="Bye"

   As mentioned above, there are sample clients in other languages as
well.


File: sicstus.info,  Node: lib-linda,  Next: lib-lists,  Prev: lib-jsonrpc,  Up: The Prolog Library

10.23 Process Communication--'library(linda/[server,client])'
=============================================================

Linda is a concept for process communication.

   For an introduction and a deeper description, see [Carreiro &
Gelernter 89a] or [Carreiro & Gelernter 89b], respectively.

   One process is running as a server and one or more processes are
running as clients.  The processes are communicating with sockets and
supports networks.

   The server is in principle a blackboard on which the clients can
write ('out/1'), read ('rd/1') and remove ('in/1') data.  If the data is
not present on the blackboard, then the predicates suspend the process
until they are available.

   There are some more predicates besides the basic 'out/1', 'rd/1' and
'in/1'.  The 'in_noblock/1' and 'rd_noblock/1' does not suspend if the
data is not available--they fail instead.  A blocking fetch of a
conjunction of data can be done with 'in/2' or 'rd/2'.

   Example: A simple producer-consumer.  In client 1:
     producer :-
            produce(X),
            out(p(X)),
            producer.

     produce(X) :- .....

   In client 2:

     consumer :-
            in(p(A)),
            consume(A),
            consumer.

     consume(A) :- .....

   Example: Synchronization

            ...,
            in(ready),  %Waits here until someone does out(ready)
            ...,

   Example: A critical region

            ...,
            in(region_free),  % wait for region to be free
            critical_part,
            out(region_free), % let next one in
            ...,

   Example: Reading global data

            ...,
            rd(data(Data)),
            ...,

     or, without blocking:
            ...,
            rd_noblock(data(Data)) ->
                  do_something(Data)
            ;     write('Data not available!'),nl
            ),
            ...,

   Example: Waiting for one of several events

            ...,
            in([e(1),e(2),...,e(n)], E),
     %  Here is E instantiated to the first tuple that became available
            ...,

* Menu:

* lib-linda-server:: Linda Server
* lib-linda-client:: Linda Client


File: sicstus.info,  Node: lib-linda-server,  Next: lib-linda-client,  Up: lib-linda

10.23.1 Linda Server
--------------------

The server is the process running the "blackboard process".  It is an
ordinary SICStus process, which can be run on a separate machine if
necessary.

   To load the package, enter the query

     | ?- use_module(library('linda/server')).

and start the server with 'linda/[0,1]'.

'linda'

     Starts a Linda-server in this SICStus.  The network address is
     written to the current output stream as HOST:PORTNUMBER.

'linda(:OPTIONS)'
     Starts a Linda-server in this SICStus.  Each option on the list
     OPTIONS is one of
     'ADDRESS-GOAL'
          where ADDRESS must be unifiable with HOST:PORT and GOAL must
          be instantiated to a goal.

          When the linda server is started, HOST and PORT are bound to
          the server host and port respectively and the goal GOAL is
          called.  A typical use of this would be to store the
          connection information in a file so that the clients can find
          the server to connect to.

          For backward compatibility, if OPTIONS is not a list, then it
          is assumed to be an option of the form 'ADDRESS-GOAL'.

          Before release 3.9.1, GOAL needed an explicit module prefix to
          ensure it was called in the right module.  This is no longer
          necessary since 'linda/1' is now a meta-predicate.

     'accept_hook(CLIENT,STREAM,GOAL)'
          When a client attempts to connects to the server CLIENT and
          STREAM will be bound to the IP address of the client and the
          socket stream connected to the client, respectively.  The GOAL
          is then called, and if it succeeds, then the client is allowed
          to connect.  If GOAL fails, then the server will close the
          stream and ignore the connection request.  A typical use of
          this feature would be to restrict the addresses of the clients
          allowed to connect.  If you require bullet proof security,
          then you would probably need something more sophisticated.

     Example:
          | ?- linda([(Host:Port)-mypred(Host,Port),
                      accept_hook(C,S,should_accept(C,S))]).

     will call 'mypred/2' when the server is started.  'mypred/2' could
     start the client-processes, save the address for the clients etc.
     Whenever a client attempts to connect from a host with IP address
     ADDR, a bi-directional socket stream STREAM will be opened to the
     client, and 'should_accept(ADDR,STREAM)' will be called to
     determine if the client should be allowed to connect.


File: sicstus.info,  Node: lib-linda-client,  Prev: lib-linda-server,  Up: lib-linda

10.23.2 Linda Client
--------------------

The clients are one or more SICStus processes that have connection(s) to
the server.

   To load the package, enter the query

     | ?- use_module(library('linda/client')).

   Some of the following predicates fail if they do not receive an
answer from the Linda-server in a reasonable amount of time.  That time
is set with the predicate 'linda_timeout/2'.

'linda_client(+ADDRESS)'

     Establishes a connection to a Linda-server specified by ADDRESS.
     The ADDRESS is of the format HOST:PORTNUMBER as given by
     'linda/[0,1]'.

     It is not possible to be connected to two Linda-servers at the same
     time.

     This predicate can fail due to a timeout.

'close_client'

     Closes the connection to the server.

'shutdown_server/0'

     Sends a Quit signal to the server, which immediately stops
     accepting new connections before 'shutdown_server/0' returns.  The
     server continues running after receiving this signal, processing
     requests from existing clients, until such time as all the clients
     have closed their connections.  It is up to the clients to tell
     each other to quit.  When all the clients are done, the server
     stops (i.e. 'linda/[0,1]' succeeds).  Courtesy of Malcolm Ryan.
     Note that 'close_client/0' should be called _after_
     'shutdown_server/0'.  'shutdown_server/0' will raise an error if
     there is no connection between the client and the server.

     The behavior of 'shutdown_server/0' changed in SICStus Prolog 4.2.
     In previous releases the server continued to accept new connections
     after being told to shutdown.  Now it immediately stops listening
     for new connections and releases the listening socket and these
     server actions happens before the client returns from
     'shutdown_server/0'.

'linda_timeout(?OLDTIME, ?NEWTIME)'

     This predicate controls Linda's timeout.  OLDTIME is unified with
     the old timeout and then timeout is set to NEWTIME.  The value is
     either 'off' or of the form SECONDS:MILLISECONDS.  The former value
     indicates that the timeout mechanism is disabled, that is, eternal
     waiting.  The latter form is the TIMEOUT-TIME.

'out(+TUPLE)'

     Places the tuple TUPLE in Linda's tuple-space.

'in(?TUPLE)'

     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, then the predicate blocks until it is available (that is,
     someone performs an 'out/1').

'in_noblock(?TUPLE)'

     Removes the tuple TUPLE from Linda's tuple-space if it is there.
     If not, then the predicate fails.

     This predicate can fail due to a timeout.

'in(+TUPLELIST, ?TUPLE)'

     As 'in/1' but succeeds when either of the tuples in TUPLELIST is
     available.  TUPLE is unified with the fetched tuple.  If that
     unification fails, then the tuple is _not_ reinserted in the
     tuple-space.

'rd(?TUPLE)'

     Succeeds if TUPLE is available in the tuple-space, suspends
     otherwise until it is available.  Compare this with 'in/1': the
     tuple is _not_ removed.

'rd_noblock(?TUPLE)'

     Succeeds if TUPLE is available in the tuple-space, fails otherwise.

     This predicate can fail due to a timeout.

'rd(+TUPLELIST, ?TUPLE)'
     As 'in/2' but does not remove any tuples.

'bagof_rd_noblock(?TEMPLATE, +TUPLE, ?BAG)'

     BAG is the list of all instances of TEMPLATE such that TUPLE exists
     in the tuple-space.

     The behavior of variables in TUPLE and TEMPLATE is as in 'bagof/3'.
     The variables could be existentially quantified with '^/2' as in
     'bagof/3'.

     The operation is performed as an atomic operation.

     This predicate can fail due to a timeout.

     Example: Assume that only one client is connected to the server and
     that the tuple-space initially is empty.
          | ?- out(x(a,3)), out(x(a,4)), out(x(b,3)), out(x(c,3)).

          | ?- bagof_rd_noblock(C-N, x(C,N), L).

          C = _32,
          L = [a-3,a-4,b-3,c-3],
          N = _52

          | ?- bagof_rd_noblock(C, N^x(C,N), L).

          C = _32,
          L = [a,a,b,c],
          N = _48



File: sicstus.info,  Node: lib-lists,  Next: lib-lmdb,  Prev: lib-linda,  Up: The Prolog Library

10.24 List Operations--'library(lists)'
=======================================

This library module provides operations on lists.  Exported predicates:

'select(?ELEMENT, ?SET, ?RESIDUE)'

     is true when SET is a list, ELEMENT occurs in SET, and RESIDUE is
     everything in SET except ELEMENT (things stay in the same order).
'selectchk(+ELEMENT, +SET, ?RESIDUE)'

     is to 'select/3' what 'memberchk/2' is to 'member/2'.  That is, it
     locates the first occurrence of ELEMENT in SET, and deletes it,
     giving RESIDUE.  It is steadfast in RESIDUE.
'append(+LISTOFLISTS, -LIST)'

     is true when LISTOFLISTS is a list [L1,...,LN] of lists, LIST is a
     list, and appending L1, ..., LN together yields LIST.  LISTOFLISTS
     _must_ be a proper list.  Additionally, either LIST should be a
     proper list, or each of L1, ..., LN should be a proper list.  The
     behavior on non-lists is undefined.  LISTOFLISTS must be proper
     because for any given solution, infinitely many more can be
     obtained by inserting nils ([]) into LISTOFLIST.  Could be defined
     as:

          append(Lists, Appended) :-
          	(   foreach(List,Lists),
          	    fromto(Appended,S0,S,[])
          	do  append(List, S, S0)
          	).
'append(?PREFIX, ?TAIL1, ?LIST1, ?TAIL2, ?LIST2)'
     is true when 'append(PREFIX, TAIL1, LIST1)' and 'append(PREFIX,
     TAIL2, LIST2)' are both true.  You could call 'append/3' twice, but
     that is order- dependent.  This will terminate if PREFIX is a
     proper list or if either LIST1 or LIST2 is a proper list.
'correspond(?X, ?XLIST, ?YLIST, ?Y)'

     is true when XLIST and YLIST are lists, X is an element of XLIST, Y
     is an element of YLIST, and X and Y are in similar places in their
     lists.  No relation is implied between other elements of XLIST and
     YLIST.  For a similar predicate without the cut, see 'select/4'.
'delete(+LIST, +KILL, -RESIDUE)'

     is true when LIST is a list, in which KILL may or may not occur,
     and RESIDUE is a copy of LIST with all elements equal to KILL
     deleted.  To extract a single copy of KILL, use 'select(KILL, LIST,
     RESIDUE)'.  KILL and the elements of LIST should be sufficiently
     instantiated for '\=' to be sound.  Could be defined as:

          delete(List, Kill, Residue) :-
          	(   foreach(X,List),
          	    fromto(Residue,S0,S,[]),
          	    param(Kill)
          	do  (X = Kill -> S0 = S ; S0 = [X|S])
          	).
'delete(+LIST, +KILL, +COUNT, -RESIDUE)'
     is true when LIST is a list, in which KILL may or may not occur,
     and COUNT is a non-negative integer, and RESIDUE is a copy of LIST
     with the first COUNT elements equal to KILL deleted.  If LIST has
     fewer than COUNT elements equal to COUNT, all of them are deleted.
     KILL and the elements of LIST should be sufficiently instantiated
     for '\=' to be sound.
'is_list(+LIST)'

     succeeds when LIST is a proper list.  That is, LIST is nil ([]) or
     a cons cell ([HEAD|TAIL]) whose TAIL is a proper list.  A variable,
     or a list whose final tail is a variable, or a cyclic list, will
     fail this test.
'keys_and_values(?[K1-V1,...,KN-VN], ?[K1,...,KN], ?[V1,...,VN])'

     is true when its arguments look like the picture above.  It is
     meant for splitting a list of KEY-VALUE pairs (such as 'keysort/2'
     wants and produces) into separate lists of KEYS and of VALUES.  It
     may just as well be used for building a list of pairs from a pair
     of lists.  In fact one usually wants just the keys or just the
     values, but you can supply '_' as the other argument.  For example,
     suppose you wanted to sort a list without having duplicates
     removed.  You could do
              keys_and_values(RawPairs, RawKeys, _),
              keysort(RawPairs, OrdPairs),
              keys_and_values(OrdPairs, OrdKeys, _).
     Could be defined as:

          keys_and_values([], [], []).
          keys_and_values([Key-Value|Pairs], [Key|Keys], [Value|Values]) :-
          	keys_and_values(Pairs, Keys, Values).
'last(+LIST, -LAST)'

     is true when LIST is a LIST and LAST is its last element.  There is
     also a 'last(?FORE, ?LAST, ?LIST)' whose argument order matches
     append/3.  This could be defined as
              last(L, X) :- append(_, [X], L).
'nextto(?X, ?Y, ?LIST)'

     is true when X and Y appear side-by-side in LIST.  It could be
     written as
              nextto(X, Y, List) :- append(_, [X,Y|_], List).
     It may be used to enumerate successive pairs from the list.  LIST
     should be proper, otherwise 'nextto/3' will generate it.
'nth0(?N, ?LIST, ?ELEM)'

     is true when ELEM is the Nth member of LIST, counting the first as
     element 0.  That is, throw away the first N elements and unify ELEM
     with the next.  E.g.  'nth0(0, [H|T], H)'.  Either N should be an
     integer, or LIST should be proper.
'nth1(?N, ?LIST, ?ELEMENT)'

     is true when ELEM is the NTH member of LIST, counting the first as
     element 1.  That is, throw away the first N-1 elements and unify
     ELEM with the next element (the NTH).  E.g.  'nth1(1, [H|T], H)'.
     This is just like 'nth0/3' except that it counts from 1 instead of
     0.  Either N should be an integer, or LIST should be proper.
'nth0(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 0, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 0) element of REST, when it yields
     LIST, e.g.  'nth0(2, List, c, [a,b,d,e])' unifies LIST with
     '[a,b,c,d,e]'.  This can be seen as inserting ELEM _after_ the NTH
     element of REST if you count from 1 rather than 0.  Either N should
     be an integer, or LIST or REST should be proper.
'nth1(?N, ?LIST, ?ELEM, ?REST)'
     unifies ELEM with the NTH element of LIST, counting from 1, and
     REST with the other elements.  It can be used to select the NTH
     element of LIST (yielding ELEM and REST), or to insert ELEM
     _before_ the NTH (counting from 1) element of REST, when it yields
     LIST, e.g.  'nth1(2, List, b, [a,c,d,e])' unifies LIST with
     '[a,b,c,d,e]'.  Either N should be an integer, or LIST or REST
     should be proper.
'one_longer(?LONGER, ?SHORTER)'

     is true when
              length(Longer,N), length(Shorter,M), succ(M,N)
     for some integers M, N.  It was written to make '{nth0,nth1}/4'
     able to find the index, just as 'same_length/2' is useful for
     making things invertible.
'perm(+LIST, ?PERM)'

     is true when LIST and PERM are permutations of each other.  The
     main use of 'perm/2' is to generate permutations.  You should not
     use this predicate in new programs; use 'permutation/2' instead.
     LIST must be a proper list.  PERM may be partly instantiated.
'permutation(?LIST, ?PERM)'

     is true when LIST and PERM are permutations of each other.  Unlike
     'perm/2', it will work even when LIST is not a proper list.  Any
     way, it works by generating permutations of LIST and unifying them
     with PERM.  Be careful: this is quite efficient, but the number of
     permutations of an N-element list is N!, and even for a 7-element
     list that is 5040.
'perm2(?A,?B, ?C,?D)'

     is true when {A,B} = {C,D}.  It is very useful for writing pattern
     matchers over commutative operators.
'proper_length(+LIST, ?LENGTH)'

     succeeds when LIST is a proper list, binding LENGTH to its length.
     That is, 'is_list(List), length(List, Length)'.  Will fail for
     cyclic lists.
'remove_dups(+LIST, ?PRUNED)'

     removes duplicated elements from LIST, which should be a proper
     list.  If LIST has non-ground elements, PRUNED may contain elements
     which unify; two elements will remain separate iff there is a
     substitution which makes them different.  E.g.  [X,X] -> [X] but
     [X,Y] -> [X,Y].  The surviving elements, by ascending standard
     order, is unified with PRUNED.
'reverse(?LIST, ?REVERSED)'

     is true when LIST and REVERSED are lists with the same elements but
     in opposite orders.  Either LIST or REVERSED should be a proper
     list: given either argument the other can be found.  If both are
     incomplete 'reverse/2' can backtrack forever trying ever longer
     lists.
'rev(+LIST, ?REVERSED)'

     is a version of 'reverse/2' which only works one way around.  Its
     LIST argument must be a proper list whatever REVERSED is.  You
     should use 'reverse/2' in new programs, though 'rev/2' is faster
     when it is safe to use it.
'same_length(?LIST1, ?LIST2)'

     is true when LIST1 and LIST2 are both lists and have the same
     number of elements.  No relation between the values of their
     elements is implied.  It may be used to generate either list given
     the other, or indeed to generate two lists of the same length, in
     which case the arguments will be bound to lists of length 0, 1, 2,
     ...  If either LIST1 or LIST2 is bound to a proper list,
     same_length is determinate and terminating.
'same_length(?LIST1, ?LIST2, ?LENGTH)'
     is true when LIST1 and LIST2 are both lists, LENGTH is a
     non-negative integer, and both LIST1 and LIST2 have exactly LENGTH
     elements.  No relation between the elements of the lists is
     implied.  If LENGTH is instantiated, or if either LIST1 or LIST2 is
     bound to a proper list, same_length is determinate and terminating.
'select(?X, ?XLIST, ?Y, ?YLIST)'

     is true when X is the KTH member of XLIST and Y the KTH element of
     YLIST for some K, and apart from that XLIST and YLIST are the same.
     You can use it to replace X by Y or vice versa.  Either XLIST or
     YLIST should be a proper list.
'selectchk(?X, +XLIST, ?Y, +YLIST)'

     is to 'select/4' as 'memberhck/2' is to 'member/2'.  That is, it
     finds the first K such that X unifies with the KTH element of XLIST
     and Y with the KTH element of YLIST, and it commits to the bindings
     thus found.  If you have KEYS and VALUES in "parallel" lists, you
     can use this to find the VALUE associated with a particular KEY
     (much better methods exist).  Except for argument order, this is
     identical to 'correspond/4', but 'selectchk/4' is a member of a
     coherent family.  Note that the arguments are like the arguments of
     'memberchk/2', twice.
'shorter_list(?SHORT, ?LONG)'

     is true when SHORT is a list is strictly shorter than LONG.  LONG
     doesn't have to be a proper list provided it is long enough.  This
     can be used to generate lists shorter than LONG, lengths 0, 1, 2...
     will be tried, but backtracking will terminate with a list that is
     one element shorter than LONG.  It cannot be used to generate lists
     longer than SHORT, because it doesn't look at all the elements of
     the longer list.
'subseq(?SEQUENCE, ?SUBSEQUENCE, ?COMPLEMENT)'

     is true when SUBSEQUENCE and COMPLEMENT are both subsequences of
     the list SEQUENCE (the order of corresponding elements being
     preserved) and every element of SEQUENCE which is not in
     SUBSEQUENCE is in the COMPLEMENT and vice versa.  That is,
     'length(Sequence) = length(SubSequence)+length(Complement)', e.g.
     'subseq([1,2,3,4], [1,3,4], [2])'.  This was written to generate
     subsets and their complements together, but can also be used to
     interleave two lists in all possible ways.
'subseq0(+SEQUENCE, ?SUBSEQUENCE)'

     is true when SUBSEQUENCE is a subsequence of SEQUENCE, but may be
     SEQUENCE itself.  Thus 'subseq0([a,b], [a,b])' is true as well as
     'subseq0([a,b], [a])'.  SEQUENCE must be a proper list, since there
     are infinitely many lists with a given SUBSEQUENCE.
          ?- setof(X, subseq0([a,b,c],X), Xs).
          Xs = [[],[a],[a,b],[a,b,c],[a,c],[b],[b,c],[c]]
          ?- bagof(X, subseq0([a,b,c,d],X), Xs).
          Xs = [[a,b,c,d],[b,c,d],[c,d],[d],[],[c],[b,d],[b],[b,c],[a,c,d],
                [a,d],[a],[a,c],[a,b,d],[a,b],[a,b,c]]
'subseq1(+SEQUENCE, ?SUBSEQUENCE)'

     is true when SUBSEQUENCE is a proper subsequence of SEQUENCE, that
     is it contains at least one element less.  SEQUENCE must be a
     proper list, as SUBSEQUENCE does not determine SEQUENCE.
'sumlist(+NUMBERS, ?TOTAL)'

     is true when NUMBERS is a list of integers, and TOTAL is their sum.
     NUMBERS should be a proper list.  Could be defined as:

          sumlist(Numbers, Total) :-
          	(   foreach(X,Numbers),
          	    fromto(0,S0,S,Total)
          	do  S is S0+X
          	).
'transpose(?X, ?Y)'

     is true when X is a list of the form
     [[X11,...,X1M],...,[XN1,...,XNM]] and Y is its transpose, that is,
     Y = [[X11,...,XN1],...,[X1M,...,XNM]] We insist that both lists
     should have this rectangular form, so that the predicate can be
     invertible.  For the same reason, we reject empty arrays with M = 0
     or N = 0.
'append_length(?PREFIX, ?SUFFIX, ?LIST, ?LENGTH)'

     is true when
              append(Prefix, Suffix, List), length(Prefix, Length).
     The normal use of this is to split a LIST into a PREFIX of a given
     LENGTH and the corresponding SUFFIX, but it can be used any way
     around provided that LENGTH is instantiated, or PREFIX is a proper
     list, or LIST is a proper list.
'append_length(?SUFFIX, ?LIST, ?LENGTH)'
     is true when there exists a list PREFIX such that
     'append_length(PREFIX, SUFFIX, LIST, LENGTH)' is true.  When you
     don't want to know the PREFIX, you should call this predicate,
     because it doesn't construct the PREFIX argument, which
     'append_length/4' would do.
'prefix_length(?LIST, ?PREFIX, ?LENGTH)'

     is true when
              prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that LENGTH
     is instantiated, or PREFIX is a proper list, or LIST is a proper
     list.  It is identical in effect to 'append_length(Prefix, _, List,
     Length)'.
'proper_prefix_length(?LIST, ?PREFIX, ?LENGTH)'

     is true when
              proper_prefix(List, Prefix) &
              length(Prefix, Length).
     The normal use of this is to find the first LENGTH elements of a
     given LIST, but it can be used any way around provided that LENGTH
     is instantiated, or PREFIX is a proper list, or LIST is a proper
     list.  It is logically equivalent to 'prefix(Prefix, List, Length),
     Length > 0'.
'suffix_length(+LIST, ?SUFFIX, ?LENGTH)'

     is true when
              suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination, LIST must be a
     proper list.  The predicate suffix/2 has the same requirement.  If
     LENGTH is instantiated or SUFFIX is a proper list, this predicate
     is determinate.
'proper_suffix_length(+LIST, ?SUFFIX, ?LENGTH)'

     is true when
              proper_suffix(List, Suffix) &
              length(Suffix, Length).
     The normal use of this is to return the last LENGTH elements of a
     given LIST.  For this to be sure of termination, LIST must be a
     proper list.  The predicate proper_suffix/2 has the same
     requirement.  If LENGTH is instantiated or SUFFIX is a proper list,
     this predicate is determinate.
'rotate_list(+AMOUNT, ?LIST, ?ROTATED)'

     is true when LIST and ROTATED are lists of the same length, and
              append(Prefix, Suffix, List) &
              append(Suffix, Prefix, Rotated) &
              (   Amount >= 0 & length(Prefix, Amount)
              |   Amount =< 0 & length(Suffix, Amount)
              ).
     That is to say, LIST rotated LEFT by AMOUNT is ROTATED.  If either
     LIST or ROTATED is bound to a proper list, rotate_list is
     determinate.
'rotate_list(?LIST, ?ROTATED)'
     is true when 'rotate_list(1, List, Rotated)', but is a bit less
     heavy-handed.  'rotate_list(X, Y)' rotates X left one place
     yielding Y.  'rotate_list(Y, X)' rotates X right one place yielding
     Y.  Either LIST or ROTATED should be a proper list, in which case
     rotate_list is determinate and terminating.
'sublist(+WHOLE, ?PART, ?BEFORE, ?LENGTH, ?AFTER)'
'sublist(+WHOLE, ?PART, ?BEFORE, ?LENGTH)'
'sublist(+WHOLE, ?PART, ?BEFORE)'

     is true when
        * WHOLE is a list - it must be proper already
        * PART is a list
        * WHOLE = ALPHA || PART || OMEGA
        * 'length(ALPHA, BEFORE)'
        * 'length(PART, LENGTH)'
        * 'length(OMEGA, AFTER)'
'cons(?HEAD, ?TAIL, ?LIST)'

     is true when HEAD is the head of LIST and TAIL is its tail.  i.e.
     'append([Head], Tail, List)'.  No restrictions.
'last(?FORE, ?LAST, ?LIST)'

     is true when LAST is the last element of LIST and FORE is the list
     of preceding elements, e.g.  'append(Fore, [Last], List)'.  FORE or
     LAST should be proper.  It is expected that LIST will be proper and
     FORE unbound, but it will work in reverse too.
'head(?LIST, ?HEAD)'

     is true when LIST is a non-empty list and HEAD is its head.  A list
     has only one head.  No restrictions.
'tail(?LIST, ?TAIL)'

     is true when LIST is a non-empty list and TAIL is its tail.  A list
     has only one tail.  No restrictions.
'prefix(?LIST, ?PREFIX)'

     is true when LIST and PREFIX are lists and PREFIX is a prefix of
     LIST.  It terminates if either argument is proper, and has at most
     N+1 solutions.  Prefixes are enumerated in ascending order of
     length.
'proper_prefix(?LIST, ?PREFIX)'

     is true when LIST and PREFIX are lists and PREFIX is a proper
     prefix of LIST.  That is, PREFIX is a prefix of LIST but is not
     LIST itself.  It terminates if either argument is proper, and has
     at most N solutions.  Prefixes are enumerated in ascending order of
     length.
'suffix(?LIST, ?SUFFIX)'

     is true when LIST and SUFFIX are lists and SUFFIX is a suffix of
     LIST.  It terminates only if LIST is proper, and has at most N+1
     solutions.  Suffixes are enumerated in descending order of length.
'proper_suffix(?LIST, ?SUFFIX)'

     is true when LIST and SUFFIX are lists and SUFFIX is a proper
     suffix of LIST.  That is, SUFFIX is a suffix of LIST but is not
     LIST itself.  It terminates only if LIST is proper, and has at most
     N solutions.  Suffixes are enumerated in descending order of
     length.
'segment(?LIST, ?SEGMENT)'

     is true when LIST and SEGMENT are lists and SEGMENT is a segment of
     LIST.  That is, LIST = _ <> SEGMENT <> _ .  Terminates only if LIST
     is proper.  If SEGMENT is proper it enumerates all solutions.  If
     neither argument is proper, it would have to diagonalize to find
     all solutions, but it doesn't, so it is then incomplete.  If
     SEGMENT is proper, it has at most N+1 solutions.  Otherwise, it has
     at most (1/2)(N+1)(N+2) solutions.
'proper_segment(?LIST, ?SEGMENT)'

     is true when LIST and SEGMENT are lists and SEGMENT is a proper
     segment of LIST.  It terminates only if LIST is proper.  The only
     solution of 'segment/2' which is not a solution of
     'proper_segment/2' is 'segment(List,List)'.  So 'proper_segment/2'
     has one solution fewer.
'cumlist(:PRED, +[X1,...,XN], ?V0, ?[V1,...,VN])'
'cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], ?V0, ?[V1,...,VN])'
'cumlist(:PRED, +[X1,...,XN], +[Y1,...,YN], +[Z1,...,ZN], ?V0, ?[V1,...,VN])'

     'cumlist/4' maps a ternary predicate PRED down the list [X1,...,XN]
     just as 'scanlist/4' does, and returns a list of the results.  It
     terminates when the lists runs out.  If PRED is bidirectional, it
     may be used to derive [X1...XN] from V0 and [V1...VN], e.g.
     'cumlist(plus, [1,2,3,4], 0, /* -> */ [1,3,6,10])' and
     'cumlist(plus, [1,1,1,1], /* <- */ 0, [1,2,3,4])'.  Could be
     defined as:

          cumlist(Pred, Xs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,V1,V)
          	).

          cumlist(Pred, Xs, Ys, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,V1,V)
          	).

          cumlist(Pred, Xs, Ys, Zs, V0, Cum) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    foreach(V,Cum),
          	    fromto(V0,V1,V,_),
          	    param(Pred)
          	do  call(Pred,X,Y,Z,V1,V)
          	).
'maplist(:PRED, +LIST)'

     succeeds when PRED(X) succeeds for each element X of LIST.  LIST
     should be a proper list.  Could be defined as:

          maplist(Pred, Xs) :-
          	(   foreach(X,Xs),
          	    param(Pred)
          	do  call(Pred, X)
          	).
'maplist(:PRED, +OLDLIST, ?NEWLIST)'
     succeeds when PRED(OLD,NEW) succeeds for each corresponding OLD in
     OLDLIST, NEW in NEWLIST.  Either OLDLIST or NEWLIST should be a
     proper list.  Could be defined as:

          maplist(Pred, Xs, Ys) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    param(Pred)
          	do  call(Pred, X, Y)
          	).
'maplist(:PRED, +XS, ?YS, ?ZS)'
     is true when XS, YS, and ZS are lists of equal length, and PRED(X,
     Y, Z) is true for corresponding elements X of XS, Y of YS, and Z of
     ZS.  At least one of XS, YS, and ZS should be a proper list.  Could
     be defined as:

          maplist(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    param(Pred)
          	do  call(Pred, X, Y, Z)
          	).
'map_product(Pred, Xs, Ys, PredOfProduct)'

     Just as 'maplist(P, Xs, L)' is the analogue of Miranda's
              let L = [ P x | x <- Xs ]
     so 'map_product(P, Xs, Ys, L)' is the analogue of Miranda's
              let L = [ P x y | x <- Xs; y <- Ys ]
     That is, if XS = [X1,...,XM], YS = [Y1,...,YN], and P(XI,YJ,ZIJ), L
     = [Z11,...,Z1N,Z21,...,Z2N,...,ZM1,...,ZMN].  It is as if we formed
     the Cartesian product of XS and YS and applied P to the (XI,YJ)
     pairs.  XS and YS should be proper lists.  Could be defined as:

          map_product(Pred, Xs, Ys, Zs) :-
          	(   foreach(X,Xs),
          	    fromto(Zs,S0,S,[]),
          	    param([Ys,Pred])
          	do  (   foreach(Y,Ys),
          		fromto(S0,[Z|S1],S1,S),
          		param([X,Pred])
          	    do  call(Pred, X, Y, Z)
          	    )
          	).
'scanlist(:PRED, [X1,...,XN], ?V1, ?V)'
'scanlist(:PRED, [X1,...,XN], [Y1,...,YN], ?V1, ?V)'
'scanlist(:PRED, [X1,...,XN], [Y1,...,YN], [Z1,...,ZN], ?V1, ?V)'

     'scanlist/4' maps a ternary relation PRED down a list.  The
     computation is PRED(X1,V1,V2), PRED(X2,V2,V3), ..., PRED(XN,VN,V)
     So if PRED is 'plus/3', 'scanlist(plus, [X1,...,Xn], 0, V)' puts
     the sum of the list elements in V.  Note that the order of the
     arguments passed to Pred is the same as the order of the arguments
     following Pred.  This also holds for scanlist/5 and scanlist/6,
     e.g.  scanlist(Pred, Xs, Ys, Zs, V1, V) calls Pred(X3,Y3,Z3,V3,V4).
     Could be defined as:

          scanlist(Pred, Xs, V0, V) :-
          	(   foreach(X,Xs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, V1, V2)
          	).

          scanlist(Pred, Xs, Ys, Zs, V0, V) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(V0,V1,V2,V),
          	    param(Pred)
          	do  call(Pred, X, Y, Z, V1, V2)
          	).
'some(:PRED, +LIST)'

     succeeds when PRED(ELEM) succeeds for some ELEM in LIST.  It will
     try all ways of proving PRED for each ELEM, and will try each ELEM
     in the LIST.  'somechk/2' is to 'some/2' as 'memberchk/2' is to
     'member/2'.
              member(X,L)     <-> some(=(X), L).
              memberchk(X, L) <-> somechk(=(X), L).
              some(Pred,L)    <-> member(X, L), call(Pred,X).
     This acts on backtracking like member/2; List should be a proper
     list.
'some(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.
'some(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZI) is true for some I.
'somechk(:PRED, +[X1,...,XN])'

     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to the
     first solution it finds (like 'memberchk/2').
'somechk(:PRED, +[X1,...,XN], ?[Y1,...,YN], ?[Z1,...,ZN])'
     is true when PRED(XI, YI, ZN) is true for some I, and it commits to
     the first solution it finds (like 'memberchk/2').
'convlist(:REWRITE, +OLDLIST, ?NEWLIST)'

     is a sort of hybrid of 'maplist/3' and 'include/3'.  Each element
     of NEWLIST is the image under REWRITE of some element of OLDLIST,
     and order is preserved, but elements of OLDLIST on which REWRITE is
     undefined (fails) are not represented.  Thus if 'foo(K,X,Y) :-
     integer(X), Y is X+K.' then 'convlist(foo(1), [1,a,0,joe(99),101],
     [2,1,102]).'  OLDLIST should be a proper list.  Could be defined
     as:

          convlist(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,N) -> S0 = [N|S] ; S0 = S)
          	).
'exclude(:PRED, +XS, ?SUBLIST)'
'exclude(:PRED, +XS, +YS, ?SUBLIST)'
'exclude(:PRED, +XS, +YS, +ZS, ?SUBLIST)'

     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _false_.
     That is, it removes all the elements satisfying PRED.  XS, YS or ZS
     should be a proper list.  Could be defined as:

          exclude(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = S ; S0 = [X|S])
          	).

          exclude(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = S ; S0 = [X|S])
          	).
'include(:PRED, +XS, ?SUBLIST)'
'include(:PRED, +XS, +YS, ?SUBLIST)'
'include(:PRED, +XS, +YS, +ZS, ?SUBLIST)'

     succeeds when SUBLIST is the sublist of XS containing all the
     elements XI[,YI[,ZI]] for which PRED(XI[,YI[,ZI]]) is _true_.  That
     is, it retains all the elements satisfying PRED.  XS, YS or ZS
     should be a proper list.  Could be defined as:

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, News) :-
          	(   foreach(X,Xs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y) -> S0 = [X|S] ; S0 = S)
          	).

          include(Pred, Xs, Ys, Zs, News) :-
          	(   foreach(X,Xs),
          	    foreach(Y,Ys),
          	    foreach(Z,Zs),
          	    fromto(News,S0,S,[]),
          	    param(Pred)
          	do  (call(Pred,X,Y,Z) -> S0 = [X|S] ; S0 = S)
          	).
'partition(:PRED, +LIST, ?LESS, ?EQUAL, ?GREATER)'

     is a relative of 'include/3' and 'exclude/3' which has some
     pretensions to being logical.  For each X in LIST, we call
     PRED(X,R), and route X to LESS, EQUAL, or GREATER according as R is
     '<', '=', or '>' .
'group(:PRED, +LIST, ?FRONT, ?BACK)'

     is true when 'append(Front, Back, List), maplist(Pred, Front)', and
     FRONT is as long as possible.
'group(:PRED, +KEY, +LIST, ?FRONT, ?BACK)'
     is true when 'append(Front, Back, List), maplist(call(Pred,Key),
     Front)', and FRONT is as long as possible.  Strictly speaking we
     don't need it; 'group(call(Pred,Key), List, Front, Back)' would do
     just as well.
'group(:PRED, +LIST, ?LISTOFLISTS)'
     is true when 'append(ListOfLists, List)', each element of
     LISTOFLISTS has the form [HEAD|TAIL] such that 'group(Pred, Head,
     Tail, Tail, [])', and each element of LISTOFLISTS is as long as
     possible.  For example, if you have a keysorted list, and define
     'same_key(K-_, K-_)', then 'group(same_key, List, Buckets)' will
     divide LIST up into BUCKETS of pairs having the same key.
'ordered(+LIST)'

     is true when LIST is a list of terms [T1,T2,...,TN] such that for
     all K in 2..N TK-1 '@=<' TK, i.e.  T1 '@=<' T2 '@=<' T3 ...  The
     output of 'keysort/2' is always ordered, and so is that of
     'sort/2'.  Beware: just because a list is ordered does not mean
     that it is the representation of an ordered set; it might contain
     duplicates.
'ordered(+P, +[T1,T2,...,TN])'
     is true when P(T1,T2) & P(T2,T3) & ... That is, if you take P as a
     "comparison" predicate like '@=<', the list is ordered.  This is
     good for generating prefixes of sequences, e.g.  'L = [1,_,_,_,_],
     ordered(times(2), L)' yields 'L = [1,2,4,8,16]'.
'max_member(?XMAX, +[X1,...,XN])'

     unifies XMAX with the maximum (in the sense of '@=<') of X1,...,XN.
     The list should be proper.  If it is empty, the predicate fails
     quietly.  Could be defined as:

          max_member(Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum)
          	do  (X@=<M0 -> M = M0 ; M = X)
          	).
'min_member(?XMIN, +[X1,...,XN])'

     unifies XMIN with the minimum (in the sense of '@=<') of X1,...,XN.
     The list should be proper.  If it is empty, the predicate fails
     quietly.  Could be defined as:

          min_member(Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum)
          	do  (M0@=<X -> M = M0 ; M = X)
          	).
'max_member(:P, ?XMAX, +[X1,...,XN])'
     unifies XMAX with the maximum element of [X1,...,XN], as defined by
     the comparison predicate P, which should act like '@=<' .  The list
     should be proper.  If it is empty, the predicate fails quietly.
     Could be defined as:

          max_member(Pred, Maximum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Maximum),
          	    param(Pred)
          	do  (call(Pred,X,M0) -> M = M0 ; M = X)
          	).
'min_member(:P, ?XMIN, +[X1,...,XN])'
     unifies XMIN with the minimum element of [X1,...,XN], as defined by
     the comparison predicate P, which should act like '@=<' .  The list
     should be proper.  If it is empty, the predicate fails quietly.
     Could be defined as:

          min_member(Pred, Minimum, [Head|Tail]) :-
          	(   foreach(X,Tail),
          	    fromto(Head,M0,M,Minimum),
          	    param(Pred)
          	do  (call(Pred,M0,X) -> M = M0 ; M = X)
          	).
'select_min(?ELEMENT, +SET, ?RESIDUE)'

     unifies ELEMENT with the smallest (in the sense of '@=<') element
     of SET, and RESIDUE with a list of all the other elements.
'select_min(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the least ELEMENT of SET, i.e.  PRED(ELEMENT,X) for all X in
     SET.
'select_max(?ELEMENT, +SET, ?RESIDUE)'

     unifies ELEMENT with the (leftmost) maximum element of the SET, and
     RESIDUE to the other elements in the same order.
'select_max(:PRED, ?ELEMENT, +SET, ?RESIDUE)'
     find the greatest ELEMENT of SET, i.e.  PRED(X,ELEMENT) for all X
     in SET.
'increasing_prefix(?SEQUENCE, ?PREFIX, ?SUFFIX)'
     is true when 'append(Prefix, Suffix, Sequence)' and PREFIX,
     together with the first element of SUFFIX, forms a monotone
     non-decreasing sequence, and no longer Prefix will do.
     Pictorially,
          Sequence = [x1,...,xm,xm+1,...,xn]
          Prefix   = [x1,...,xm]
          Suffix     = [xm+1,...,xn]
          x1 <= x2 <= ... <= xm <= xm+1
          not xm+1 <= xm+2
     This is perhaps a surprising definition; you might expect that the
     first element of SUFFIX would be included in PREFIX.  However, this
     way, it means that if Sequence is a strictly decreasing sequence,
     the PREFIX will come out empty.
'increasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?SUFFIX)'

     is the same as 'increasing_prefix/3', except that it uses the
     binary relation ORDER in place of '@=<'.
'decreasing_prefix(?SEQUENCE, ?PREFIX, ?SUFFIX)'
'decreasing_prefix(:ORDER, ?SEQUENCE, ?PREFIX, ?SUFFIX)'

     is the same, except it looks for a decreasing prefix.  The order is
     the converse of the given order.  That is, where
     'increasing_prefix/[3,4]' check X(R)Y, these routines check Y(R)X.
'clumps(+ITEMS, -CLUMPS)'

     is true when CLUMPS is a list of lists such that
        * 'append(Clumps, Items)'
        * for each CLUMP in CLUMPS, all the elements of CLUMP are
          identical ('==')
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.
'keyclumps(+PAIRS, ?CLUMPS)'

     is true when PAIRS is a list of pairs and CLUMPS a list of lists
     such that
        * 'append(Clumps, Pairs)'
        * for each CLUMP in CLUMPS, all of the KEY-VALUE pairs in CLUMP
          have identical ('==') KEYS.
     PAIRS must be a proper list of pairs for which keysorting would
     have been sound.  In fact, it usually is the result of keysorting.
'clumped(+ITEMS, ?COUNTS)'

     is true when COUNTS is a list of ITEM-COUNT pairs such that if
     'clumps(Items, Clumps)', then each ITEM-COUNT pair in COUNTS
     corresponds to an element [ITEM/*1*/,...,ITEM/*COUNT*/] of CLUMPS.
     ITEMS must be a proper list of terms for which sorting would have
     been sound.  In fact, it usually is the result of sorting.
'keyclumped(+PAIRS, ?GROUPS)'

     is true when PAIRS is a list of KEY-ITEM pairs and GROUPS is a list
     of KEY-ITEMS pairs such that if 'keyclumps(Pairs, Clumps)', then
     for each K-[I1,...,IN] pair in GROUPS there is a [K-I1,...,K-IN]
     clump in CLUMPS.  PAIRS must be a proper list of pairs for which
     keysorting would have been sound.  In fact, it usually is the
     result of keysorting.


File: sicstus.info,  Node: lib-lmdb,  Next: lib-logarr,  Prev: lib-lists,  Up: The Prolog Library

10.25 External Storage of Terms (LMDB)--'library(lmdb)'
=======================================================

This library module handles storage and retrieval of terms on files.  By
using indexing, the store/retrieve operations are efficient also for
large data sets.  The package is an interface to the Lightning
Memory-Mapped Database Manager (LMDB). The API is quite similar to the
deprecated 'library(bdb)', and provides essentially the same
functionality, although some details differ.  The library module is part
of SICStus Prolog since release 4.7.0.

* Menu:

* LMDB Basics:: Basics
* LMDB Current Limitations:: Current Limitations
* Lightning Memory-Mapped Database Manager:: Lightning Memory-Mapped Database Manager
* LMDB DB-Spec Intro:: DB-Spec--Introduction
* LMDB Predicates:: Predicates
* LMDB Example Session:: Example Session
* LMDB DB-Spec Details:: DB-Spec--Details
* LMDB Export-Import:: Exporting and Importing a Database


File: sicstus.info,  Node: LMDB Basics,  Next: LMDB Current Limitations,  Up: lib-lmdb

10.25.1 Basics
--------------

The idea is to get a behavior similar to 'assert/1', 'retract/1' and
'clause/2', but the terms are stored on file instead of in primary
memory.  Like the Prolog database, LMDB will store variables with
attributes or with blocked goals as ordinary variables.

   The differences compared with the Prolog database are:

   * A "database" must be explicitly created, and occupies a file system
     directory.  A database must be opened before any access and closed
     after the last access.

   * The functors and the indexing specifications of the terms to be
     stored have to be given when the database is created.  It is
     possible to index on other parts of the term than just the functor
     and first argument.  (*note LMDB DB-Spec Details::).

   * Changes are not guaranteed to affect the database until it is
     explicitly "synced".


File: sicstus.info,  Node: LMDB Current Limitations,  Next: Lightning Memory-Mapped Database Manager,  Prev: LMDB Basics,  Up: lib-lmdb

10.25.2 Current Limitations
---------------------------

   * The terms are not necessarily fetched in the same order as they
     were stored.

   * The number of terms ever inserted in a database cannot exceed
     2^32-1.

   * A size limit must be set at creation time.  An LMDB database cannot
     grow beyond that limit.


File: sicstus.info,  Node: Lightning Memory-Mapped Database Manager,  Next: LMDB DB-Spec Intro,  Prev: LMDB Current Limitations,  Up: lib-lmdb

10.25.3 Lightning Memory-Mapped Database Manager (LMDB)
-------------------------------------------------------

LMDB is a software library that provides a transactional database in the
form of a key-value store.  LMDB stores arbitrary key/data pairs as byte
arrays, has a range-based search capability, and supports multiple data
items for a single key.  LMDB is fully thread-aware and supports
concurrent read/write access from multiple processes and threads.

   For details on the underlying technology, we refer to the OpenLDAP
home page <https://www.openldap.org/>.


File: sicstus.info,  Node: LMDB DB-Spec Intro,  Next: LMDB Predicates,  Prev: Lightning Memory-Mapped Database Manager,  Up: lib-lmdb

10.25.4 The DB-Spec--Informal Description
-----------------------------------------

The "db-spec" defines which functors are allowed and which parts of a
term are used for indexing in a database.  The syntax of a db-spec is a
skeletal goal with no module.  The db-spec is a list of atoms and
compound terms where the arguments are either '+' or '-'.  A term can be
inserted in the database if there is a spec in the spec list with the
same functor.

   Multilevel indexing is not supported, terms have to be "flattened".

   Every spec with the functor of the "indexed term" specifies an
indexing.  Every argument where there is a '+' in the spec is indexed
on.

   The idea of the db-spec is illustrated with a few examples.  (A
section further down explains the db-spec in a more formal way).

   Given a spec of '[f(+,-), .(+,-), g, f(-,+)]' the indexing works as
follows.  (The parts with indexing are underlined.)

TERM        STORE                   FETCH
'g(x,y)'    domain error            domain error
'f(A,B)'    'f(A,B)'                instantiation error
            '-'
'f(a,b)'    'f(a,b)  f(a,b)'        'f(a,b)'
            '- -     -   -'         '- -'
'[a,b]'     '.(a,.(b,[]))'          '.(a,.(b,[]))'
            '- -'                   '- -'
'g'         'g'                     'g'
            '-'                     '-'

   The specification '[f(+,-), f(-,+)]' is different from '[f(+,+)]'.
The first specifies that two indices are to be made whereas the second
specifies that only one index is to be made on both arguments of the
term.


File: sicstus.info,  Node: LMDB Predicates,  Next: LMDB Example Session,  Prev: LMDB DB-Spec Intro,  Up: lib-lmdb

10.25.5 Predicates
------------------

* Menu:

* LMDB Conventions:: Conventions
* LMDB Memory Leaks:: Memory Leaks
* LMDB The Predicates:: The Predicates


File: sicstus.info,  Node: LMDB Conventions,  Next: LMDB Memory Leaks,  Up: LMDB Predicates

10.25.5.1 Conventions
.....................

The following conventions are used in the predicate descriptions below.
   * The predicates that create and open databases can be given a list
     of options.  An OPTION is one of:
     'mapsize(S)'
          The mapsize, or size limit, of the database being created, in
          MiB. The default is 10MiB.

     'permission(S)'
          The UNIX permission for files of the database being created.
          Ignored for Windows.  The default is octal 664.

     'mode(S)'
          The access mode for the database being opened.  One of the
          atoms 'read' and 'write'.  If 'read' (the default), no updates
          are allowed.

   * DBREF is a reference to an open database.  It is returned when the
     database is opened.  The reference becomes invalid after the
     database has been closed.  The reference corresponds to the LMDB
     environment notion.  An environment physically consists of a
     directory containing the files needed to enable sharing databases
     between processes.

   * TERMREF is a reference to a term in a given database.  The
     reference is returned when a term is stored.  The reference stays
     valid even after the database has been closed and hence can be
     stored permanently as part of another term.  However, if such
     references are stored in the database, automatic compression of the
     database (using 'lmdb_compress/[2,3]') is not possible, in that
     case the user has to write their own compressing predicate.

   * SPECLIST is a description of the indexing scheme; *note The
     DB-Spec::.

   * TERM is any Prolog term.

   * ITERATOR is a non-backtrackable mutable object.  It can be used to
     iterate through a set of terms stored in a database.  The iterators
     are unidirectional.


File: sicstus.info,  Node: LMDB Memory Leaks,  Next: LMDB The Predicates,  Prev: LMDB Conventions,  Up: LMDB Predicates

10.25.5.2 Memory Leaks
......................

In order to avoid memory leaks, databases and iterators should always be
closed explicitly.  Consider using 'lmdb_with_db/[2,3]' and
'lmdb_with_iterator/3' to automate the closing/deallocation of these
objects.

     *Please note*: a database must not be closed while there are
     outstanding choices for some 'lmdb_fetch/3' or 'lmdb_enumerate/3'
     goal that refers to that database.  Outstanding choices can be
     removed with a cut ('!').


File: sicstus.info,  Node: LMDB The Predicates,  Prev: LMDB Memory Leaks,  Up: LMDB Predicates

10.25.5.3 The Predicates
........................

'lmdb_create(+PATH, +SPECLIST)'
'lmdb_create(+PATH, +SPECLIST, +OPTIONS)'

     Creates a brand new LMDB database with the given spec list.  PATH
     should be a file system path where a new directory can be created.
     If some file or directory already exists there, an exception is
     raised.
'lmdb_open(+PATH, -DBREF)'
'lmdb_open(+PATH, -DBREF, +OPTIONS)'

     Opens an existing database and unifies DBREF with its reference.
     PATH should be a file system path to the directory that holds the
     database.

     *Please note:* Only one DBREF may be connected to the same PATH at
     the same time in the same process.  I.e., you must not call
     'lmdb_open/2' twice with the same PATH without closing the DBREF
     before the second call.
'lmdb_with_db(+PATH, :GOAL)'
'lmdb_with_db(+PATH, :GOAL, +OPTIONS)'

     Opens an existing database, calls GOAL with its reference, as if by
     'call(Goal, DBRef)', and ensures that the database is closed
     afterwards.  GOAL may backtrack and succeed multiple times.  PATH
     should be a file system path to the directory that holds the
     database.

     *Please note:* see 'lmdb_open/2' for restrictions on opening the
     same PATH more than once at the same time.
'lmdb_close(+DBREF)'

     Closes the database referenced by DBREF.
'lmdb_store(+DBREF, +TERM, -TERMREF)'

     Stores TERM in the database DBREF.  TERMREF is unified with a
     corresponding term reference.  The functor of TERM must match the
     functor of a spec in the db-spec associated with DBREF.
'lmdb_fetch(+DBREF, ?TERM, ?TERMREF)'

     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     If TERMREF is not instantiated, both the functor and the
     instantiatedness of TERM must match a spec in the db-spec
     associated with DBREF.

     If TERMREF is instantiated, the referenced term is read and unified
     with TERM.

     If you simply want to find all matching terms, it is more efficient
     to use 'lmdb_findall/5' or 'lmdb_enumerate/3'.
'lmdb_erase(+DBREF, +TERMREF)'

     Deletes the term from the database DBREF that is referenced by
     TERMREF.
'lmdb_enumerate(+DBREF, ?TERM, -TERMREF)'

     Unifies TERM with a term from the database DBREF.  At the same
     time, TERMREF is unified with a corresponding term reference.
     Backtracking over the predicate unifies with all terms matching
     TERM.

     Implemented by linear search--the db-spec associated with DBREF is
     ignored.
'lmdb_findall(+DBREF, +TEMPLATE, +TERM, :GOAL, -BAG)'

     Unifies BAG with the list of instances of TEMPLATE in all proofs of
     GOAL found when TERM is unified with a matching term from the
     database DBREF.  Both the functor and the instantiatedness of TERM
     must match a spec in the db-spec associated with DBREF.
     Conceptually, this predicate is equivalent to 'findall(TEMPLATE,
     (lmdb_fetch(DBREF, TERM, _), GOAL), BAG)'.
'lmdb_compress(+DBREFFROM, +DBREFTO)'

     Copies the database given by DBREFFROM to a new database given by
     DBREFTO.  The new database will be a compressed version of the
     first one in the sense that it will not have "holes" resulting from
     deletion of terms.  Deleted term references will also be reused,
     which implies that references that refer to terms in the old
     database will be invalid in the new one.

     The terms of DBREFFROM will be appended to any existing terms of
     DBREFTO.  Of course, DBREFTO must have an indexing specification
     that enables the terms in DBREFFROM to be inserted into it.
'lmdb_sync(+DBREF)'

     Flushes any cached information from the database referenced by
     DBREF to stable storage.
'lmdb_make_iterator(+DBREF, +TERM, -ITERATOR)'

     Creates a new iterator and unifies it with ITERATOR.  The iterator
     iterates through the terms that would be found by
     'lmdb_fetch(DBREF, TERM, _)'.

     Every iterator created by 'lmdb_make_iterator/3' must be destroyed
     with 'lmdb_iterator_done/1'.
'lmdb_with_iterator(+DBREF, +TERM, :GOAL)'

     Creates a new iterator, calls GOAL with it, as if by 'call(Goal,
     Iterator)', and ensures that the iterator is destroyed afterwards.
     GOAL may backtrack and succeed multiple times.  See the
     documentation of LMDB_MAKE_ITERATOR/3.
'lmdb_iterator_next(+ITERATOR, -TERM, -TERMREF)'

     ITERATOR advances to the next term, and TERM and TERMREF are
     unified with the term and its reference pointed to by ITERATOR.  If
     there is no next term, the predicate fails.
'lmdb_iterator_done(+ITERATOR)'

     Deallocates ITERATOR, which must not be in use anymore.
'lmdb_property(+DBREF, -PROPERTY)'

     Unifies PROPERTY with one of the properties of the database given
     by DBREF, which are:

     'path(P)'
          The file system path of the database.

     'speclist(L)'
          The SPECLIST with which the database was created.

     'mapsize(S)'
          The mapsize, or size limit, of the database.

     'mode(S)'
          The access mode with which the database was opened.  One of
          the atoms 'read' and 'write'.

     Enumerates all four properties on backtracking.
'lmdb_export(+DBREF, +EXPORTFILE)'

     Exports the database given by DBREF to the text file EXPORTFILE.
     EXPORTFILE can be imported by 'lmdb_import/2'.
'lmdb_import(+DBREF, +IMPORTFILE)'

     Imports the text file IMPORTFILE into the database given by DBREF.

     The 'ImportFile' should have been written by 'lmdb_export/2' or by
     the corresponding functionality in 'library(bdb)'.


File: sicstus.info,  Node: LMDB Example Session,  Next: LMDB DB-Spec Details,  Prev: LMDB Predicates,  Up: lib-lmdb

10.25.6 Example Session
-----------------------

This example creates a database, opens it, and add some values to it.
Finally the values are read.

     | ?- lmdb_create(tempdb, [a(+,-)]).

     | ?- lmdb_open(tempdb, R, [mode(write)]), assertz(tempdb(R)).
     R = '$lmdb'(4611936272) ?

     | ?- tempdb(R), lmdb_store(R, a(b,1), T).
     R = '$lmdb'(4611936272),
     T = '$db_termref'(0) ?

     | ?- tempdb(R), lmdb_store(R, a(c,2), T).
     R = '$lmdb'(4611936272),
     T = '$db_termref'(1) ?

     | ?- tempdb(R), lmdb_store(R, a(b,X), T).
     R = '$lmdb'(4611936272),
     T = '$db_termref'(2) ?

     | ?- tempdb(R), lmdb_enumerate(R, Term, _).
     R = '$lmdb'(4611936272),
     Term = a(b,1) ? ;
     R = '$lmdb'(4611936272),
     Term = a(c,2) ? ;
     R = '$lmdb'(4611936272),
     Term = a(b,_A) ? ;

     | ?- tempdb(R), lmdb_findall(R, Term, Term, ground(Term), Bag).
     R = '$lmdb'(4611936272),
     Bag = [a(b,1),a(c,2)] ?

     | ?- retract(tempdb(R)), lmdb_close(R).
     R = '$lmdb'(4611936272) ?

   Later, in another (or the same) process, the stored data can be read.

     | ?- lmdb_open(tempdb, R, [mode(read)]), assertz(tempdb(R)).
     R = '$lmdb'(4560556048) ?

     | ?- tempdb(R), lmdb_findall(R, Term, Term, ground(Term), Bag).
     R = '$lmdb'(4560556048),
     Bag = [a(b,1),a(c,2)] ?

     | ?- retract(tempdb(R)), lmdb_close(R).
     R = '$lmdb'(4560556048) ?


File: sicstus.info,  Node: LMDB DB-Spec Details,  Next: LMDB Export-Import,  Prev: LMDB Example Session,  Up: lib-lmdb

10.25.7 DB-Spec--Details
------------------------

A db-spec has the form of a SPECLIST:

SPECLIST
     = '['SPEC1, ..., SPECM']'

SPEC
     = FUNCTOR'('ARGSPEC1, ..., ARGSPECN')'

ARGSPEC
     = '+' | '-'
   where FUNCTOR is a Prolog atom.  The case N = 0 is allowed.

   A spec F'('ARGSPEC1, ..., ARGSPECN')' is _applicable_ to any nonvar
term with principal functor F/N.

   When storing a term T, we generate a hash code for every applicable
spec in the db-spec, and a reference to T is stored with each of them.
(More precisely, with each element of the set of generated hash codes).
If T contains nonvar elements on each '+' position in the spec, then the
hash code depends on each of these elements.  If T does contain some
variables on '+' position, then the hash code depends only on the
functor of T.

   When fetching a term Q, we look for an applicable spec for which
there are no variables in Q on positions marked '+'.  If no applicable
spec can be found, a domain error is raised.  If no spec can be found
where on each '+' position a nonvar term occurs in Q, an instantiation
error is raised.  Otherwise, we choose the spec with the most '+'
positions, breaking ties by choosing the leftmost one.

   The terms that contain nonvar terms on every '+' position will be
looked up using indexing based on the principal functor of the term and
the principal functor of terms on '+' positions.  The other (more
general) terms will be looked up using an indexing based on the
principal functor of the term only.


File: sicstus.info,  Node: LMDB Export-Import,  Prev: LMDB DB-Spec Details,  Up: lib-lmdb

10.25.8 Exporting and Importing a Database
------------------------------------------

Since the database format of LMDB may change from version to version, it
may become necessary to migrate a database when upgrading.  Two
predicates are provided for this purpose: 'lmdb_export/2' and
'lmdb_import/2'.

   To ease migration from the legacy 'library(bdb)' library, files
exported with 'bdb:db_export/[2,3]' can be imported into the LMDB format
using 'lmdb_import/2'.


File: sicstus.info,  Node: lib-logarr,  Next: lib-mutarray,  Prev: lib-lmdb,  Up: The Prolog Library

10.26 Sparse Array Operations--'library(logarr)'
================================================

This library module provides extendible arrays with logarithmic access
time.  *Please note:* the atom '$' is used to indicate an unset element,
and the functor '$/4' is used to indicate a subtree.  In general, array
elements whose principal function symbol is '$' will not work.

   Exported predicates:

     new_array(-A) returns a new empty array A.
'is_array(+A)'
     checks whether A is an array.
'alist(+ARRAY, -LIST)'
     returns a list of pairs INDEX-ELEMENT of all the elements of ARRAY
     that have been set.
'aref(+INDEX, +ARRAY, -ELEMENT)'
     unifies ELEMENT with ARRAY[INDEX], or fails if ARRAY[INDEX] has not
     been set.
'arefa(+INDEX, +ARRAY, -ELEMENT)'
     is as 'aref/3', except that it unifies ELEMENT with a new array if
     ARRAY[INDEX] is undefined.  This is useful for multidimensional
     arrays implemented as arrays of arrays.
'arefl(+INDEX, +ARRAY, -ELEMENT)'
     is as 'aref/3', except that ELEMENT appears as '[]' for undefined
     cells.
'aset(+INDEX, +ARRAY, +ELEMENT, -NEWARRAY)'
     unifies NEWARRAY with the result of setting ARRAY[INDEX] to
     ELEMENT.


File: sicstus.info,  Node: lib-mutarray,  Next: lib-mutdict,  Prev: lib-logarr,  Up: The Prolog Library

10.27 Mutable, Dense Array Operations--'library(mutarray)'
==========================================================

Prolog does not have an array type.  Instead, one must use lists or
trees, with logarithmic access time to the elements at best.  This
package provides operations on dense, mutable arrays, of elements
indexed from 1 and up.  It uses an array representation, which admits
direct access to the elements and constant-time access to any element.
Update operations also take constant time, except under some
circumstances when the entire array must be copied, in which case such
operations take linear time.  Following are the exported predicates,
where a MUTARRAY is a MUTABLE (*note ref-lte-mut::), the value of which
is accessed and modified by the operations of this package.

'is_mutarray(+ARRAY)'

     succeeds when ARRAY is a MUTARRAY.
'list_to_mutarray(+ITEMS, -ARRAY)'

     where ITEMS should be a list of values.  ARRAY is unified with a
     new MUTARRAY populated by the given values.
'new_mutarray(-ARRAY)'

     unifies ARRAY with a new MUTARRAY of zero length.
'new_mutarray(-ARRAY, +SIZE)'

     where SIZE should be a nonnegative integer.  ARRAY is unified with
     a new MUTARRAY of the given size populated by brand new variables.
'mutarray_length(+MUTARRAY, -LENGTH)'

     LENGTH is unified in constant time with the length of MUTARRAY.
'mutarray_set_length(+MUTARRAY, +LENGTH)'

     sets the new length of MUTARRAY MUTARRAY to LENGTH.  If the
     MUTARRAY becomes shorter, this runs in constant time in the best
     case.  Otherwise, new brand new variables are added to the end of
     the array in linear time.
'mutarray_last(+MUTARRAY, -LAST)'

     LAST is unified in constant time with the last element of MUTARRAY.
     Merely fails if MUTARRAY is of zero length.
'mutarray_to_list(+MUTARRAY, -LIST)'

     LIST is unified with the list of elements of MUTARRAY.
'mutarray_gen(+MUTARRAY, -N, -ELEMENT)'

     is true when ELEMENT is the N:th element of the given MUTARRAY.
     Iterates over all elements by increasing N.
'mutarray_get(+MUTARRAY, +N, -ELEMENT)'

     unifies ELEMENT in constant time with the N:th element of MUTARRAY.
'mutarray_put(+MUTARRAY, +N, +ELEMENT)'

     sets the N:th element of MUTARRAY to ELEMENT.
'mutarray_update(+MUTARRAY, +N, -OLDELEMENT, +NEWELEMENT)'

     unifies OLDELEMENT with the N:th element of MUTARRAY, and sets that
     element to NEWELEMENT.
'mutarray_append(+MUTARR, +MUTARRORVALUES)'

     where MUTARRORVALUES should be a MUTARRAY or a list of values,
     which is appended to the end of MUTARR.


File: sicstus.info,  Node: lib-mutdict,  Next: lib-objects,  Prev: lib-mutarray,  Up: The Prolog Library

10.28 Mutable Dictionary Operations--'library(mutdict)'
=======================================================

Prolog does not have a dictionary type.  Instead, one can use, e.g., AVL
trees, with logarithmic access time.  This package provides operations
on mutable dictionaries.  Such a MUTDICT is an unordered collection of
items that consist of a key and a value.  The only restrictions on items
is that the key must be ground.  The given MUTDICT can hold at most one
item for any given key.  It uses a hash table representation, which
admits table lookup in constant time, if there are no hash collisions.
Update operations also take constant time, except under some
circumstances when the entire table must be copied, in which case such
operations take linear time.  In addition, the hash function takes time
linear in the size of the key, and so simple keys are more efficient
than compound terms.  A MUTDICT is a MUTABLE (*note ref-lte-mut::), the
value of which is accessed and modified by the operations of this
package.  Following are the exported predicates:

'is_mutdict(+DICT)'

     succeeds when DICT is a MUTDICT.
'list_to_mutdict(+ITEMS, -DICT)'

     unifies DICT with a new MUTDICT populated by ITEMS, each of which
     should be of the form 'KEY-VALUE'.
'new_mutdict(-DICT)'

     unifies DICT with a new MUTDICT.
'mutdict_empty(+DICT)'

     succeeds when DICT is an empty MUTDICT.
'mutdict_size(+DICT, -SIZE)'

     unifies SIZE with the number of elements of the MUTDICT DICT.
'mutdict_gen(+DICT, -KEY, -VALUE)'

     succeeds when DICT is a MUTDICT where one item consists of KEY and
     VALUE.  Iterates over all items, but in no specific order.
'mutdict_get(+DICT, +KEY, -VALUE)'

     If there is an item of the MUTDICT with key KEY, then its value is
     unified with VALUE.  Otherwise, the goal fails.
'mutdict_put(+DICT, +KEY, +VALUE)'

     If there is an item of the MUTDICT with key KEY, then its value is
     simply replaced by VALUE; otherwise, adds the item consisting of
     KEY and VALUE to the given MUTDICT.
'mutdict_update(+DICT, +KEY, -OLDVALUE, +NEWVALUE)'

     If there is an item of the MUTDICT with key KEY, then its value is
     unified with OLDVALUE and replaced by NEWVALUE.  Otherwise, the
     goal fails.
'mutdict_delete(+DICT, +KEY)'

     If there is an item of the MUTDICT with key KEY, then it is
     deleted; otherwise, the goal merely succeeds.
'mutdict_clear(+DICT)'

     All items are deleted from the MUTDICT.
'mutdict_keys(+DICT, -KEYS)'

     KEYS is unified with the list of keys of MUTDICT.  The list comes
     in no specific order, and is free of duplicates.
'mutdict_values(+DICT, -VALUES)'

     VALUES is unified with the list of values of MUTDICT.  The list
     comes in no specific order, and can contain duplicates.
'mutdict_items(+DICT, -ITEMS)'

     ITEMS is unified with the list of items of MUTDICT.  Each item is
     of the form 'KEY-VALUE'.  The list comes in no specific order, and
     is free of duplicates.
'mutdict_append(+DICT, +DICTORITEMS)'

     where DICTORITEMS should be a MUTDICT or a list of items.  For each
     item of DICTORITEMS of the form 'KEY-VALUE', if there is an item of
     the MUTDICT with key KEY, then its value is simply replaced by
     VALUE; otherwise, the item is added to the given MUTDICT.


File: sicstus.info,  Node: lib-objects,  Next: lib-odbc,  Prev: lib-mutdict,  Up: The Prolog Library

10.29 The Objects Package--'library(objects)'
=============================================

* Menu:

* obj-exp::                             Exported Predicates
* obj-glo::                             Glossary
* obj-bas::                             Introduction
* obj-scl::                             Simple Classes
* obj-inh::                             Inheritance
* obj-tcl::                             Term Classes
* obj-tech::                            Technical Details

The SICStus Objects package enables programmers to write object-oriented
programs in SICStus Prolog.  The objects in SICStus Objects are
modifiable data structures that provide a clean and efficient
alternative to storing data in the Prolog database.


File: sicstus.info,  Node: obj-bas,  Next: obj-scl,  Prev: obj-glo,  Up: lib-objects

10.29.1 Introduction
--------------------

* Menu:

* obj-bas-uobj::                        Using SICStus Objects
* obj-bas-def::                         Defining Classes
* obj-bas-ucl::                         Using Classes
* obj-bas-la::                          Looking Ahead

The SICStus Objects package enables programmers to write object-oriented
programs in SICStus Prolog.  The objects in SICStus Objects are
modifiable data structures that provide a clean and efficient
alternative to storing data in the Prolog database.

   This user's guide is neither an introduction to object-oriented
programming nor an introduction to SICStus Prolog.  A number of small,
sample programs are described in this manual, and some larger programs
are in the 'demo' directory.


File: sicstus.info,  Node: obj-bas-uobj,  Next: obj-bas-def,  Up: obj-bas

10.29.1.1 Using SICStus Objects
...............................

One of the basic ideas of object-oriented programming is the
encapsulation of data and procedures into objects.  Each object belongs
to exactly one class, and an object is referred to as an instance of its
class.  A class definition determines the following things for its
objects:

   * slots, where an object holds data
   * messages, the commands that can be sent to an object
   * methods, the procedures the object uses to respond to the messages

   All interaction with an object is by sending it messages.  The
command to send a message to an object has the form

     OBJECT MESSAGEOP MESSAGE

where OBJECT is an object, MESSAGEOP is one of the message operators
('<<', '>>', or '<-') and MESSAGE is a message defined for the object's
class.  Roughly speaking, the '>>' message operator is used for
extracting information from an object, '<<' is for storing information
into an object, and '<-' is for any other sort of operation.

   For example, using the point class defined in the next section, it
would be possible to give the following command, which demonstrates all
three message operators.

     | ?- create(point, PointObj),
          PointObj >> x(InitX),
          PointObj >> y(InitY),
          PointObj << x(2.71828),
          PointObj << y(3.14159),
          PointObj <- print(user_output),
          nl(user_output).

     (2.71828,3.14159)
     PointObj = point(23461854),
     InitX = 1.0,
     InitY = 2.0

   First it binds the variable 'PointObj' to a newly created 'point'
object.  Then, the two get messages (sent with the '>>' operator) fetch
the initial values of the point's 'x' and 'y' slots, binding the
variables 'InitX' and 'InitY' to these values.  Next, the two put
messages (sent with the '<<' operator) assign new values to the object's
'x' and 'y' slots.  Finally, the send message (sent with the '<-'
operator) instructs the point object to print itself to the
'user_output' stream, followed by a newline.  Following the goal, we see
the point has been printed in a suitable form.  Following this, the
values of 'PointObj', 'InitX', and 'InitY' are printed as usual for
goals entered at the top-level prompt.

   Because this goal is issued at the top-level prompt, the values of
the variables 'PointObj', 'InitX' and 'InitY' are not retained after the
command is executed and their values are displayed, as with any goal
issued at the top-level prompt.  However, the point object still exists,
and it retains the changes made to its slots.  Hence, objects, like
clauses asserted to the Prolog database, are more persistent than Prolog
variables.

   Another basic idea of object-oriented programming is the notion of
inheritance.  Rather than defining each class separately, a new class
can inherit the properties of a more general superclass.  Or, it can be
further specialized by defining a new subclass, which inherits its
properties.  (C++ uses the phrase "base class" where we use
"superclass."  It also uses "derived class" where we use "subclass.")

   SICStus Objects uses term expansion to translate object-oriented
programs into ordinary Prolog.  (This is the same technique that Prolog
uses for its DCG grammar rules.)  As much as possible is done at compile
time.  Class definitions are used to generate Prolog clauses that
implement the class's methods.  Message commands are translated into
calls to those Prolog clauses.  And, inheritance is resolved at
translation time.

   SICStus Objects consists of two modules, 'obj_decl' and 'objects'.
The 'obj_decl' module is used at compile time to translate the
object-oriented features of SICStus Objects.  Any file that defines
classes or sends messages should include the command

     :- load_files(library(obj_decl),
                   [when(compile_time), if(changed)]).

   The 'objects' module provides runtime support for SICStus Objects
programs.  A file that sends messages or asks questions about what
classes are defined or to what class an object belongs should include
the command:

     :- use_module(library(objects)).

   You will probably include both in most files that define and use
classes.

   *Please note:* A file that loads 'library(obj_decl)' currently cannot
recursively load another file that loads 'library(obj_decl)', because
that would confuse the internal database being used by the package.

   If you use the foreign resource linker, 'splfr', on a Prolog file
that uses the 'objects' package, then you must pass it the '--objects'
option.  This will make 'splfr' understand the package's syntax
extensions.


File: sicstus.info,  Node: obj-bas-def,  Next: obj-bas-ucl,  Prev: obj-bas-uobj,  Up: obj-bas

10.29.1.2 Defining Classes
..........................

A class definition can restrict the values of any slot to a particular
C-style type.  It can specify whether a slot is "private" (the default,
meaning that it cannot be accessed except by that methods of that
class), "protected" (like "private", except that the slot can also be
accessed by subclasses of the class), or "public" (meaning get and put
methods for the slot are generated automatically), and it can specify an
initial value.  The class definition also may contain method clauses,
which determine how instances of the class will respond to messages.  A
class definition may also specify one or more superclasses and which
methods are to be inherited.

   The point object created in the previous example had two floating
point slots, named 'x' and 'y', with initial values of 1.0 and 2.0,
respectively.  As we have seen, the 'point' class also defined put and
get methods for 'x' and 'y', as well as a send method for printing the
object.  The put and get methods for 'x' and 'y' can be automatically
generated simply by declaring the slots 'public', but the 'print' method
must be explicitly written.  In addition, in order to be able to create
instances of this class, we must define a 'create' method, as explained
in *note obj-scl-meth::.  We also provide a second 'create' method,
taking two arguments, allowing us to specify an 'x' and 'y' value when
we first create a point object.

     :- class point =
             [public x:float = 1.0,
              public y:float = 2.0].

     Self <- create.

     Self <- create(X, Y) :-
             Self << x(X),
             Self << y(Y).

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, '(~w,~w)', [X,Y]).

     :- end_class point.

   The variable name 'Self' in these clauses is arbitrary--any variable
to the left of the message operator in the head of a method clause
refers to the instance of the class receiving the message.


File: sicstus.info,  Node: obj-bas-ucl,  Next: obj-bas-la,  Prev: obj-bas-def,  Up: obj-bas

10.29.1.3 Using Classes
.......................

Given this definition, the following command creates an instance of the
point class, assigning values to its 'x' and 'y' slots, and prints a
description of the point.

     | ?- create(point(3,4), PointObj),
          PointObj <- print(user_output).

   The print message prints '(3.0,4.0)'.  The variable 'PointObj' is
bound to a Prolog term of the form

     point(ADDRESS)

where ADDRESS is essentially a pointer to the object.

   In general, an object belonging to a class CLASSNAME will be
represented by a Prolog term of the form

     CLASSNAME(ADDRESS)

   The name CLASSNAME must be an atom.  This manual refers to such a
term as if it were the object, not just a pointer to the object.  Users
are strongly discouraged from attempting to do pointer arithmetic with
the address.

   After execution of this command, the point object still exists, but
the variable 'PointObj' can no longer be used to access it.  So, while
objects resemble clauses asserted into the Prolog database in their
persistence, there is no automatic way to search for an object.  Objects
are not automatically destroyed when they are no longer needed.  And,
there is no automatic way to save an object from one Prolog session to
the next.  It is the responsibility of the programmer to keep track of
objects, perhaps calling the 'destroy/1' predicate for particular
objects that are no longer needed or asserting bookkeeping facts into
the Prolog database to keep track of important objects.


File: sicstus.info,  Node: obj-bas-la,  Prev: obj-bas-ucl,  Up: obj-bas

10.29.1.4 Looking Ahead
.......................

The next few sections of this manual describe the SICStus Objects
package in greater detail.  In particular, they describe how to define
classes, their methods and their slots, and how to reuse class
definitions via inheritance.  Small sample programs and program
fragments are provided for most of the features described.

   Experienced Prolog programmers may choose to skip over these sections
and look at the sample programs in this package's demo directory,
referring to the reference pages as necessary.  Everyone is encouraged
to experiment with the sample programs before writing their own
programs.


File: sicstus.info,  Node: obj-scl,  Next: obj-inh,  Prev: obj-bas,  Up: lib-objects

10.29.2 Simple Classes
----------------------

* Menu:

* obj-scl-scp::                         Scope of a Class Definition
* obj-scl-slt::                         Slots
* obj-scl-meth::                        Methods

This section is about simple classes that inherit nothing--neither slots
nor methods--from more general superclasses.  Everything about these
classes is given directly in their definitions, so they are the best
starting point for programming with SICStus Objects.

   The use of inheritance in defining classes is described in the next
section.  Classes that inherit properties from superclasses are called
derived classes in some systems, such as C++.  In general, the use of
inheritance extends the properties of the simple classes in this
section.


File: sicstus.info,  Node: obj-scl-scp,  Next: obj-scl-slt,  Up: obj-scl

10.29.2.1 Scope of a Class Definition
.....................................

A simple class definition begins with a statement of the form

     :- class CLASSNAME = [SLOTDEF, ...].

   The class's slots are described in the list of SLOTDEF terms.  It is
possible, though not often useful, to define a class with no slots, by
specifying the empty list.  In that case the '=' and the list may be
omitted.

   The class's methods are defined following the 'class/1' directive, by
Prolog clauses.  Most of this section is about defining and using
methods.

   The class definition ends with any of the following:

     :- end_class CLASSNAME.

or

     :- end_class.

or the next 'class/1' directive or the end of the file.  The CLASSNAME
argument to 'end_class/1' must match the class name in the corresponding
'class/1' directive.  It is not possible to nest one class definition
inside another.


File: sicstus.info,  Node: obj-scl-slt,  Next: obj-scl-meth,  Prev: obj-scl-scp,  Up: obj-scl

10.29.2.2 Slots
...............

A slot description has the form

     VISIBILITY SLOTNAME:SLOTTYPE = INITIALVALUE

where VISIBILITY and '= INITIALVALUE' are optional.  Each slot of a
class must have a distinct name, given by the atom SLOTNAME.  The
VISIBILITY, SLOTTYPE and INITIALVALUE parts of the slot description are
described separately.

Visibility
----------

A slot's visibility is either private, protected, or public.  If its
visibility is not specified, then the slot is private.  The following
example shows all four possibilities:

     :- class example = [w:integer,
                         private   x:integer,
                         protected y:integer,
                         public    z:integer]

   Slot 'z' is public, 'y' is protected, and both 'x' and 'w' are
private.

   Direct access to private slots is strictly limited to the methods of
the class.  Any other access to such slots must be accomplished through
these methods.  Making slots private will allow you later to change how
you represent your class, adding and removing slots, without having to
change any code that uses your class.  You need only modify the methods
of the class to accommodate that change.  This is known as "information
hiding".

   Protected slots are much like private slots, except that they can
also be directly accessed by subclasses.  This means that if you wish to
modify the representation of your class, then you will need to examine
not only the class itself, but also its subclasses.

   Public slots, in contrast, can be accessed from anywhere.  This is
accomplished through automatically generated get and put methods named
for the slot and taking one argument.  In the example above, our
'example' class would automatically support a get and put method named
'z/1'.  Note, however, that unlike other object oriented programming
languages that support them, public slots in SICStus Objects do not
violate information hiding.  This is because you may easily replace a
public slot with your own get and put methods of the same name.  In this
sense, a public slot is really only a protected slot with automatically
generated methods to fetch and store its contents.

   Within a method clause, any of the class's slots can be accessed via
the 'fetch_slot/2' and 'store_slot/2' predicates.  These are the only
way to access private and protected slots.  They may be used to define
get and put methods for the class, which provide controlled access to
the protected slots.  But, they can only be used within the method
clauses for the class, and they can only refer to slots of the current
class and protected and public slots of superclasses.

   In the slot description, 'public', 'protected' and 'private' are used
as prefix operators.  The 'obj_decl' module redefines the prefix
operator 'public', as follows:

     :- op(600, fy, [public]).

   Unless you use the obsolete 'public/1' directive in your Prolog
programs, this should cause no problems.

Types
-----

A slot's type restricts the kinds of values it may contain.  The slot is
specified in the slot description by one of the following Prolog terms
with the corresponding meaning.  Most of these will be familiar, but the
last four, 'address', 'term', CLASS and 'pointer(TYPE)', require some
additional explanation:

'integer'
     signed integer, large enough to hold a pointer

'integer_64   since release 4.3'
     64-bit signed integer

'integer_32'
     32-bit signed integer

'integer_16'
     16-bit signed integer

'integer_8'
     8-bit signed integer

'unsigned'
     unsigned integer, large enough to hold a pointer

'unsigned_64   since release 4.3'
     64-bit unsigned integer

'unsigned_32'
     32-bit unsigned integer

'unsigned_16'
     16-bit unsigned integer

'unsigned_8'
     8-bit unsigned integer

'float'
     64-bit floating point number

'float_32'
     32-bit floating point number

'atom'
     Prolog atom

'address'
     Pointer.  The 'address' type is intended for use with foreign code.
     A slot of this type might store an address returned from a foreign
     function.  That address might, in turn, be used in calling another
     foreign function.  Hence, most Prolog programmers can safely ignore
     this type.

'term'
     Prolog term.  The 'term' type is for general Prolog terms.  Such a
     slot can hold any of the other types.  However, if you know a slot
     will be used to hold only values of a particular type, then it is
     more efficient to specify that type in the class definition.

     Storing a term containing free variables is similar to asserting a
     clause containing free variables into the Prolog database.  The
     free variables in the term are replaced with new variables in the
     stored copy.  And, when you fetch the term from the slot, you are
     really fetching a copy of the term, again with new variables.

'CLASS'
     where CLASS is the name of a defined class.  The class type is for
     any object in a class defined with SICStus Objects.  Such a slot
     holds an object of its class or one of that class's descendants, or
     the 'null' object.

'pointer(TYPE)'
     where TYPE is an atom.  The pointer type is intended for use with
     the Structs Package.  It is similar to the 'address' type, except
     that access to this slot yields, and update to this slot expects, a
     term of arity 1 whose functor is TYPE and whose argument is the
     address.  Again, most Prolog programmers can safely ignore this
     type.

Initial Values
--------------

A slot description may optionally specify an initial value for the slot.
The initial value is the value of the slot in every instance of the
class, when the object is first created.  The initial value must be a
constant of the correct type for the slot.

   If an initial value is not specified, then a slot is initialized to a
value that depends on its type.  All numbers are initialized to 0, of
the appropriate type.  Atom and term slots are initialized to the empty
atom ('''').  Addresses and pointers are initialized to null pointers.
And, objects are initialized to the 'null' object.

   More complicated initialization--not the same constant for every
instance of the class--must be performed by create methods, which are
described later.

The 'null' object
-----------------

The 'null' object is a special object that is not an instance of any
class, but that can be stored in a slot intended for any class of
object.  This is very much like the 'NULL' pointer in C. This is useful
when you do not yet have an object to store in a particular slot.

   In Prolog, the 'null' is represented by the atom 'null'.

   Note that because the 'null' object is not really an object of any
class, you cannot determine its class with 'class_of/2'.  Unless noted
otherwise, when we write of an "object" in this document, we do not
include the 'null' object.


File: sicstus.info,  Node: obj-scl-meth,  Prev: obj-scl-slt,  Up: obj-scl

10.29.2.3 Methods
.................

Some methods are defined by method clauses, between the 'class/1'
directive and the end of the class's definition.  Others are generated
automatically.  There are three kinds of messages in SICStus Objects,
distinguished by the message operator they occur with:

'>>'
     A get message, which is typically used to fetch values from an
     object's slots.

'<<'
     A put message, which is typically used to store values in an
     object's slots.

'<-'
     A send message, which is used for other operations on or involving
     an object.

   SICStus Objects automatically generates some get and put methods.
And, it expects particular message names with the send operator for
create and destroy methods.  For the most part, however, you are free to
use any message operators and any message names that seem appropriate.

   A method clause has one of these message operators as the principal
functor of its head.  Its first argument, written to the left of the
message operator, is a variable.  By convention, we use the variable
'Self'.  Its second argument, written to the right of the message
operator, is a term whose functor is the name of the message and whose
arguments are its arguments.

   For example, in the class whose definition begins as follows, a
0-argument send message named 'increment' is defined.  No parentheses
are needed in the clause head, because the precedence of the '<-'
message operator is lower than that of the ':-' operator.

     :- class counter = [public count:integer = 0].

     Self <- increment :-
             Self >> count (X0),
             X1 is X0 + 1,
             Self << count (X1).

   Its definition uses the automatically generated get and put methods
for the public slot 'count'.

   It may look as though this technique is directly adding clauses to
the '>>/2', '<</2' and '<-/2' predicates, but the method clauses are
transformed by term expansion, at compile time.  However, the method
clauses have the effect of extending the definitions of those
predicates.

   Methods are defined by Prolog clauses, so it is possible for them to
fail, like Prolog predicates, and it is possible for them to be
nondeterminate, producing multiple answers, upon backtracking.  The rest
of this section describes different kinds of methods.

Get and Put Methods
-------------------

Get and put methods are generated automatically for each of a class's
public slots.  These are 1-argument messages, named after the slots.

   In the point class whose definition begins with

     :- class point =
             [public x:float=0,
              public y:float=0].

the get and put methods are automatically generated for the 'x' and 'y'
slots.  If the class defines a 'create/0' method, then the command

     | ?- create(point, PointObj),
          PointObj >>  x(OldX),
          PointObj >>  y(OldY),
          PointObj <<  x(3.14159),
          PointObj <<  y(2.71828).

creates a point object and binds both 'OldX' and 'OldY' to 0.0E+00, its
initial slot values.  Then, it changes the values of the 'x' and 'y'
slots to 3.14159 and 2.71828, respectively.  The variable 'PointObj' is
bound to the point object.

   It is possible, and sometimes quite useful, to create get and put
methods for slots that do not exist.  For example, it is possible to add
a polar coordinate interface to the point class by defining get and put
methods for 'r' and 'theta', even though there are no 'r' and 'theta'
slots.  The get methods might be defined as follows:

     Self >> r(R) :-
             Self >> x(X),
             Self >> y(Y),
             R is sqrt(X*X + Y*Y).

     Self >> theta(T) :-
             Self >> x(X),
             Self >> y(Y),
             T is atan(Y/X).

   The put methods are left as an exercise.

   In the rational number class whose definition begins with:

     :- class rational =
             [public num:integer,
              public denom:integer].

get and put methods are automatically generated for the 'num' and
'denom' slots.  It might be reasonable to add a get method for 'float',
which would provide a floating point approximation to the rational in
response to that get message.  This is left as an exercise.

   It is also possible to define get and put methods that take more than
one argument.  For example, it would be useful to have a put method for
the point class that sets both slots of a point object.  Such a method
could be defined by

     Self << point(X,Y) :-
             Self << x(X),
             Self << y(Y).

   Similarly, a 2-argument get method for the rational number class
might be defined as

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   Note that the name of the put message is '(/)/2', and that the
parentheses are needed because of the relative precedences of the '>>'
and '/' operators.

   Put messages are used to store values in slots.  Get messages,
however, may be used either to fetch a value from a slot or to test
whether a particular value is in a slot.  For instance, the following
command tests whether the 'do_something/2' predicate sets the point
object's 'x' and 'y' slots to 3.14159 and 2.71828, respectively.

     | ?- create(point, PointObj),
          do_something(PointObj),
          PointObj >> x(3.14159),
          PointObj >> y(2.71828).

   The 'fetch_slot/2' predicate can similarly be used to test the value
of a slot.

   The effects of a put message (indeed, of any message) are not undone
upon backtracking.  For example, the following command fails:

     | ?- create(point, PointObj),
          PointObj << x(3.14159),
          PointObj << y(2.71828),
          fail.

   But, it leaves behind a point object with 'x' and 'y' slots
containing the values 3.14159 and 2.71828, respectively.  In this,
storing a value in an object's slot resembles storing a term in the
Prolog database with 'assert/1'.

   Some care is required when storing Prolog terms containing unbound
variables in term slots.  For example, given the class definition that
begins with

     :- class prolog_term = [public p_term:term].

     Self <- create.

the following command would succeed:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,Y)),
          X = a,
          Y = b,
          TermObj >> p_term(foo(c,d)).

   The reason is that the free variables in 'foo(X,Y)' are renamed when
the term is stored in the 'prolog_term' object's 'p_term' slot.  This is
similar to what happens when such a term is asserted to the Prolog
database:

     | ?- retractall(foo(_,_)),
          assert(foo(X,Y)),
          X = a,
          Y = b,
          foo(c,d).

   However, this goal would fail, because 'c' and 'd' cannot be unified:

     | ?- create(prolog_term, TermObj),
          TermObj << p_term(foo(X,X)),
          TermObj >> p_term(foo(c,d)).

Direct Slot Access
------------------

Get and put methods are not automatically generated for private and
protected slots.  Those slots are accessed by the 'fetch_slot/2' and
'store_slot/2' predicates, which may only appear in the body of a method
clause and which always operate on the object to which the message is
sent.  It is not possible to access the slots of another object with
these predicates.

   You may declare a slot to be private or protected in order to limit
access to it.  However, it is still possible, and frequently useful, to
define get and put methods for such a slot.

   For example, if numerator and denominator slots of the rational
number class were private rather than public, then it would be possible
to define put methods to ensure that the denominator is never 0 and that
the numerator and denominator are relatively prime.  The get methods
merely fetch slot values, but they need to be defined explicitly, since
the slots are private.  The new definition of the rational number class
might start as follows:

     :- class rational =
             [num:integer=0,
              denom:integer=1].

     Self >> num(N) :-
             fetch_slot(num, N).

     Self >> denom(D) :-
             fetch_slot(denom, D).

     Self >> (N/D) :-
             Self >> num(N),
             Self >> denom(D).

   One of the put methods for the class might be

     Self << num(NO) :-
             fetch_slot(denom, DO)
             reduce(NO, DO, N, D),
             store_slot(num, N),
             store_slot(denom, D).

where the 'reduce/4' predicate would be defined to divide 'NO' and 'DO'
by their greatest common divisor, producing 'N' and 'D', respectively.

   The definition of 'reduce/4' and the remaining put methods is left as
an exercise.  The put methods should fail for any message that attempts
to set the denominator to 0.

Send Methods
------------

Messages that do something more than fetch or store slot values are
usually defined as send messages.  While the choice of message operators
is (usually) up to the programmer, choosing them carefully enhances the
readability of a program.

   For example, print methods might be defined for the point and
rational number classes, respectively, as

     Self <- print(Stream) :-
             Self >> x(X),
             Self >> y(Y),
             format(Stream, "(~w,~w)", [X, Y]).

and

     Self <- print(Stream) :-
             fetch_slot(num, N),
             fetch_slot(denom, D),
             format(Stream, "~w/~w", [N, D]).

   These methods are used to access slot values.  But, the fact that the
values are printed to an output stream makes it more reasonable to
define them as send messages than get messages.

   Frequently send methods modify slot values.  For example, the point
class might have methods that flip points around the x and y axes,
respectively:

     Self <- flip_x :-
             Self >> y(Y0),
             Y1 is -1 * Y0,
             Self << y(Y1).

     Self <- flip_y :-
             Self >> x(X0),
             X1 is -1 * X0,
             Self << x(X1).

   And, the rational number class might have a method that swaps the
numerator and denominator of a rational number object.  It fails if the
numerator is 0.

     Self <- invert :-
             fetch_slot(num, N)
             N =\= 0,
             fetch_slot(denom, D)
             store_slot(num, D),
             store_slot(denom, N).

   These methods modify slot values, but they do not simply store values
that are given in the message.  Hence, it is more reasonable to use the
send operator.

   It is possible for a method to produce more than one answer.  For
example, the class whose definition begins with

     :- class interval =
             [public lower:integer,
              public upper:integer].

might define a send method

     Self <- in_interval(X) :-
             Self >> lower(L),
             Self >> upper(U),
             between(L, U, X).

which uses the 'between/3' predicate from 'library(between)'.  The
'in_interval' message will bind 'X' to each integer, one at a time,
between the lower and upper slots, inclusive.  It fails if asked for too
many answers.

   The rest of this section describes particular kinds of send messages.

Create and Destroy Methods
--------------------------

Objects are created with the 'create/2' predicate.  When you define a
class, you must specify all the ways that instances of the class can be
created.  The simplest creation method is defined as

     Self <- create.

   If this method were defined for CLASS, then the command

     | ?- create(CLASS, Object).

would create an instance of CLASS and bind the variable 'Object' to that
instance.  All slots would receive their (possibly default) initial
values.

   More generally, if the definition for CLASS contains a create method

     Self <- create(ARGUMENTS) :-
             BODY.

then the command

     | ?- create(CLASS(ARGUMENTS), OBJECT).

will create an instance of CLASS and execute the BODY of the create
method, using the specified ARGUMENTS.  The variable OBJECT is bound to
the new instance.

   If a simple class definition has no create methods, then it is
impossible create instances of the class.  While the absence of create
methods may be a programmer error, that is not always the case.
Abstract classes, which are classes that cannot have instances, are
often quite useful in defining a class hierarchy.

   Create methods can be used to initialize slots in situations when
specifying initial slot values will not suffice.  (Remember that initial
values must be specified as constants at compile time).  The simplest
case uses the arguments of the create message as initial slot values.
For example, the definition of the point class might contain the
following create method.

     Self <- create(X,Y) :-
             Self << x(X),
             Self << y(Y).

   If used as follows

     | ?- create(point(3.14159, 2.71828), PointObj),
          PointObj >> x(X),
          PointObj >> y(Y).

then it would give 'X' and 'Y' the values of 3.14159 and 2.71828,
respectively.

   In some cases, the create method might compute the initial values.
The following (partial) class definition uses the 'date/1' predicate
from 'library(date)' to initialize its year, month and day slots.

     :- class date_stamp =
             [year:integer,
              month:integer,
              day:integer].

     Self <- create :-
             date(date(Year, Month, Day)),
             store_slot(year, Year),
             store_slot(month, Month),
             store_slot(day, Day).

   All three slots are private, so it will be necessary to define get
methods in order to retrieve the time information.  If no put methods
are defined, however, then the date cannot be modified after the
'date_stamp' object is created (unless some other method for this class
invokes 'store_slot/2' itself).

   Create methods can do more than initialize slot values.  Consider the
'named_point' class, whose definition begins as follows:

     :- class named_point =
             [public name:atom,
              public x:float=1,
              public y:float=0].

     Self <- create(Name, X, Y) :-
             Self << name(Name),
             Self << x(X),
             Self << y(Y),
             assert(name_point(Name, Self)).

   Not only does the 'create/3' message initialize the slots of a new
'named_point' object, but it also adds a 'name_point/2' fact to the
Prolog database, allowing each new object to be found by its name.
(This create method does not require the 'named_point' object to have a
unique name.  Defining a 'uniq_named_point' class is left as an
exercise.)

   An object is destroyed with the 'destroy/1' command.  Unlike
'create/2', 'destroy/1' does not require that you define a 'destroy'
method for a class.  However, 'destroy/1' will send a destroy message
(with no arguments) to an object before it is destroyed, if a 'destroy'
method is defined for the object's class.

   If a 'named_point' object is ever destroyed, then the address of the
object stored in this name 'point/2' fact is no longer valid.  Hence,
there should be a corresponding destroy method that retracts it.

     Self <- destroy :-
             Self >> name(Name),
             retract(name_point(Name, Self)).

   Similar create and destroy methods can be defined for objects that
allocate their own separate memory or that announce their existence to
foreign code.

Instance Methods
----------------

Instance methods allow each object in a class to have its own method for
handling a specified message.  For example, in a push-button class it
would be convenient for each instance (each push-button) to have its own
method for responding to being pressed.

   The declaration

     :- instance_method NAME/ARITY, ....

inside a class definition states that the message NAME/ARITY supports
instance methods.  If the class definition defines a method for this
message, then it will be treated as a default method for the message.

   The 'define_method/3' predicate installs a method for an object of
the class, and the 'undefine_method/3' predicate removes that method.

   Suppose that the 'date_stamp' class, defined earlier, declared an
instance method to print the year of a 'date_stamp' instance.

     :- instance_method print_year/1.

     Self <- print_year(Stream) :-
             Self >> year(Y0),
             Y1 is YO + 1970,
             format(Stream, "~d", [Y1]).

   The arithmetic is necessary because UNIX dates are based on January
1, 1970.

   If a particular 'date_stamp' object's date were to be printed in
Roman numerals, then it could be given a different 'print_year' method,
using the 'define_method/3' predicate.

     | ?- create(date_stamp, DateObj),
          define_method(DateObj,
     		   print_year(Stream),
     		   print_roman_year(Stream, DateObj)).

   If this 'date_stamp' object is created in 1994, then a 'print_year'
message sent to it would print the current year as

     MCMXCIV

   Defining the predicate 'print_roman_year/2' is left as an exercise.
It must be able to access the 'year' slot of a 'date_stamp' object.
Because it is not defined by a method clause within the class
definition, 'print_roman_year/2' cannot use the 'get_slot/2' predicate.

   None of 'instance_method/1', 'define_method/3', 'undefine_method/3'
specify a message operator.  Instance methods can only be defined for
send messages.

