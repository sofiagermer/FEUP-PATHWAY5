/* -*- Mode:C -*-
 *
 * This file is linked and #included into the containing executable (as
 * generated by spld/splfr).
 *
 */

/* [PM] 3.9b5 This file contain templates both for spld generated
   executables (if SPLD_GENERATE_MAIN is true) and templates for
   foreign resource glue code (if SPLD_GENERATE_MAIN is not set).
 */

#if SPLD_GENERATE_MAIN

#if SPLD_SET_PROCESS_LOCALE
#include <locale.h>
#endif /* SPLD_SET_PROCESS_LOCALE */

/* [PM] 4.0 non-negative exception type if a $reserved/1 exception was
   available, *pdata is its attached data or zero (currently only used
   for halt/1.

   return -1 if no properly formatted $reserved/1 exception was present
*/
static int get_reserved_exception(SP_integer *pdata)
{
  int res = -1;
  SP_term_ref exception_term = SP_new_term_ref();

  if (SP_exception_term(exception_term))
    {
      
      SP_integer data = 0;

      res = SP_decode_reserved_exception(exception_term, &data);
      if (res > 0)
        {
          *pdata = data;
          return res;
        }
    }
  return -1;
}


/*
  Generate main function for spld
  Inputs:
  SPLD_MAIN_NAME -- name of function. A C identifier
  SPLD_DSP -- Development system, 0 (RT) or 1 (DS) (or 2 Extended RT?).
  SPLD_INTERACTIVE -- undefined or 1
  SPLD_USERHOOK -- undefined or 1
  SPLD_SAV_FILE -- sav file to restore, undefined or string literal.
  SPLD_LOAD_FILES -- files to SP_load, undefined or brace enclosed, 0 terminated list of string literals
*/
int SPCDECL SPLD_MAIN_NAME(int argc, char *argv[])
{
  int dsp;
  int rv;
  int sp_argc;
  char **sp_argv;
  SP_pred_ref main_pred;
  int need_deinitialize=0;                 /* glue_initialize called? */
  int result = 0;

  /* [PM] 4.3 Set process locale. POSIX only. */
#if SPLD_SET_PROCESS_LOCALE
  {
    /* Which locale name should we use? Default is to let OS ask the environment. */
#if !defined(SPLD_PROCESS_LOCALE_NAME)
    /* The empty string means locale as specified in environment but you
       could specify some hardwired locale by passing, e.g.
          -DSPLD_PROCESS_LOCALE_NAME=C
    */
#define SPLD_PROCESS_LOCALE_NAME /* empty */
#endif /* !defined(SPLD_PROCESS_LOCALE_NAME) */

    /* #define SPLD_PROCESS_LOCALE_STRING "" */
#if !defined(SPLD_STRINGIFY)
#define SPLD_STRINGIFY_(x) #x
#define SPLD_STRINGIFY(x) SPLD_STRINGIFY_(x)
#endif /* !defined(SPLD_STRINGIFY) */


#define SPLD_PROCESS_LOCALE_STRING SPLD_STRINGIFY(SPLD_PROCESS_LOCALE_NAME)


    {
      char * locale_name = SPLD_PROCESS_LOCALE_STRING;
      /* default is setlocale(LC_ALL, ""), i.e. set all locale related things from environment. */
      if (setlocale(LC_ALL, locale_name) == NULL) {
        /* Setting LC_ALL failed for some reason.

           We really only care about char encoding et al.
           (LC_CTYPE). Also, Mac OS X seems to use locale name that only
           contain the encoding, so they do not work with LC_ALL.

           10.5 Terminal.app sets LANG=UTF-8 which only works with
           LC_CTYPE. Terminal in Mac OS X 10.7 seems to ignore its
           International settings...

        */
        if (setlocale(LC_CTYPE, locale_name) == NULL) {
          /* Could not set process locale at all. */
          fprintf(stderr, "Failed to set locale to \"%s\". Exiting\n",
                  (locale_name[0] == 0 ? "default" : locale_name));
          result = 1;
          goto cleanup;
        }
      }
    }
  }
#endif /* SPLD_SET_PROCESS_LOCALE */

  dsp = (SPLD_DSP);

  SetupSICStusDISPATCH();

#if SPLD_INTERACTIVE
  SP_force_interactive();
#endif /* SPLD_INTERACTIVE */

#if SPLD_USERHOOK
  if (0 != (rv = SU_initialize(argc,argv)))
    {
      result = rv;
      goto cleanup;
    }
#endif /* SPLD_USERHOOK */

  sp_argc = ( argc > 0 ? argc-1 : 0 );
  sp_argv = ( argc > 0 ? argv+1 : argv );

  /* [PM] 4.0.3 Use SP_set_argv to pass argc,argv instead of passing them to sp_glue_initialize */
  rv = sp_glue_initialize(0 /* sp_argc*/, NULL /* sp_argv */,NULL,sp_pre_linkage,sp_pre_map,dsp,SP_GLUE_INITIALIZE_OPTION_RESTORE);
  need_deinitialize = 1;        /* need SP_deinitialize even if sp_glue_initialize failed ([PM] 4.0.5 could be partially inited) */
  if (rv != SP_SUCCESS)
    {
      if (SP_errno == 3 /* NOT_FIND_BOOTFILE */)
        {
          fprintf(stderr, "! Prolog engine initialization failed: could not find bootfile %s\n",
                  sp_get_failed_bootpath()); fflush(stderr);
        }
      else if (SP_errno)
        {
          fprintf(stderr, "! Prolog engine initialization failed: %s\n", SP_error_message(SP_errno)); fflush(stderr);
        }
      else
        {
          fprintf(stderr, "! Prolog engine initialization failed\n"); fflush(stderr);
        }
      result=1;
      goto cleanup;
    }


  if (!SP_set_argv(sp_argc, sp_argv,
#if SP_USER_MAIN_ARGV_UTF8      /* argv is UTF-8, e.g. Windows */
                   SPIO_OPTION_NONE
#else  /* !SP_USER_MAIN_ARGV_UTF8 argv uses some (locale-based) system encoding */
                   SP_SET_ARGV_OPTION_SYSTEM_ENCODING
#endif  /* !SP_SET_ARGV_OPTION_SYSTEM_ENCODING */
                   ))
    {
      fprintf(stderr, "! Prolog engine initialization failed. Malformed or overlong command line.\n"); fflush(stderr);
      result=1;
      goto cleanup;
    }


#ifdef SPLD_SAV_FILE
  rv = SP_restore(SPLD_SAV_FILE);
  if (rv != SP_SUCCESS)
    {
      /* [PM] 3.12.3 SPRM 8748, detect special exceptions. Important
         if sav-file was created with non-trivial second (predicate-)
         argument to save_program. */
      if (rv == SP_ERROR)
        {
          SP_integer data;
          switch (get_reserved_exception(&data))
            {
            case 4:         /* halt/[0,1] */
              result = (int) data;
              goto cleanup;
            case 3:         /* abort/0 (treated like halt(1) */
              result=1;     /* unsuccessful exit (but silent) */
              goto cleanup;
            default:        /* unknown/malformed */
              ;
              /* FALLTHROUGH */
            }
        }
      fprintf(stderr,"! Could not restore \"" SPLD_SAV_FILE "\".\n"); fflush(stderr);
      result=1;
      goto cleanup;
    }
#endif /* SPLD_SAV_FILE */

#ifdef SPLD_LOAD_FILES
  {
    char const* load_files[] = SPLD_LOAD_FILES;
    char const * const * pf;
    
    for (pf = &load_files[0]; *pf; pf++)
      {
        /* .pl, .ql, and .po are handled by SP_load() */
        rv = SP_load(*pf);
        if (rv != SP_SUCCESS)
          {
            fprintf(stderr,"! Could not load \"%s\".\n", *pf); fflush(stderr);
            result=1;
            goto cleanup;
          }
      }
  }
#endif /* SPLD_LOAD_FILES */

  main_pred = SP_predicate("main",0,"prolog"); /* known to exist */
  if (main_pred == NULL)
    {
      fprintf(stderr,"! Could not find entrypoint: %s\n",SP_error_message(SP_errno)); fflush(stderr);
      result=1;
      goto cleanup;
    }
  rv = SP_query(main_pred);

  if (rv != SP_SUCCESS)
    {
      /* [PM] 4.0 $reserved/1 exceptions are no longer caught by
         main/0. Handle them here instead (needed for halt/1 argument
         propagation)  */
      if (rv == SP_ERROR)
        {
          SP_integer data;
          switch (get_reserved_exception(&data))
            {
            case 4:         /* halt/[0,1] */
              result = (int) data;
              goto cleanup;
            case 3:         /* abort/0 (treated like halt(1) */
              result=1;
              goto cleanup;
            default:        /* unknown/malformed */
              ;
              /* FALLTHROUGH */
            }
        }
      result = 1;
    }

  goto cleanup;

 cleanup:
  if (need_deinitialize) (void)SP_deinitialize();
  return result;
}


#if !SPLD_USERHOOK /* this is needed for development systems (called by user_main in main.c) */
int SPCDECL SU_initialize(int argc, char *argv[])
{
  (void)argc; (void)argv;
  return 0;
}
#endif /* !SPLD_USERHOOK */


#endif /* SPLD_GENERATE_MAIN */


#if !SPLD_GENERATE_MAIN

#ifndef SP_DYNAMIC_FOREIGN_RESOURCE
#define SP_DYNAMIC_FOREIGN_RESOURCE (SPDLL+0)
#endif

#if (SPDLL || SP_DYNAMIC_FOREIGN_RESOURCE)
#if SP_DYNAMIC_FOREIGN_RESOURCE != SPDLL
#error "C macro inconsistency, SP_DYNAMIC_FOREIGN_RESOURCE should always equal SPDLL"
#endif /* SP_DYNAMIC_FOREIGN_RESOURCE */
#endif /* (SPDLL || SP_DYNAMIC_FOREIGN_RESOURCE) */

#define INCLUDED_IN_FOREIGN_RESOURCE (SP_STATIC_FOREIGN_RESOURCE || SP_DYNAMIC_FOREIGN_RESOURCE)
#if !defined SPIO_INCLUDE_OS_TYPES
#define SPIO_INCLUDE_OS_TYPES 0
#endif	/* !defined SPIO_INCLUDE_OS_TYPES */
#define SICSTUS_HIDDEN_API 1
#if LOCAL_INCLUDES
#include "sicstus.h"
#else
#include <sicstus/sicstus.h> /* typedef SICSTUS_DISPATCH_TABLE */
#endif /* LOCAL_INCLUDES */

#if !SP_STATIC_FOREIGN_RESOURCE /* if static then instead use main app sp_GlobalSICStus */

#if (MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE) || (MULTI_SP_AWARE && SP_ALLOW_MULTI_STATIC)
/* A multi SP need to pass around the API so should need no global variable for API */
/* nothing */
#else  /* !(MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE) */

/* By default what GetSICStusDISPATCH() returns */
SICSTUS_API_STRUCT_TYPE *sp_GlobalSICStus = 0;
#endif /* !(MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE) */

#endif /* !SP_STATIC_FOREIGN_RESOURCE */

#if INCLUDED_IN_FOREIGN_RESOURCE /* [PM] 3.9b4 rest of file only used when included in foreign resource. */

#if INCLUDED_IN_FOREIGN_RESOURCE

/* [PM] 3.9 These should handle various degrees of MULTI SP awareness in each foreign function stub
            See internals.tex for more info.
*/

#if MULTI_SP_AWARE

/* xref flids.c */

#define SP_STUB_LOCAL_DECLARATIONS(_RESNAME) SPAPI_ARG_LOCAL_DECL
#define SP_STUB_SETUP_API(_RESNAME) SPAPI_ARG_NAME = spenv;
#define SP_MAYBE_UNLOCK_SINGLE_THREADED_RESOURCE(_RESNAME)

#else  /* !MULTI_SP_AWARE */

#define SP_STUB_LOCAL_DECLARATIONS(_RESNAME)
#define SP_STUB_SETUP_API(_RESNAME) /* nothing */
#define SP_MAYBE_UNLOCK_SINGLE_THREADED_RESOURCE(_RESNAME)

#endif /* !MULTI_SP_AWARE */

#endif /* INCLUDED_IN_FOREIGN_RESOURCE */

typedef enum {
  sp_main_no_err=0,
  sp_main_err_param=1,          /* Incorrect parameters */
  /* Version mismatch between this resource and (calling run-time or calling params) */
  sp_main_version_err=2,
  /* non-MULTI_SP foreign resource invoked from more than once run-time */
  sp_main_err_multiple=3,
  sp_main_err_mutex=4
} sp_main_errcode;


/* foreign resource include this file just before 
   calling sp_main_helper so we can (and must if SP_STATIC_FOREIGN_RESOURCE)
   make it static   */
/* the generated sp_main_<RESOURCE> will just call sp_main_helper to do the work */
static int SPCDECL sp_main_helper(SP_MAINFUN_PARAMS *params,
                           unsigned long version,
                           SICSTUS_API_STRUCT_TYPE **papi,
                           SP_mutex *mutex,
#if SP_FLI_APPLY_ASM_GENERIC
                           const SP_GenericGlueFunPtr  glue_funcs[],
#else  /* !SP_FLI_APPLY_ASM_GENERIC */
                           const SP_GlueFunPtr  fli_funcs[],
#endif  /* !SP_FLI_APPLY_ASM_GENERIC */
                           const char* prednames[],
                           const int   arities[],
#if MULTI_SP_AWARE
                           SP_InitFunMulti* init_fun,
                           SP_InitFunMulti* deinit_fun
#else  /* !MULTI_SP_AWARE */
                           SP_InitFunPlain* init_fun,
                           SP_InitFunPlain* deinit_fun
#endif  /* !MULTI_SP_AWARE */
                           )
{
  int err_code = 1;
  static int invocations = 0;
  SICSTUS_API_STRUCT_TYPE *api;
  /* avoid warnings about unused variables */
  (void)invocations; (void)papi; (void)mutex;

  if (version != SP_MAINFUN_PARAMS_VERSION) { err_code = sp_main_version_err; goto barf; }
  /* [PM] 4.2.3+ cast to avoid sign mismatch warnings. SPRM 13081. */
  if (((unsigned long) params->version) != version) { err_code = sp_main_version_err; goto barf; }

  /* [PM] 4.2.1+ verify FLI calling convention. */
  {
    int expects_glue = ((params->flags & SP_MAINFUN_PARAM_FLAG_IN_GLUE) != 0);
#if SP_FLI_APPLY_ASM_GENERIC
    if (!expects_glue) { err_code = sp_main_version_err; goto barf; }
    params->flags |= SP_MAINFUN_PARAM_FLAG_OUT_GLUE;
#else  /* !SP_FLI_APPLY_ASM_GENERIC */
    if (expects_glue) { err_code = sp_main_version_err; goto barf; }
#endif /* !SP_FLI_APPLY_ASM_GENERIC */
  }

  api = params->spenv;
  if (api == NULL) { err_code = sp_main_err_param; goto barf; }
  {
    struct DISPATCH_TABLE_STRUCT_SICSTUS_H *sicstus_h_dispatch = api->dispatch_API_SICSTUS_H;
    if (sicstus_h_dispatch == NULL) { err_code = sp_main_err_param; goto barf; }
    if ((sicstus_h_dispatch->version >> 16) != SP_DISPATCH_API_VERSION_MAJOR) { err_code = sp_main_version_err; goto barf; }
    if ((sicstus_h_dispatch->version - (SP_DISPATCH_API_VERSION_MAJOR<<16)) >= SP_DISPATCH_API_VERSION_MINOR)
      {
        /* run-time minor version is at least as large as compile-time minor version*/
        if ((sicstus_h_dispatch->version - (SP_DISPATCH_API_VERSION_MAJOR<<16)) == SP_DISPATCH_API_VERSION_MINOR)
          {
            /* perfect match */
          }
        else
          {
            /* run-time version is larger than compile-time version. */
#if SP_REQUIRE_PERFECT_API_VERSION_MATCH
            { err_code = sp_main_version_err; goto barf; }
#endif  /* SP_REQUIRE_PERFECT_API_VERSION_MATCH */
          }
      }
    else
      {
        { err_code = sp_main_version_err; goto barf; }
      }
  }

  /* Check if more than one SICStus is trying to use this resource */
#if MULTI_SP_AWARE
  /* nothing, multiple use is OK. */

  params->flags |= SP_MAINFUN_PARAM_FLAG_OUT_MULTI;

#else  /* !MULTI_SP_AWARE */

  params->flags |= SP_MAINFUN_PARAM_FLAG_OUT_PLAIN;

#if SP_DYNAMIC_FOREIGN_RESOURCE
  *papi = api; /* must be done even if !SP_MAINFUN_PARAM_FLAG_IN_ENTER so that caller can use SP_XXX on unload too.*/

  {
  /* sharing between multiple sicstus can only happen for shared
     library versions of a foreign resource. */
  if (params->flags & SP_MAINFUN_PARAM_FLAG_IN_ENTER)
    {
      /* The following sets up the SICStus API in a way that would
         work even if MULTI_SP_AWARE had been true (which it is not,
         due to the #if above. The reason for setting things up is to
         give an example for future maintainers. */
      int invocation;
      SPAPI_ARG_PROTO_DECL;        /* needed if MULTI_SP_AWARE */

      /* The following two will write to the same global variable unless
         MULTI_SP_AWARE */
#if SICSTUS_DBG
#if MULTI_SP_AWARE
         if (GetSICStusDISPATCHAddress() == papi) /* GetSICStusDISPATCHAddress() should give address of a local variable */
           {
             fprintf(stderr, "\n *** ERROR: invariant error MULTI_SP_AWARE GetSICStusDISPATCHAddress() == papi (%p==%p)\n",
                     GetSICStusDISPATCHAddress(), papi);
             fflush(stderr); abort();
           }
#else/* !MULTI_SP_AWARE */
         if (GetSICStusDISPATCHAddress() != papi) /* both should point at the same global variable */
           {
             fprintf(stderr, "\n *** ERROR: invariant error !MULTI_SP_AWARE GetSICStusDISPATCHAddress() != papi (%p!=%p)\n",
                     GetSICStusDISPATCHAddress(), papi);
             fflush(stderr); abort();
           }
#endif/* !MULTI_SP_AWARE */
#endif  /* SICSTUS_DBG */

#if MULTI_SP_AWARE
      (*GetSICStusDISPATCHAddress())=api; /* makes SP_XXX API accessible by setting SPAPI_ARG_PROTO_DECL */
#endif/* MULTI_SP_AWARE */

      if (!SP_mutex_lock(mutex))
        {
#if SICSTUS_DBG
          fprintf(stderr, "\n *** ERROR: SP_mutex_lock() error\n"); fflush(stderr); abort();
#endif /* SICSTUS_DBG */
          err_code = sp_main_err_mutex;
          goto barf;            /* without attempting to unlock the mutex */
        }
      invocation = ++invocations;
      if (!SP_mutex_unlock(mutex))
        {
#if SICSTUS_DBG
          fprintf(stderr, "\n *** ERROR: SP_mutex_unlock() error\n"); fflush(stderr); abort();
#endif /* SICSTUS_DBG */
          err_code = sp_main_err_mutex;
          goto barf;
        }

      if (invocation != 1)
        {
#if SICSTUS_DBG
          fprintf(stderr, "\nERROR: non-MULTI_SP_AWARE resource loaded multiple times\n");
#endif  /* SICSTUS_DBG */
          err_code = sp_main_err_multiple;
          goto barf;
        }
    }
  else
    {
       ; /* nothing */
    }
  }
#endif /* SP_DYNAMIC_FOREIGN_RESOURCE */
#endif /* !MULTI_SP_AWARE */

#if SP_FLI_APPLY_ASM_GENERIC
  params->glue_funcs = glue_funcs;
#else  /* !SP_FLI_APPLY_ASM_GENERIC */
  params->funcs = fli_funcs;
#endif  /* !SP_FLI_APPLY_ASM_GENERIC */

  params->prednames = prednames;
  params->arities = arities;
#if MULTI_SP_AWARE
  params->init_fun.multi = init_fun;
  params->deinit_fun.multi = deinit_fun;
#else  /* !MULTI_SP_AWARE */
  params->init_fun.plain = init_fun;
  params->deinit_fun.plain = deinit_fun;
#endif  /* !MULTI_SP_AWARE */
  err_code = 0;
 barf:
  return err_code;
}

#endif /* INCLUDED_IN_FOREIGN_RESOURCE */

#endif /* !SPLD_GENERATE_MAIN */
